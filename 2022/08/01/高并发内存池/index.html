<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="高并发内存池, Blog，coding">
    <meta name="description" content="言之命至">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>高并发内存池 | Allen 的 blog</title>
    <link rel="icon" type="image/png" href="/BlogNet/favicon.png">

    <link rel="stylesheet" type="text/css" href="/BlogNet/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/BlogNet/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/BlogNet/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/BlogNet/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/BlogNet/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/BlogNet/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/BlogNet/css/my.css">

    <script src="/BlogNet/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/BlogNet/atom.xml" title="Allen 的 blog" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/BlogNet/" class="waves-effect waves-light">
                    
                    <img src="/BlogNet/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Allen 的 blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/BlogNet/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/BlogNet/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Allen 的 blog</div>
        <div class="logo-desc">
            
            言之命至
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/BlogNet/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/BlogNet/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">高并发内存池</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/BlogNet/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/BlogNet/tags/%E9%A1%B9%E7%9B%AE/">
                                <span class="chip bg-color">项目</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-08-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/BlogNet/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[toc]</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>为了学习和提高设计能力，检验编程思想以及编程能力，以下开始学习并探究实现高并发内存池项目</p>
<p>本项目实现的是一个高并发的内存池，它是Google的一个开源项目tcmalloc的迷你版，tcmalloc全称Thread-Caching Malloc，即线程缓存的malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数malloc和free。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208211705700.png" alt="image-20220821170456564"></p>
<p>tcmalloc高知名度的大项目，是全球顶尖的C++大佬联手创造的项目，不少公司都在用它，而Go语言就直接用它做了自己的内存分配器。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301446105.png" alt="image-20220830144611046"></p>
<p>该项目就是把tcmalloc中最核心的框架简化后拿出来，模拟实现出一个mini版的高并发内存池，目的就是学习tcmalloc的精华。</p>
<p>该项目主要涉及C/C++、数据结构（链表、哈希桶）、操作系统内存管理、单例模式、多线程、互斥锁等方面的技术。</p>
<h2 id="什么是内存池"><a href="#什么是内存池" class="headerlink" title="什么是内存池"></a>什么是内存池</h2><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><p>所谓“池化技术”，就是<strong>程序先向系统申请过量的资源，然后自己进行管理，以备不时之需。</strong></p>
<p><span style="color:lightseagreen">之所以要申请过量的资源，是因为申请和释放资源都有较大的开销，不如提前申请一些资源放入“池”中，当需要资源时直接从“池”中获取，不需要时就将该资源重新放回“池”中即可。</span>这样使用时就会变得非常快捷，可以大大提高程序的运行效率。</p>
<p>其实我们还有很多使用“池”这种技术的地方，除了内存池之外，还有连接池、线程池、对象池等。</p>
<p>以服务器上的线程池为例，它的主要思想就是：先启动若干数量的线程，让它们处于睡眠状态，当接收到客户端的请求时，唤醒池中某个睡眠的线程，让它来处理客户端的请求，当处理完这个请求后，线程又进入睡眠状态。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>内存池是指程序预先向操作系统申请一块足够大的内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当释放内存的时候，并不是真正将内存返回给操作系统，而是将内存返回给内存池。当程序退出时（或某个特定时间），内存池才将之前申请的内存真正释放。</p>
<h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>内存池主要解决的就是效率的问题，它能够避免让程序频繁的向系统申请和释放内存。</p>
<h4 id="解决内存碎片"><a href="#解决内存碎片" class="headerlink" title="解决内存碎片"></a>解决内存碎片</h4><p>其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301404371.png" alt="image-20220830140353243"></p>
<p>内存碎片是指您的大部分内存被分配在大量不连续的块或块中 - 使您的总内存中有很大一部分未分配，但在大多数典型情况下无法使用。这会导致内存不足异常或分配错误（即 malloc 返回 null）。</p>
<p>考虑这一点的最简单方法是想象你有一面大的空墙，你需要在上面放置不同尺寸的图片。每张图片都占据一定的尺寸，您显然无法将其拆分成更小的部分以使其适合。你需要在墙上有一个空的地方，图片的大小，否则你不能把它放上去。现在，如果你开始把照片挂在墙上，但你不小心如何安排它们，你很快就会看到一面墙被部分照片覆盖，即使你可能有空位，大多数新照片都不适合因为它们比可用的位置大。您仍然可以挂非常小的图片，但大多数图片不适合。所以你必须重新排列（紧凑）已经在墙上的那些，以便为更多空间腾出空间。</p>
<h5 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h5><p><strong>外部碎片</strong>是一些空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配申请需求。</p>
<p><strong>内部碎片</strong>是由于一些对齐的需求，导致分配出去的空间中一些内存无法被利用。</p>
<p>注意： 内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>C/C++中我们要动态申请内存并不是直接去堆申请的，而是通过malloc函数去申请的，包括C++中的new实际上也是封装了malloc函数的。</p>
<p>我们申请内存块时是先调用malloc，malloc再去向操作系统申请内存。malloc实际就是一个内存池，malloc相当于向操作系统“批发”了一块较大的内存空间，然后“零售”给程序用，当全部“售完”或程序有大量的内存需求时，再根据实际需求向操作系统“进货”。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301429040.png" alt="image-20220830142903941"></p>
<p>malloc的实现方式有很多种，一般不同编译器平台用的都是不同的。比如Windows的VS系列中的malloc就是微软自行实现的一套，而Linux下的gcc用的是glibc中的ptmalloc。</p>
<p><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>那我们既然已经有了malloc，为什么还需要学习使用tcmalloc的模拟呢？</strong></p>
<blockquote>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301431381.png" alt="image-20220830143143335"></p>
<p>也就是说tcmalloc是一个比malloc在多线程模式下更快的一个内存池</p>
</blockquote>
<h2 id="实现一个定长内存池"><a href="#实现一个定长内存池" class="headerlink" title="实现一个定长内存池"></a>实现一个定长内存池</h2><blockquote>
<p>“尺有所短 寸有所长”</p>
</blockquote>
<p>malloc其实就是一个通用的内存池，在什么场景下都可以使用，但这也意味着malloc在什么场景下都不会有很高的性能，因为malloc并不是针对某种场景专门设计的。</p>
<p>定长内存池就是针对固定大小内存块的申请和释放的内存池，<strong>由于定长内存池只需要支持固定大小内存块的申请和释放，因此我们可以将其性能做到极致，并且在实现定长内存池时不需要考虑内存碎片等问题</strong>，因为我们申请/释放的都是固定大小的内存块。</p>
<p>通过实现定长内存池我们可以来熟悉一下对简单内存池的控制，其次这个定长内存池后面会作为高并发内存池的一个基础组件，后期也会使用到</p>
<h3 id="实现定长"><a href="#实现定长" class="headerlink" title="实现定长"></a>实现定长</h3><p>我们可以使用非类型模板参数，使得在该内存池中申请到的对象的大小都是N。</p>
<p>同时定长内存池也叫做对象池，在创建对象池时，对象池可以根据传入的对象类型的大小来实现“定长”，因此我们可以通过使用模板参数来实现“定长”，比如创建定长内存池时传入的对象类型是int，那么该内存池就只支持4字节大小内存的申请和释放。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//用模板控制了大小</span>
<span class="token comment">//template&lt;size_t N&gt;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">ObjectPool</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="设计成员变量"><a href="#设计成员变量" class="headerlink" title="设计成员变量"></a>设计成员变量</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token comment">//指向大块内存的指针。</span>
<span class="token keyword">int</span> _remainBytes <span class="token comment">//大块内存切分过程中剩余字节数。</span>
<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token comment">//还回来过程中链接的自由链表的头指针。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意初始化，不初始化的报错：</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301738257.png" alt="image-20220830173811179"></p>
<p><strong>规则1：内置类型的变量如果初始化，则它的默认初始化值取决于定义它的位置</strong></p>
<ul>
<li><strong>定义在任何函数之外的未初始化的内置类型变量（也就是全局变量）会被默认初始化为0</strong></li>
<li><strong>定义在函数体内部的（包括main函数）未初始化的内置类型变量（也就是局部变量）的默认初始值是未定义的（也就是一个随机数）。如果试图拷贝或以其他方式访问该变量的值，此时会引发编译错误</strong></li>
</ul>
<p><strong>规则2：未初始化的内置类型的全局变量的默认初始化值还取决于变量的数据类型：</strong></p>
<ul>
<li><strong>数值数据类型的未初始化全局变量的默认初始值为0</strong></li>
<li><strong>bool类型的未初始化的全局变量的默认初始化值为false（也就是0）</strong></li>
<li><strong>char类型的未初始化的全局变量的默认初始化值为‘\0’（ASCII码值为0）</strong> </li>
<li><strong>string类型（姑且当成内置类型）的未初始化的全局变量的默认初始值为“”</strong></li>
</ul>
<p><strong>规则3：静态变量无论是全局变量还是局部变量，编译器都会给其默认初始化值，值为多少取决于变量的数据类型</strong></p>
<p><strong>规则4：指针类型的全局未初始化的变量的默认初始值为NULL，而指针类型的局部未初始化变量的默认值这是未定义的（在有些编译器下定义为初始化的局部指针变量会报错）</strong></p>
<h4 id="指针记录"><a href="#指针记录" class="headerlink" title="指针记录"></a>指针记录</h4><p>对于向堆申请到的大块内存，我们可以用一个指针来对其进行管理</p>
<p>由于此后我们需要将这块内存进行切分，为了方便切分操作，指向这块内存的指针最好是字符指针，因为指针的类型决定了指针向前或向后走一步有多大距离，对于字符指针来说，当我们需要向后移动n个字节时，直接对字符指针进行加n操作即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301457386.png" alt="image-20220830145721335"></p>
<p>这里使用<code>char*</code>而不适用<code>void*</code>的原因是，后期需要进行切片，使用void*方便++和–操作，同时一个字节为大小的话，后期大小好控制（相较于int）</p>
<h4 id="自由链表"><a href="#自由链表" class="headerlink" title="自由链表"></a>自由链表</h4><p>同时释放回来的定长内存块也需要被管理，我们可以将这些释放回来的定长内存块链接成一个链表，这里我们将管理释放回来的内存块的链表叫做自由链表，为了能找到这个自由链表，我们还需要一个指向自由链表的指针。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301457924.png" alt="image-20220830145729885"></p>
<p>我们将我们之前释放的每一块内存块表示成一个节点，我们去这个节点的前四个字节保存连接下一个节点的地址（需要处理小于四字节的情况）</p>
<h4 id="剩余字节数"><a href="#剩余字节数" class="headerlink" title="剩余字节数"></a>剩余字节数</h4><p>仅用一个指针管理内存池肯定是不够的，我们还需要用一个变量来记录这块内存的长度。</p>
<p>如果没有一个size代表着剩余的长度的话有可能就一下子取光越界了</p>
<p>于是我们针对这个剩余字节数，如果剩的够的话，就留着，如果不够了就需要再开辟</p>
<h3 id="从内存池申请对象"><a href="#从内存池申请对象" class="headerlink" title="从内存池申请对象"></a>从内存池申请对象</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在一切的开始，初始化一下内存池，如果剩余大小不够了，就重新开一个内存空间</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">  <span class="token comment">//一个对象都不够的话，就重新申请</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    _remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    _memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>_remainBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//128KB</span>
    <span class="token comment">//逻辑上切一个T大小的对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="重复利用"><a href="#重复利用" class="headerlink" title="重复利用"></a>重复利用</h4><p>当我们申请对象时，内存池应该优先把还回来的内存块对象再次重复利用，因此如果自由链表当中有内存块的话，就直接从自由链表头删一个内存块进行返回即可。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301702409.png" alt="image-20220830170203369"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//优先还回来的内存块重复利用</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span>
<span class="token punctuation">{</span>	<span class="token comment">//头删操作</span>
	<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下一个节点的地址</span>
    obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>
    _freeList <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//切片出去了</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="利用剩余内存池块"><a href="#利用剩余内存池块" class="headerlink" title="利用剩余内存池块"></a>利用剩余内存池块</h4><p>如果自由链表当中没有内存块，那么我们就在大块内存中切出定长的内存块进行返回，当内存块切出后及时更新<code>_memory</code>指针的指向，以及<code>_remainBytes</code>的值即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>
_memory <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//偏移</span>
_remainBytes <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301704351.png" alt="image-20220830170406273"></p>
<p><strong>需要特别注意的是，由于当内存块释放时我们需要将内存块链接到自由链表当中，因此我们必须保证切出来的对象至少能够存储得下一个地址，所以当对象的大小小于当前所在平台指针的大小时，需要按指针的大小进行内存块的切分。</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>
<span class="token keyword">const</span> size_t objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>

_memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> <span class="token comment">//偏移</span>
_remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span>

<span class="token keyword">return</span> obj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    T<span class="token operator">*</span> obj <span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>

    <span class="token comment">//优先还回来的内存块重复利用</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>	<span class="token comment">//头删操作</span>
 		<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下一个节点的地址</span>
        obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>
        _freeList <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//切片出去了</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//一个对象都不够的话，就重新申请</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
            _memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>_remainBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//128KB</span>
            <span class="token comment">//逻辑上切一个T大小的对象</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>
        <span class="token keyword">const</span> size_t objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>

        _memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> <span class="token comment">//偏移</span>
        _remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span>

        <span class="token comment">//定位new显示调用T的构造函数初始化</span>
        <span class="token keyword">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>T<span class="token punctuation">;</span>

        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>需要注意的是，与释放对象时需要显示调用该对象的析构函数一样，当内存块切分出来后，我们也应该使用定位new，显示调用该对象的构造函数对其进行初始化。</strong></p>
<h3 id="从内存池释放对象"><a href="#从内存池释放对象" class="headerlink" title="从内存池释放对象"></a>从内存池释放对象</h3><p>对于还回来的定长内存块，我们可以用自由链表将其链接起来，但我们并不需要为其专门定义链式结构，我们可以让内存块的前4个字节（32位平台）或8个字节（64位平台）作为指针，存储后面内存块的起始地址即可。</p>
<h4 id="初始化freelist"><a href="#初始化freelist" class="headerlink" title="初始化freelist"></a>初始化freelist</h4><p>一开始freelist是空的，我们希望在每一个节点的前一个指针大小的字节处，存放下一个节点的指针，可是在32位机器下是需要8个字节的，这时就很难受了，我们如何分别64位和32位？用分支判断太复杂，我们其实可以使用一个更好用简单的方法</p>
<p>我们知道，32位平台下指针的大小是4个字节，64位平台下指针的大小是8个字节。而指针指向数据的类型，决定了指针解引用后能向后访问的空间大小，因此我们这里需要的是一个指向指针的指针，这里使用二级指针就行了。</p>
<p>当我们需要访问一个内存块的前4/8个字节时，我们就可以先该内存块的地址先强转为二级指针（无论是<code>void*</code>还是<code>int*</code>都可以），由于二级指针存储的是一级指针的地址，二级指针解引用能向后访问一个指针的大小，因此在32位平台下访问的就是4个字节，在64位平台下访问的就是8个字节，此时我们访问到了该内存块的前4/8个字节。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>_freeList <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    _freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token comment">//*(int*)obj = nullptr; //获取一个指针的大小 ，但是不好使用64位</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>	
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="后续释放"><a href="#后续释放" class="headerlink" title="后续释放"></a>后续释放</h4><p>这里我们选择头插，这样可以不用去找尾，省去效率</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301651334.png" alt="image-20220830165151259"></p>
<p>在向自由链表插入被释放的内存块时，先让该内存块的前4个字节或8个字节存储自由链表中第一个内存块的地址，然后再让<code>_freeList</code>指向该内存块即可，也就是一个简单的链表头插操作。</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>此时的delete函数，由于头插是和初始化不冲突的，所以说我们可以不用分支判断，直接一步到位</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//调用析构函数</span>
		obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="如何直接从堆申请空间？"><a href="#如何直接从堆申请空间？" class="headerlink" title="如何直接从堆申请空间？"></a>如何直接从堆申请空间？</h3><p>既然是内存池，那么我们首先得向系统申请一块内存空间，然后对其进行管理。要想直接向堆申请内存空间，在Windows下，可以调用VirtualAlloc函数；在Linux下，可以调用brk或mmap函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token comment">//...</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">//直接去堆上申请按页申请空间</span>
<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>size_t kpage<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> kpage<span class="token operator">&lt;&lt;</span><span class="token number">13</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token comment">// linux下brk mmap等</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里我们可以通过条件编译将对应平台下向堆申请内存的函数进行封装，此后我们就不必再关心当前所在平台，当我们需要直接向堆申请内存时直接调用我们封装后的SystemAlloc函数即可。</p>
<h3 id="测试性能-amp-amp-调整过后的pool"><a href="#测试性能-amp-amp-调整过后的pool" class="headerlink" title="测试性能&amp;&amp;调整过后的pool"></a>测试性能&amp;&amp;调整过后的pool</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> fixed_length_pool
<span class="token punctuation">{</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token comment">//...</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">//直接去堆上申请按页申请空间</span>
<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>size_t kpage<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> kpage<span class="token operator">&lt;&lt;</span><span class="token number">13</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token comment">// linux下brk mmap等</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">ObjectPool</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	T<span class="token operator">*</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		T<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

		<span class="token comment">//优先还回来的内存块重复利用</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>	<span class="token comment">//头删操作</span>
			<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下一个节点的地址</span>
			obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>
			_freeList <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//切片出去了</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">else</span>
		<span class="token punctuation">{</span>
			<span class="token comment">//一个对象都不够的话，就重新申请</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				_remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
				<span class="token comment">// _memory = (char*)malloc(_remainBytes);  //128KB</span>
				_memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>_remainBytes <span class="token operator">&gt;&gt;</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//除8K换算出页数</span>


				<span class="token comment">//逻辑上切一个T大小的对象</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
					<span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>
			<span class="token keyword">const</span> size_t objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>

			_memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> <span class="token comment">//偏移</span>
			_remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span>

			<span class="token comment">//定位new显示调用T的构造函数初始化</span>
			<span class="token keyword">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>T<span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//调用析构函数</span>
		obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">char</span><span class="token operator">*</span> _memory <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//指向大块内存的指针。</span>
	<span class="token keyword">int</span> _remainBytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//大块内存切分过程中剩余字节数。</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//还回来过程中链接的自由链表的头指针。</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> _left<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> _right<span class="token punctuation">;</span>
	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">TestObjectPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 申请释放的轮次</span>
	<span class="token keyword">const</span> size_t Rounds <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token comment">// 每轮申请释放多少次</span>
	<span class="token keyword">const</span> size_t N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
	v1<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">delete</span> v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ObjectPool<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> TNPool<span class="token punctuation">;</span>
	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
	v2<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>TNPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			TNPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		v2<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"new cost time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"object pool cost time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用malloc时，对比</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301734134.png" alt="image-20220830173459075"></p>
<h2 id="内存池框架设计"><a href="#内存池框架设计" class="headerlink" title="内存池框架设计"></a>内存池框架设计</h2><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>现代的设计往往单核但进程已经是性能达到极限了，所以往往转向多核多进程的设计</p>
<p>现代很多的开发环境也都是多核多线程，因此在申请内存时，必然存在激烈的锁竞争问题。malloc本身其实已经很优秀了，但是在并发场景下可能会因为频繁的加锁和解锁导致效率有所降低，而该项目的原型tcmalloc实现的就是一种在多线程高并发场景下更胜一筹的内存池。</p>
<p>在实现高并发内存池时我们一般需要考虑：</p>
<ol>
<li>性能问题。（一般内存池）</li>
<li>多线程环境下，锁竞争问题。（高并发的内存池需要考虑该问题）</li>
<li>内存碎片问题。（一般内存池）</li>
</ol>
<h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311003227.png" alt="image-20220831100345062"></p>
<p>高并发内存池主要由以下三个部分构成：</p>
<h4 id="thread-cache"><a href="#thread-cache" class="headerlink" title="thread cache"></a>thread cache</h4><p>thread cache就是一个类，他是一个内存的数据结构</p>
<p>好处是线程缓存是每个线程独有的，每个线程申请内存的时候都是不用加锁的，这也就是这个并发线程池高效的地方</p>
<p>不过它用于小于等于256KB的内存分配</p>
<p>每个线程独享一个thread cache。</p>
<p>但是thread cache不可能永远是够的，总会出现内存取光的情况</p>
<h4 id="central-cache"><a href="#central-cache" class="headerlink" title="central cache"></a>central cache</h4><p><strong>中心缓存是所有线程所共享</strong></p>
<p>当thread cache需要内存时会<strong>按需从central cache中获取</strong>内存</p>
<p>central cache合适的时机回收thread cache中的对象，避免<strong>一个线程占用了太多的内存，而其他线程的内存吃紧</strong>，它可以达到内存分配在多个线程中更均衡的按需调度的目的</p>
<p>central cache是存在竞争的，所以从这里取内存对象是需要加锁，首先这里用的是桶锁，其次只有thread cache同时没有内存对象时才会找central cache，所以这里锁竞争不会很激烈</p>
<h4 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h4><p>页缓存中存储的内存是以页为单位进行存储及分配的，当central cache需要内存时，page cache会分配出一定数量的页分配给central cache，而当central cache中的内存满足一定条件时，page cache也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</p>
<p>page cache如果没有的话就去系统找堆去要</p>
<h2 id="thread-cache-1"><a href="#thread-cache-1" class="headerlink" title="thread cache"></a>thread cache</h2><h3 id="设计threadcache"><a href="#设计threadcache" class="headerlink" title="设计threadcache"></a>设计threadcache</h3><p>定长内存池只支持固定大小内存块的申请释放，因此定长内存池中只需要一个自由链表管理释放回来的内存块。现在我们要支持申请和释放不同大小的内存块，那么我们就需要多个自由链表来管理释放回来的内存块，因此thread cache实际上一个哈希桶结构，每个桶中存放的都是一个自由链表。</p>
<p>thread cache支持小于等于256KB内存的申请，如果我们将每种字节数的内存块都用一个自由链表进行管理的话，那么此时我们就需要20多万个自由链表，光是存储这些自由链表的头指针就需要消耗大量内存，这显然是得不偿失的。所以我们可以将某一个字节范围内的需求归到一个指定的对齐字节的自由链表统一分配  </p>
<p>这时我们可以选择做一些平衡的牺牲，让这些字节数按照某种规则进行对齐，例如我们让这些字节数都按照8字节进行向上对齐，那么thread cache的结构就是下面这样的，此时当线程申请<code>1~8</code>字节的内存时会直接给出8字节，而当线程申请<code>9~16</code>字节的内存时会直接给出16字节，以此类推。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311027210.png" alt="image-20220831102717104"></p>
<p><strong>因此当线程要申请某一大小的内存块时，就需要经过某种计算得到对齐后的字节数，进而找到对应的哈希桶</strong>，如果该哈希桶中的自由链表中有内存块，那就从自由链表中头删一个内存块进行返回；如果该自由链表已经为空了，那么就需要向下一层的central cache进行获取了。</p>
<p>但此时由于对齐的原因，就可能会产生一些碎片化的内存无法被利用，比如线程只申请了6字节的内存，而thread cache却直接给了8字节的内存，这多给出的2字节就无法被利用，导致了一定程度的空间浪费，这些因为某些对齐原因导致无法被利用的内存，就是内存碎片中的<strong>内部碎片</strong>。</p>
<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><ol>
<li>当内存申请size&lt;=256KB，先获取到线程本地存储的thread cache对象，计算size映射的哈希桶自由链表下标i。</li>
<li>如果自由链表_freeLists[i]中有对象，则直接Pop一个内存对象返回。</li>
<li>如果_freeLists[i]中没有对象时，则批量从central cache中获取一定数量的对象，插入到自由链表并返回一个对象。</li>
</ol>
<h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><ol>
<li>当释放内存小于256k时将内存释放回thread cache，计算size映射自由链表桶位置i，将对象Push到_freeLists[i]。</li>
<li>当链表的长度过长，则回收一部分内存对象到central cache。</li>
</ol>
<h3 id="成员变量-自由链表"><a href="#成员变量-自由链表" class="headerlink" title="成员变量-自由链表"></a>成员变量-自由链表</h3><p>为了方便使用自由链表，我们仿照之前对于自由链表的操作，现在对结构进行封装，目前我们就提供Push和Pop两个成员函数，对应的操作分别是将对象插入到自由链表（头插）和从自由链表获取一个对象（头删），后面在需要时还会添加对应的成员函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//管理切分好的小对象的自由链表</span>
<span class="token keyword">class</span> <span class="token class-name">FreeLIst</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> obj<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 头插</span>
        <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
        _freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//头删</span>
        <span class="token keyword">void</span><span class="token operator">*</span> obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
        _freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="设计hashbucket对齐规则"><a href="#设计hashbucket对齐规则" class="headerlink" title="设计hashbucket对齐规则"></a>设计hashbucket对齐规则</h3><h4 id="如何进行对齐？"><a href="#如何进行对齐？" class="headerlink" title="如何进行对齐？"></a>如何进行对齐？</h4><p>首先，这些内存块是会被链接到自由链表上的，因此一开始肯定是按8字节进行对齐是最合适的，因为我们必须保证这些内存块，无论是在32位平台下还是64位平台下，都至少能够存储得下一个指针。</p>
<p>但如果所有的字节数都按照8字节进行对齐的话，那么我们就需要建立256 × 1024 ÷ 8 = 32768个桶，这个数量还是比较多的，实际上我们可以让不同范围的字节数按照不同的对齐数进行对齐，具体对齐方式如下：</p>
<p>这里的映射规则是对<code>tcmaclloc</code>简化的，<code>tcmaclloc</code>还要复杂</p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>对齐数</th>
<th>hashbucket下标</th>
<th>桶数</th>
</tr>
</thead>
<tbody><tr>
<td>[ 1 ，128 ]</td>
<td>8</td>
<td>[ 0 ， 16 )</td>
<td>16</td>
</tr>
<tr>
<td>[ 128 + 1 ，1024 ]</td>
<td>16</td>
<td>[ 16 ， 72 )</td>
<td>56</td>
</tr>
<tr>
<td>[ 1024 + 1 ，8 × 1024 ]</td>
<td>128</td>
<td>[ 72 ， 128 )</td>
<td>56</td>
</tr>
<tr>
<td>[ 8 × 1024 + 1 ，64 × 1024 ]</td>
<td>1024</td>
<td>[ 128 ， 184 )</td>
<td>56</td>
</tr>
<tr>
<td>[ 64 × 1024 + 1 ，256 × 1024 ]</td>
<td>8×1024</td>
<td>[ 184 ， 208 )</td>
<td>24</td>
</tr>
</tbody></table>
<p>这样整体可以控制到10%左右的浪费，这是怎么算的？</p>
<h4 id="空间浪费率"><a href="#空间浪费率" class="headerlink" title="空间浪费率"></a>空间浪费率</h4><p>虽然对齐产生的内碎片会引起一定程度的空间浪费，但按照上面的对齐规则，我们可以将浪费率控制10%左右。需要说明的是，1~128这个区间我们不做讨论，因为1字节就算是对齐到2字节也有50%的浪费率，这里我们就从第二个区间开始进行计算。</p>
<p>$$<br>浪费率 = \frac{浪费的字节数}{对齐后的字节数}<br>$$</p>
<p> </p>
<p>  根据上面的公式，我们要得到某个区间的最大浪费率，就应该让分子取到最大，让分母取到最小。比如129~1024这个区间，该区域的对齐数是16，那么最大浪费的字节数就是15，而最小对齐后的字节数就是这个区间内的前16个数所对齐到的字节数，也就是144，那么该区间的最大浪费率也就是<code>15 ÷ 144 ≈ 10.42 %</code>同样的道理，后面两个区间的最大浪费率分别是<code>127 ÷ 1152 ≈ 11.02 %</code> 和 <code>1023 ÷ 9216 ≈ 11.10 % </code></p>
<h4 id="实现对齐函数"><a href="#实现对齐函数" class="headerlink" title="实现对齐函数"></a>实现对齐函数</h4><p>需要注意的是，SizeClass类当中的成员函数最好设置为静态成员函数，否则我们在调用这些函数时就需要通过对象去调用，并且对于这些可能会频繁调用的函数，为了减少频繁调用的开销，我们可以考虑将其设置为内联函数。</p>
<h5 id="RoundUp"><a href="#RoundUp" class="headerlink" title="RoundUp"></a>RoundUp</h5><p>在获取某一字节数向上对齐后的字节数时，可以先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">RoundUp</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="RoundUp-1"><a href="#RoundUp-1" class="headerlink" title="RoundUp"></a>RoundUp</h5><p>一般来说正常人都是这么解决对齐问题的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 整体控制在最多10%左右的内碎片浪费</span>
<span class="token comment">// [1,128]					8byte对齐	    freelist[0,16)</span>
<span class="token comment">// [128+1,1024]				16byte对齐	    freelist[16,72)</span>
<span class="token comment">// [1024+1,8*1024]			128byte对齐	    freelist[72,128)</span>
<span class="token comment">// [8*1024+1,64*1024]		1024byte对齐     freelist[128,184)</span>
<span class="token comment">// [64*1024+1,256*1024]		8*1024byte对齐   freelist[184,208)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> size_t AlignNum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t alignSize<span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">%</span> AlignNum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">//对齐到对齐数</span>
            alignSize <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> alignSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> AlignNum <span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span><span class="token comment">//正好对齐</span>
            alignSize <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> alignSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而高手采用了这个思路，只能说太强了，虽然位运算可能并没有上面的写法容易理解，但计算机执行位运算的速度是比执行乘法和除法更快的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">,</span> size_t alignNum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于上述位运算，我们以10字节按8字节对齐为例进行分析8 − 1 = 7，7就是一个低三位为1其余位为0的二进制序列，我们将10与7相加，相当于将10字节当中不够8字节的剩余字节数补上了。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311215003.png" alt="image-20220831121520939"></p>
<p>然后我们再将该值与7按位取反后的值进行与运算，而7按位取反后是一个低三位为0其余位为1的二进制序列，该操作进行后相当于屏蔽了该值的低三位而该值的其余位保持不变，此时得到的值就是10字节按8字节对齐后的值，即16字节。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311215264.png" alt="image-20220831121537192"></p>
<p>在获取某一字节数对应的哈希桶下标时，也是先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p>
<h3 id="获取桶下标"><a href="#获取桶下标" class="headerlink" title="获取桶下标"></a>获取桶下标</h3><p>在获取某一字节数对应的哈希桶下标时，也是先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*size_t _Index(size_t bytes, size_t alignNum)
{
    if (bytes % alignNum == 0)
    {
        return bytes / alignNum - 1;
    }
    else
    {
        return bytes / alignNum;
    }
}
*/</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">_Index</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">,</span> size_t align_shift<span class="token punctuation">)</span>
<span class="token punctuation">{</span>													<span class="token comment">//下标从一开始</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 计算映射的哪一个自由链表桶</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">Index</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 每个区间有多少个链</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> group_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在获取某一字节数对应的哈希桶下标时，也是先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p>
<p>此时我们需要编写一个子函数来继续进行处理，容易想到的就是根据对齐数来计算某一字节数对应的下标。</p>
<p>当然，为了提高效率下面也提供了一个用位运算来解决的方法，需要注意的是，此时我们并不是传入该字节数的对齐数，而是将对齐数写成2的n次方的形式后，将这个n值进行传入。比如对齐数是8，传入的就是3。</p>
<h3 id="ThreadCache类"><a href="#ThreadCache类" class="headerlink" title="ThreadCache类"></a>ThreadCache类</h3><p>按照上述的对齐规则，thread cache中桶的个数，也就是自由链表的个数是208，以及thread cache允许申请的最大内存大小256KB，我们可以将这些数据按照如下方式进行定义。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//小于等于MAX_BYTES，就找thread cache申请</span>
<span class="token comment">//大于MAX_BYTES，就直接找page cache或者系统堆申请</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> size_t MAX_BYTES <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token comment">//thread cache和central cache自由链表哈希桶的表大小</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> size_t NFREELISTS <span class="token operator">=</span> <span class="token number">208</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一个debug</p>
<p>这里当时没有赋值最大的桶的shu’l</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311625499.png" alt="image-20220831162550410"></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311626667.png" alt="image-20220831162628566"></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311625596.png" alt="image-20220831162532503"></p>
<h4 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h4><p>在thread cache申请对象时，通过所给字节数计算出对应的哈希桶下标，如果桶中自由链表不为空，则从该自由链表中取出一个对象进行返回即可；但如果此时自由链表为空，那么我们就需要从central cache进行获取了，这里的FetchFromCentralCache函数也是thread cache类中的一个成员函数，在后面再进行具体实现。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//申请内容不可以超过256K</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//获取对齐的字节</span>
	size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//获得桶的下标</span>
	size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>alignSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> alignSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h4><p>释放的时候找到对应大小的桶，放回去</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">Deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//找到对应的桶插进去</span>
	size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="threadcacheTLS无锁访问"><a href="#threadcacheTLS无锁访问" class="headerlink" title="threadcacheTLS无锁访问"></a>threadcacheTLS无锁访问</h4><p>TLS: Thread Local Storage 线程本地存储</p>
<h5 id="why-TLS"><a href="#why-TLS" class="headerlink" title="why TLS"></a>why TLS</h5><p>每个线程都有一个自己独享的thread cache，那应该如何创建这个thread cache呢？我们不能将这个thread cache创建为全局的，因为全局变量是所有线程共享的，这样就不可避免的需要锁来控制，增加了控制成本和代码复杂度。</p>
<p>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现。这就是TLS。这是一种变量的存储方法，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。</p>
<p>TLS在不同的平台有不同的实现，可移植性不太好。幸好要实现线程局部存储并不难，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程的ID不同，查到的数据自然也不同了。大多数平台都提供了线程局部存储的方法，无需要我们自己去实现</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//TLS - Thread Local Storage</span>
<span class="token keyword">static</span> <span class="token function">_declspec</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> ThreadCache<span class="token operator">*</span> pTLSThreadCache <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>尤其注意</strong>：这里的对象要把它设置成一个静态的，不然的话会产生链接错误，因为这里被多个文件包含，就会导致在多个.o文件中出现，导致冲突和链接错误，加上一个static，表示只在当前文件可见</p>
<p>但不是每个线程被创建时就立马有了属于自己的thread cache，而是当该线程调用相关申请内存的接口时才会创建自己的thread cache，因此在申请内存的函数中会包含以下逻辑</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		pTLSThreadCache <span class="token operator">=</span><span class="token keyword">new</span> ThreadCache<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="central-cache-1"><a href="#central-cache-1" class="headerlink" title="central cache"></a>central cache</h2><h3 id="central-cache框架"><a href="#central-cache框架" class="headerlink" title="central cache框架"></a>central cache框架</h3><p>当线程申请某一大小的内存时，如果thread cache中对应的自由链表不为空，那么直接取出一个内存块进行返回即可，但如果此时该自由链表为空，那么这时thread cache就需要向central cache申请内存了。</p>
<p>central cache的结构与thread cache是一样的，它们都是哈希桶的结构，并且<strong>它们遵循的对齐映射规则都是一样的</strong>。<span style="color:darkcyan">这样做的好处就是，当thread cache的某个桶中没有内存了，就可以直接到central cache中对应的哈希桶里去取内存就行了。</span></p>
<h4 id="申请内存-1"><a href="#申请内存-1" class="headerlink" title="申请内存"></a>申请内存</h4><ol>
<li>当thread cache中没有内存时，就会批量向central cache申请一些内存对象，这里的批量获取对象的数量使用了类似网络tcp协议拥塞控制的慢开始算法；central cache也有一个哈希映射的spanlist，spanlist中挂着span，从span中取出对象给thread cache，这个过程是需要加锁的，不过这里使用的是一个桶锁，尽可能提高效率。</li>
<li>central cache映射的spanlist中所有span的都没有内存以后，则需要向page cache申请一个新的span对象，拿到span以后将span管理的内存按大小切好作为自由链表链接到一起。然后从span中取对象给thread cache。</li>
<li>central cache的中挂的span中use_count记录分配了多少个对象出去，分配一个对象给thread<br>cache，就++use_count</li>
</ol>
<p><strong>当一个 thread cache 挂有过多的内存时，我们就可以把它还给central cache，再给到其他的thread cache使用，这就做到了均衡分配</strong></p>
<h4 id="释放内存-1"><a href="#释放内存-1" class="headerlink" title="释放内存"></a>释放内存</h4><ol>
<li>当thread_cache过长或者线程销毁，则会将内存释放回central cache中的，释放回来时–use_count。当use_count减到0时则表示所有对象都回到了span，则将span释放回page cache，page cache中会对前后相邻的空闲页进行合并。</li>
</ol>
<h3 id="central-cache与thread-cache的不同"><a href="#central-cache与thread-cache的不同" class="headerlink" title="central cache与thread cache的不同"></a>central cache与thread cache的不同</h3><p>central cache与thread cache有两个明显不同的地方，首先，thread cache是每个线程独享的，而#<strong>central cache是所有线程共享的</strong>，因为每个线程的thread cache没有内存了都会去找central cache，因此在访问central cache时是需要加锁的。</p>
<p>但central cache在加锁时并不是将整个central cache全部锁上了，<strong>central cache在加锁时用的是桶锁</strong>，也就是说每个桶都有一个锁。此时只有当多个线程同时访问central cache的同一个桶时才会存在锁竞争，如果是多个线程同时访问central cache的不同桶就不会存在锁竞争。</p>
<p>central cache与thread cache的第二个不同之处就是，thread cache的每个桶中挂的是一个个切好的内存块，而<strong>central cache的每个桶中挂的是一个个的span。</strong><br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311816818.png" alt="image-20220831181626735"></p>
<p><strong>每个span管理的都是一个以页为单位的大块内存</strong>，每个桶里面的若干span是按照双链表的形式链接起来的，并且每个span里面还有一个自由链表，这个自由链表里面挂的就是一个个切好了的内存块，根据其所在的哈希桶这些内存块被切成了对应的大小。</p>
<p>如果span被拿完了，那么就继续问下面的page cache要</p>
<h3 id="centralcache结构设计"><a href="#centralcache结构设计" class="headerlink" title="centralcache结构设计"></a>centralcache结构设计</h3><h4 id="页号的类型"><a href="#页号的类型" class="headerlink" title="页号的类型"></a>页号的类型</h4><p>首先我们知道进程地址空间的大小：每个程序运行起来后都有自己的进程地址空间，在32位平台下，进程地址空间的大小是2^32^；而在64位平台下，进程地址空间的大小就是2^64^。</p>
<p>页的大小一般是4K或者8K，我们以8K为例。在32位平台下，进程地址空间就可以被分成 2^32^ ÷ 2^13^= 2^19^  个页；在64位平台下，进程地址空间就可以被分成 2^64^ ÷ 2^13^ = 2^51^个页。页号本质与地址是一样的，它们都是一个编号，只不过地址是以一个字节为一个单位，而页是以多个字节为一个单位。</p>
<p>由于页号在64位平台下的取值范围是[ 0 ， 2^51^) ，因此我们不能简单的用一个无符号整型来存储页号，这时我们需要借助条件编译来解决这个问题。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//条配件编译解决页号</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
<span class="token keyword">typedef</span> size_t PAGE_ID<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">_WIN64</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> PAGE_ID<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这不对，因为这里是很坑的</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209012013197.png" alt="image-20220901201330077"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//条配件编译解决页号</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN64</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> PAGE_ID<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">_WIN32</span></span>
<span class="token keyword">typedef</span> size_t PAGE_ID<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，在32位下，<code>_WIN32</code>有定义，<code>_WIN64</code>没有定义；而在64位下，<code>_WIN32</code>和<code>_WIN64</code>都有定义。因此在条件编译时，我们应该先判断<code>_WIN64</code>是否有定义，再判断<code>_WIN32</code>是否有定义。</p>
<h4 id="span的结构"><a href="#span的结构" class="headerlink" title="span的结构"></a>span的结构</h4><p>central cache的每个桶里挂的是一个个的span，span是一个管理以页为单位的大块内存，span的结构如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//管理以页为单位的大块内存</span>
<span class="token keyword">struct</span> <span class="token class-name">Span</span>
<span class="token punctuation">{</span>
	PAGE_ID _pageId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//大块内存起始页的页号</span>
	size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment">//页的数量</span>

	Span<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment">//双链表结构</span>
	Span<span class="token operator">*</span> _prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

	size_t _useCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">//切好的小块内存，被分配给thread cache的计数</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment">//切好的小块内存的自由链表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么要记录页号?</strong></p>
<blockquote>
<p>对于span管理的以页为单位的大块内存，我们需要知道这块内存具体在哪一个位置，便于之后page cache进行前后页的合并，因此span结构当中会记录所管理大块内存起始页的页号。</p>
</blockquote>
<p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么双向链表？</strong></p>
<blockquote>
<p>每个桶当中的span是以双链表的形式组织起来的，当我们需要将某个span归还给page cache时，就可以很方便的将该span从双链表结构中移出。如果用单链表结构的话就比较麻烦了，因为单链表在删除时，需要知道当前结点的前一个结点。</p>
</blockquote>
<p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么要自由链表？</strong></p>
<blockquote>
<p>此外，每个span管理的大块内存，都会被切成相应大小的内存块挂到当前span的自由链表中，比如8Byte哈希桶中的span，会被切成一个个8Byte大小的内存块挂到当前span的自由链表中，因此span结构中需要存储切好的小块内存的自由链表。</p>
</blockquote>
<p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么要<code>_usecount</code>?</strong></p>
<blockquote>
<p>span结构当中的<code>_useCount</code>成员记录的就是，当前span中切好的小块内存，被分配给thread cache的计数，当某个span的<code>_useCount</code>计数变为0时，代表当前span切出去的内存块对象全部还回来了，此时central cache就可以将这个span再还给page cache。</p>
</blockquote>
<h4 id="SpanList结构"><a href="#SpanList结构" class="headerlink" title="SpanList结构"></a>SpanList结构</h4><p>根据上面的描述，central cache的每个哈希桶里面存储的都是一个双链表结构，对于该双链表结构我们可以对其进行封装。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向链表</span>
<span class="token keyword">class</span> <span class="token class-name">SpanList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">SpanList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_head <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>
		_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> pos<span class="token punctuation">,</span> Span<span class="token operator">*</span> newSpan<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>newSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

		Span<span class="token operator">*</span> prev <span class="token operator">=</span>pos<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token comment">//prev newspan pos</span>
		prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newSpan<span class="token punctuation">;</span>
		newSpan<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
		newSpan<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> pos<span class="token punctuation">;</span>
		pos<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Erase</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> pos<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">!=</span> _head<span class="token punctuation">)</span><span class="token punctuation">;</span>

		Span<span class="token operator">*</span> prev <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		Span<span class="token operator">*</span> next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>

		prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
		next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	Span<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span>  <span class="token comment">//桶锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，从双链表删除的span会还给下一层的page cache，相当于只是把这个span从双链表中移除，因此不需要对删除的span进行delete操作。</p>
<h3 id="centralcache核心实现"><a href="#centralcache核心实现" class="headerlink" title="centralcache核心实现"></a>centralcache核心实现</h3><p>由于每个线程都有一个属于自己的thread cache，我们是用TLS来实现每个线程无锁的访问属于自己的thread cache的。而central cache和page cache在整个进程中只有一个，对于这种只能创建一个对象的类，我们可以将其设置为单例模式。</p>
<p>单例模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。单例模式又分为饿汉模式和懒汉模式，懒汉模式相对较复杂，我们这里使用饿汉模式就足够了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CentralCache</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//thread cache 是无锁的，但是CentralCache是有桶锁的</span>


	<span class="token comment">//采用单例模式,这里是一个全局访问点</span>
	<span class="token keyword">static</span> CentralCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInst<span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token function">CentralCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span><span class="token punctuation">}</span>

	<span class="token comment">//不可拷贝构造</span>
	<span class="token function">CentralCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> CentralCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	SpanList _spanList<span class="token punctuation">[</span>NFREELIST<span class="token punctuation">]</span><span class="token punctuation">;</span>  
	<span class="token keyword">static</span> CentralCache _sInst<span class="token punctuation">;</span>  <span class="token comment">//不要在.h中定义，否则会被多个文件包含</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了保证CentralCache类只能创建一个对象，我们需要将central cache的构造函数和拷贝构造函数设置为私有，或者在C++11中也可以在函数声明的后面加上<code> = delete</code>进行修饰。</p>
<p>CentralCache类当中还需要有一个CentralCache类型的静态的成员变量，当程序运行起来后我们就立马创建该对象，在此后的程序中就只有这一个单例了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">CentralCache CentralCache<span class="token double-colon punctuation">::</span>_sInst<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最后central cache还需要提供一个公有的成员函数，用于获取该对象，此时在整个进程中就只会有一个central cache对象了。</p>
<h4 id="慢反馈调节算法"><a href="#慢反馈调节算法" class="headerlink" title="慢反馈调节算法"></a>慢反馈调节算法</h4><p>当thread cache向central cache申请内存时，central cache应该给出多少个对象呢？这是一个值得思考的问题，如果central cache给的太少，那么thread cache在短时间内用完了又会来申请；但如果一次性给的太多了，可能thread cache用不完也就浪费了。</p>
<p>鉴于此，我们这里采用了一个慢开始反馈调节算法。当thread cache向central cache申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p>
<p>通过下面这个函数，我们就可以根据所需申请的对象的大小计算出具体给出的对象个数，并且可以将给出的对象个数控制到2~512个之间。也就是说，就算thread cache要申请的对象再小，我最多一次性给出512个对象；就算thread cache要申请的对象再大，我至少一次性给出2个对象。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> size_t <span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//[2, 512] ,依次批量移动多少个对象的（慢启动）上限值</span>
    <span class="token comment">//小对象一次批量的上限高</span>
    <span class="token comment">//大对象一次批量的上限低</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> MAX_BYTES <span class="token operator">/</span> size<span class="token punctuation">;</span>

    <span class="token comment">//下限（一个对象很大的情况下，只取一个对象太小了）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//上限（8字节的对象依次会取太多）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">512</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        num <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但就算申请的是小对象，一次性给出512个也是比较多的，基于这个原因，我们可以在FreeList结构中增加一个叫做<code>_maxSize</code>的成员变量，该变量的初始值设置为1，并且提供一个公有成员函数用于获取这个变量。也就是说，现在thread cache中的每个自由链表都会有一个自己的<code>_maxSize</code>。</p>
<p><strong>也就是说，我将之前的这个NumMoveSize作为一个上限，保证每次申请的值不超过NumMoveSize的返回值</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//管理切分好的小对象的自由链表</span>
<span class="token keyword">class</span> <span class="token class-name">FreeList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	size_t<span class="token operator">&amp;</span> <span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _maxSize<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//自由链表</span>
	size_t _maxSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时当thread cache申请对象时，我们会比较<code>_maxSize</code>和计算得出的值，取出其中的较小值作为本次申请对象的个数。此外，如果本次采用的是<code>_maxSize</code>的值，那么还会将thread cache中该自由链表的<code>_maxSize</code>的值进行加一。</p>
<p>因此，thread cache第一次向central cache申请某大小的对象时，申请到的都是一个，但下一次thread cache再向central cache申请同样大小的对象时，因为该自由链表中的<code>_maxSize</code>增加了，最终就会申请到两个。直到该自由链表中<code>_maxSize</code>的值，增长到超过计算出的值后就不会继续增长了，此后申请到的对象个数就是计算出的个数。（这有点像网络中拥塞控制的机制）</p>
<h4 id="FetchFromCentralCache"><a href="#FetchFromCentralCache" class="headerlink" title="FetchFromCentralCache"></a>FetchFromCentralCache</h4><p>每次thread cache向central cache申请对象时，我们先通过慢开始反馈调节算法计算出本次应该申请的对象的个数，然后再向central cache进行申请。</p>
<p>如果thread cache最终申请到对象的个数就是一个，那么直接将该对象返回即可。为什么需要返回一个申请到的对象呢？因为thread cache要向central cache申请对象，其实由于某个线程向thread cache申请对象但thread cache当中没有，这才导致thread cache要向central cache申请对象。因此central cache将对象返回给thread cache后，thread cache会再将该对象返回给申请对象的线程。</p>
<p>但如果thread cache最终申请到的是多个对象，那么除了将第一个对象返回之外，还需要将剩下的对象挂到thread cache对应的哈希桶当中。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//慢开始的调节算法</span>

	<span class="token comment">/* 1. 最开始的时候不会依次向中心缓存要太多，因为一下太多了就会用不完
	 * 2. 如果你不要这个size大小的 内存需求，那么batchNum就会向上增长到上限
	 * 3. size越大，一次向中心缓存要的batch就小
	 * 4. size越小，一次向中心缓存要的batch就大
	 */</span>

	<span class="token comment">//						自己有一个最小值							这里的设置作为一个获取的上限</span>
	size_t batchNum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span>batchNum <span class="token operator">==</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_freeLists<span class="token operator">-&gt;</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> end <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

	<span class="token comment">//返回值是实际返回的值</span>
	size_t actualNum <span class="token operator">=</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">FetchRangeObject</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> batchNum<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">assert</span><span class="token punctuation">(</span>actualNum <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>actualNum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> start<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> start<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="FetchRangeObject"><a href="#FetchRangeObject" class="headerlink" title="FetchRangeObject"></a>FetchRangeObject</h4><p>这里我们要从central cache获取n个指定大小的对象，这些对象肯定都是从central cache对应哈希桶的某个span中取出来的，因此取出来的这n个对象是链接在一起的，我们只需要得到这段链表的头和尾即可，这里可以采用输出型参数进行获取。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">FetchRangeObject</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> size_t batchNum<span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">//加锁</span>
	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//实现锁内的逻辑</span>

	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token function">GetOneSpan</span><span class="token punctuation">(</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//对应的桶里面获得span</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span>

	start <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>
	<span class="token comment">//end需要往后走batchNum - 1</span>
	end <span class="token operator">=</span> start<span class="token punctuation">;</span>
	size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	size_t actualNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//需要返回的参数</span>

	<span class="token comment">//为防止span &lt; batchNum这里使用while循环</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> batchNum <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		end <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>i<span class="token punctuation">;</span>
		<span class="token operator">++</span>actualNum<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	span<span class="token operator">-&gt;</span>_useCount <span class="token operator">+=</span> actualNum<span class="token punctuation">;</span><span class="token comment">//更新被分配给thread cache的计数</span>
	<span class="token comment">//解锁</span>
	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> actualNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于central cache是所有线程共享的，所以我们在访问central cache中的哈希桶时，需要先给对应的哈希桶加上桶锁，在获取到对象后再将桶锁解掉。</p>
<p>在向central cache获取对象时，先是在central cache对应的哈希桶中获取到一个非空的span，然后从这个span的自由链表中取出n个对象即可，但可能这个非空的span的自由链表当中对象的个数不足n个，这时该自由链表当中有多少个对象就给多少就行了。GetOneSpan函数后期实现</p>
<p>也就是说，thread cache实际从central cache获得的对象的个数可能与我们传入的n值是不一样的，因此我们需要统计本次申请过程中，实际thread cache获取到的对象个数，然后根据该值及时更新这个span中的小对象被分配给thread cache的计数。</p>
<p>需要注意的是，虽然我们实际申请到对象的个数可能比n要小，但这并不会产生任何影响。因为thread cache的本意就是向central cache申请一个对象，我们之所以要一次多申请一些对象，是因为这样一来下次线程再申请相同大小的对象时就可以直接在thread cache里面获取了，而不用再向central cache申请对象。</p>
<h4 id="PushRange"><a href="#PushRange" class="headerlink" title="PushRange"></a>PushRange</h4><p>如果thread cache最终从central cache获取到的对象个数是大于一的，那么我们还需要将剩下的对象插入到thread cache中对应的哈希桶中，为了能让<strong>自由链表支持插入一段范围的对象</strong>，我们还需要在FreeList类中增加一个对应的成员函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
    _freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="page-cache-1"><a href="#page-cache-1" class="headerlink" title="page cache"></a>page cache</h2><h3 id="page-cache框架"><a href="#page-cache框架" class="headerlink" title="page cache框架"></a>page cache框架</h3><h4 id="page-cache与central-cache相同之处"><a href="#page-cache与central-cache相同之处" class="headerlink" title="page cache与central cache相同之处"></a>page cache与central cache相同之处</h4><p>page cache与central cache一样，它们都是哈希桶的结构，并且page cache的每个哈希桶中里挂的也是一个个的span，这些span也是按照双链表的结构链接起来的。</p>
<h4 id="page-cache与central-cache不同之处"><a href="#page-cache与central-cache不同之处" class="headerlink" title="page cache与central cache不同之处"></a>page cache与central cache不同之处</h4><p>首先，<strong>central cache的映射规则与thread cache保持一致</strong>，<strong>而page cache的映射规则与它们都不相同。</strong>page cache的哈希桶映射规则采用的是<strong>直接定址法</strong>，比如1号桶挂的都是1页的span，2号桶挂的都是2页的span，以此类推。</p>
<p>其次，central cache每个桶中的span被切成了一个个对应大小的对象，以供thread cache申请。而page cache当中的span是没有被进一步切小的，因为page cache服务的是central cache，当central cache没有span时，向page cache申请的是某一固定页数的span，而如何切分申请到的这个span就应该由central cache自己来决定。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209021448911.png" alt="image-20220902144759770"></p>
<p>至于page cache当中究竟有多少个桶，这就要看你最大想挂几页的span了，这里我们就最大挂128页的span，为了让桶号与页号对应起来，我们可以将第0号桶空出来不用，因此我们需要将哈希桶的个数设置为129。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> size_t NPAGES <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span> <span class="token comment">//pagebucket num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为什么这里最大挂128页的span呢？因为线程申请单个对象最大是256KB，而128页可以被切成4个256KB的对象，因此是足够的。当然，如果你想在page cache中挂更大的span也是可以的，根据具体的需求进行设置就行了。</p>
<h3 id="获取k个span"><a href="#获取k个span" class="headerlink" title="获取k个span"></a>获取k个span</h3><p>如果central cache要获取一个n页的span，那我们就可以在page cache的第n号桶中取出一个span返回给central cache即可，但如果第n号桶中没有span了，<strong>这时我们并不是直接转而向堆申请一个n页的span，而是要继续在后面的桶当中寻找span。</strong></p>
<p><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么不直接向堆申请？</strong></p>
<blockquote>
<p>直接向堆申请以页为单位的内存时，我们应该尽量申请大块一点的内存块，因为此时申请到的内存是连续的，当线程需要内存时我们可以将其切小后分配给线程，而当线程将内存释放后我们又可以将其合并成大块的连续内存。如果我们向堆申请内存时是小块小块的申请的，那么我们申请到的内存就不一定是连续的了。</p>
</blockquote>
<p>因此，当第n号桶中没有span时，我们可以继续找第n+1号桶，因为我们可以将n+1页的span切分成一个n页的span和一个1页的span，这时我们就可以将n页的span返回，而将切分后1页的span挂到1号桶中。但如果后面的桶当中都没有span，这时我们就只能向堆申请一个128页的内存块，并将其用一个span结构管理起来，然后将128页的span切分成n页的span和128-n页的span，其中n页的span返回给central cache，而128-n页的span就挂到第128-n号桶中。</p>
<p><strong>也就是说，我们每次向堆申请的都是128页大小的内存块，central cache要的这些span实际都是由128页的span切分出来的。</strong></p>
<h3 id="page-cache实现"><a href="#page-cache实现" class="headerlink" title="page cache实现"></a>page cache实现</h3><h4 id="page-cache-要加锁吗？"><a href="#page-cache-要加锁吗？" class="headerlink" title="page cache 要加锁吗？"></a>page cache 要加锁吗？</h4><p>当每个线程的thread cache没有内存时都会向central cache申请，此时多个线程的thread cache如果访问的不是central cache的同一个桶，那么这些线程是可以同时进行访问的。这时central cache的多个桶就可能同时向page cache申请内存的，所以page cache也是存在线程安全问题的，因此在访问page cache时也必须要加锁。</p>
<h4 id="使用桶锁吗？"><a href="#使用桶锁吗？" class="headerlink" title="使用桶锁吗？"></a>使用桶锁吗？</h4><p>但是在page cache这里我们不能使用桶锁，因为当central cache向page cache申请内存时，page cache可能会将其他桶当中大页的span切小后再给central cache。此外，当central cache将某个span归还给page cache时，page cache也会尝试将该span与其他桶当中的span进行合并。</p>
<p>也就是说，在访问page cache时，我们可能需要访问page cache中的多个桶，如果page cache用桶锁就会出现大量频繁的加锁和解锁，导致程序的效率低下（for循环外面的加锁和for循环里面的加锁）。因此我们在访问page cache时使用没有使用桶锁，而是用一个大锁将整个page cache给锁住。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209021536631.png" alt="image-20220902153611534"></p>
<h4 id="为什么central-cache用桶锁"><a href="#为什么central-cache用桶锁" class="headerlink" title="为什么central cache用桶锁"></a>为什么central cache用桶锁</h4><p>而thread cache在访问central cache时，只需要访问central cache中对应的哈希桶就行了，因为central cache的每个哈希桶中的span都被切分成了对应大小，thread cache只需要根据自己所需对象的大小访问central cache中对应的哈希桶即可，不会访问其他哈希桶，因此central cache可以用桶锁。</p>
<p><strong>此外，page cache在整个进程中也是只能存在一个的，因此我们也需要将其设置为单例模式。</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PageCache</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> PageCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInstan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//获取K页的span</span>
	Span<span class="token operator">*</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	SpanList _spanLists<span class="token punctuation">[</span>NPAGES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//分桶的连着不同的页数</span>
	std<span class="token double-colon punctuation">::</span>mutex _pagemtx<span class="token punctuation">;</span> <span class="token comment">//大锁</span>

	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

	<span class="token keyword">static</span> PageCache _sInstan<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当程序运行起来后我们就立马创建该对象即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">PageCache PageCache<span class="token double-colon punctuation">::</span>_sInst<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="page-cache中获取Span"><a href="#page-cache中获取Span" class="headerlink" title="page cache中获取Span"></a>page cache中获取Span</h3><h4 id="GetOneSpan"><a href="#GetOneSpan" class="headerlink" title="GetOneSpan"></a>GetOneSpan</h4><p>thread cache向central cache申请对象时，central cache需要先从对应的哈希桶中获取到一个非空的span，然后从这个非空的span中取出若干对象返回给thread cache。那central cache到底是如何从对应的哈希桶中，获取到一个非空的span的呢？</p>
<h4 id="桶中有余"><a href="#桶中有余" class="headerlink" title="桶中有余"></a>桶中有余</h4><p>首先当然是先遍历central cache对应哈希桶当中的双链表，如果该双链表中有非空的span，那么直接将该span进行返回即可。为了方便遍历这个双链表，我们可以模拟迭代器的方式，给SpanList类提供Begin和End成员函数，分别用于获取双链表中的第一个span和最后一个span的下一个位置，也就是头结点。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span>
<span class="token keyword">class</span> <span class="token class-name">SpanList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	Span<span class="token operator">*</span> <span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Span<span class="token operator">*</span> <span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Span<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span> <span class="token comment">//桶锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="桶中空空"><a href="#桶中空空" class="headerlink" title="桶中空空"></a>桶中空空</h4><p>但如果遍历双链表后发现双链表中没有span，或该双链表中的span都为空，那么此时central cache就需要向page cache申请内存块了。</p>
<p>那具体是向page cache申请多大的内存块呢？我们可以根据具体所需对象的大小来决定，就像之前我们根据对象的大小计算出，thread cache一次向central cache申请对象的个数上限，现在我们是<strong>根据对象的大小计算出，central cache一次应该向page cache申请几页的内存块。</strong></p>
<p>我们可以先根据对象的大小计算出，thread cache一次向central cache申请对象的个数上限，然后将这个上限值乘以单个对象的大小，就算出了<strong>具体需要多少字节</strong>，最后再将这个算出来的字节数转换为页数，如果转换后不够一页，那么我们就申请一页，否则转换出来是几页就申请几页。也就是说，central cache向page cache申请内存时，要求申请到的内存尽量能够满足thread cache向central cache申请时的上限</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//管理对齐和映射等关系</span>
<span class="token keyword">class</span> <span class="token class-name">SizeAlignment</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//central cache一次向page cache获取多少页</span>
	<span class="token comment">//单个对象 8Bytes - 256KB</span>
								<span class="token comment">//size-&gt;单个对象的大小</span>
	<span class="token keyword">static</span> size_t <span class="token function">NumMovePage</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		size_t num_limit <span class="token operator">=</span> <span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取能获取的对象的上限</span>
		size_t actual_Byte <span class="token operator">=</span> num_limit <span class="token operator">*</span> size<span class="token punctuation">;</span>	<span class="token comment">//实际申请的对象的总大小</span>

		size_t npage <span class="token operator">=</span> actual_Byte <span class="token operator">&gt;&gt;</span> PAEG_SHIFT<span class="token punctuation">;</span>  <span class="token comment">//和页的转换 8K</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>npage <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			npage <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> npage<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码中的<code>PAGE_SHIFT</code>代表页大小转换偏移，我们这里以页的大小为8K为例，<code>PAGE_SHIFT</code>的值就是13。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//页大小转换偏移，即一页定义为2^13，也就是8KB</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> size_t PAGE_SHIFT <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="挂接"><a href="#挂接" class="headerlink" title="挂接"></a>挂接</h4><p>需要注意的是，当central cache申请到若干页的span后，还需要将这个span切成一个个对应大小的对象挂到该span的自由链表当中。</p>
<p>如何找到一个span所管理的内存块呢？<strong>首先需要计算出该span的起始地址</strong>，我们可以用这个span的起始页号乘以一页的大小即可得到这个span的起始地址，然后用这个span的页数乘以一页的大小就可以得到这个span所管理的内存块的大小，用起始地址加上内存块的大小即可得到这块内存块的结束位置。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209022133383.png" alt="image-20220902213347301"></p>
<blockquote>
<p>这张图片显示的是切片和链接的逻辑</p>
</blockquote>
<p>明确了这块内存的起始和结束位置后，我们就可以进行切分了。根据所需对象的大小，每次从大块内存切出一块固定大小的内存块尾插到span的自由链表中即可。</p>
<p>为什么是尾插呢？因为我们如果是将切好的对象尾插到自由链表，这些对象看起来是按照链式结构链接起来的，而实际它们在物理上是连续的，这时当我们把这些连续内存分配给某个线程使用时，可以提高该线程的CPU缓存利用率。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取一个非空的span</span>
Span<span class="token operator">*</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetOneSpan</span><span class="token punctuation">(</span>SpanList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//看看当前的Page桶里面还有没有剩余的span对象在List中</span>
	Span<span class="token operator">*</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//只要挂着有对象就返回</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">-&gt;</span>_freeList <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> it<span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			it <span class="token operator">=</span> it<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//没有空闲的Span了，只能找其他的桶上面换Span，再不行就在page类中找堆</span>
	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*切分，然后挂载*/</span>
	<span class="token comment">//1. 找到起始地址</span>
	<span class="token keyword">char</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAEG_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//2. 计算span大块内存的大小（字节数）</span>
	size_t bytes <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;&lt;</span> PAEG_SHIFT<span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> end <span class="token operator">=</span> start <span class="token operator">+</span> bytes<span class="token punctuation">;</span>
	<span class="token comment">//3. 切割 + 尾插</span>
	<span class="token comment">/*把大块内存切成自由链表链接起来，先切下来一个做头节点，方便尾插*/</span>
	span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>
	start <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> tail <span class="token operator">=</span>span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//tail往后走</span>
		start <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//这里是一个BUG</span>
    <span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//尾的指向置空</span>

	<span class="token comment">//不能忘记要插入span</span>
	list<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> span<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，当我们把span切好后，需要将这个切好的span挂到central cache的对应哈希桶中。因此SpanList类还需要提供一个接口，用于将一个span插入到该双链表中。这里我们选择的是头插，这样当central cache下一次从该双链表中获取非空span时，一来就能找到。</p>
<p>由于SpanList类之前实现了Insert和Begin函数，这里实现双链表头插就非常简单，直接在双链表的Begin位置进行Insert即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span>
<span class="token keyword">class</span> <span class="token class-name">SpanList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">PushFront</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Span<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span> <span class="token comment">//桶锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="获取一个k页的span"><a href="#获取一个k页的span" class="headerlink" title="获取一个k页的span"></a>获取一个k页的span</h3><p>当我们调用上述的GetOneSpan从central cache的某个哈希桶获取一个非空的span时，如果遍历哈希桶中的双链表后发现双链表中没有span，或该双链表中的span都为空，那么此时central cache就需要向page cache申请若干页的span了，下面我们就来说说如何从page cache获取一个k页的span。</p>
<h4 id="补充函数"><a href="#补充函数" class="headerlink" title="补充函数"></a>补充函数</h4><p>因为page cache是直接按照页数进行映射的，因此我们要从page cache获取一个k页的span，就应该直接先去找page cache的第k号桶，如果第k号桶中有span，那我们直接头删一个span返回给central cache就行了。所以我们这里需要再给SpanList类添加对应的Empty和PopFront函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span>
<span class="token keyword">class</span> <span class="token class-name">SpanList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _head <span class="token operator">==</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Span<span class="token operator">*</span> <span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		Span<span class="token operator">*</span> front <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token function">Erase</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> front<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Span<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span> <span class="token comment">//桶锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="处理分配"><a href="#处理分配" class="headerlink" title="处理分配"></a>处理分配</h4><p>如果page cache的第k号桶中没有span，我们就应该继续找后面的桶，只要后面任意一个桶中有一个n页span，我们就可以将其切分成一个k页的span和一个n-k页的span，<strong>然后将切出来k页的span返回给central cache，再将n-k页的span挂到page cache的第n-k号桶即可。</strong></p>
<p>但如果后面的桶中也都没有span，此时我们就需要向堆申请一个128页的span了，在向堆申请内存时，直接调用我们封装的SystemAlloc函数即可。</p>
<p>需要注意的是，向堆申请内存后得到的是这块内存的起始地址，此时我们需要将该地址转换为页号。由于我们向堆申请内存时都是按页进行申请的，因此我们直接将该地址除以一页的大小即可得到对应的页号。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//第K个桶里面有没有span</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _spanLists<span class="token operator">-&gt;</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//检查一下后面的 桶里面有没有span，如果有的话，把它进行切分</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			Span<span class="token operator">*</span> nSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//切</span>
			Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>
			<span class="token comment">//在nSpan的头部切k页下来</span>
			kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> nSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>  <span class="token comment">//修改起始地址</span>
			kSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>		<span class="token comment">//获得k页</span>

			nSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+=</span> k<span class="token punctuation">;</span>	 <span class="token comment">//起始页号修改</span>
			nSpan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span>			<span class="token comment">//页数修改</span>
			<span class="token comment">//将剩下的挂到对应映射的位置</span>
			_spanLists<span class="token punctuation">[</span>nSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> kSpan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//已经没有任何Span了</span>
	Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//128</span>
	<span class="token comment">//指针转化页号</span>
	bigSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>  <span class="token comment">//初始页号</span>
	bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//挂载</span>
	_spanLists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//尽量避免代码重复，递归调用自己s，相当于第一遍走一个堆申请，第二遍返回span</span>
	<span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里说明一下，当我们向堆申请到128页的span后，需要将其切分成k页的span和128-k页的span，但是为了尽量避免出现重复的代码，我们最好不要再编写对应的切分代码。我们可以先将申请到的128页的span挂到page cache对应的哈希桶中，然后再递归调用该函数就行了，此时在往后找span时就一定会在第128号桶中找到该span，然后进行切分。</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>首先搞清楚不可以在这里加锁，递归枷锁会把自己锁住（递归锁会解决，或者可以分离子函数），下面看看大佬的方式</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031008912.png" alt="image-20220903100849784"></p>
<p>这里其实有一个问题：当central cache向page cache申请内存时，central cache对应的哈希桶是处于加锁的状态的，那在访问page cache之前我们应不应该把central cache对应的桶锁解掉呢？</p>
<p>这里建议在访问page cache前，先把central cache对应的桶锁解掉。虽然此时central cache的这个桶当中是没有内存供其他thread cache申请的，但thread cache<strong>除了申请内存还会释放内存</strong>，如果在访问page cache前将central cache对应的桶锁解掉，那么此时当其他thread cache想要归还内存到central cache的这个桶时就不会被阻塞。</p>
<p>因此在调用NewSpan函数之前，我们需要先将central cache对应的桶锁解掉，然后再将page cache的大锁加上，当申请到k页的span后，我们需要将page cache的大锁解掉，但此时我们不需要立刻获取到central cache中对应的桶锁。因为central cache拿到k页的span后还会对其进行切分操作，因此我们可以在span切好后需要将其挂到central cache对应的桶上时，再获取对应的桶锁。</p>
<p>这里为了让代码清晰一点，只写出了加锁和解锁的逻辑，我们只需要将这些逻辑添加到之前实现的GetOneSpan函数的对应位置即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">spanList<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解桶锁</span>
<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加大锁</span>

<span class="token comment">//从page cache申请k页的span</span>

<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解大锁</span>

<span class="token comment">//进行span的切分...</span>

spanList<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加桶锁</span>

<span class="token comment">//将span挂到central cache对应的哈希桶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="申请内存过程联调"><a href="#申请内存过程联调" class="headerlink" title="申请内存过程联调"></a>申请内存过程联调</h2><p>先去调试一下申请内存过程的话，后期再做释放内存过程的话会更好调试</p>
<h3 id="关于SystemAlloc"><a href="#关于SystemAlloc" class="headerlink" title="关于SystemAlloc"></a>关于SystemAlloc</h3><p>对于调用堆申请内存来说，这里我们需要如果在Windows上的话我们就需要包含头文件&lt;windows.h&gt;，这里说一下编译时会出现的问题，在C++的algorithm头文件中有一个min函数，这是一个函数模板，而在Windows.h头文件中也有一个min，这是一个宏。由于调用函数模板时需要进行参数类型的推演，因此当我们调用min函数时，编译器会优先匹配Windows.h当中以宏的形式实现的min，此时当我们以std::min的形式调用min函数时就会产生报错，这就是没有用命名空间进行封装的坏处，这时我们只能选择将std::去掉，让编译器调用Windows.h当中的min。</p>
<h3 id="ConcurrentAlloc函数"><a href="#ConcurrentAlloc函数" class="headerlink" title="ConcurrentAlloc函数"></a>ConcurrentAlloc函数</h3><p>在将thread cache、central cache以及page cache的申请流程写通了之后，我们就可以向外提供一个ConcurrentAlloc函数，用于申请内存块。每个线程第一次调用该函数时会通过TLS获取到自己专属的thread cache对象，然后每个线程就可以通过自己对应的thread cache申请对象了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//通过TLS，每个线程无锁的获取自己专属的ThreadCache对象</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		pTLSThreadCache <span class="token operator">=</span> <span class="token keyword">new</span> ThreadCache<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="UnionTest1"><a href="#UnionTest1" class="headerlink" title="UnionTest1"></a>UnionTest1</h3><p>由于在多线程场景下调试观察起来非常麻烦，这里就先不考虑多线程场景，看看在单线程场景下代码的执行逻辑是否符合我们的预期，其次，我们这里就只简单观察在一个桶当中的内存申请就行了。</p>
<p>下面该线程进行了三次内存申请，这三次内存申请的字节数最终都对齐到了8，此时当线程申请内存时就只会访问到thread cache的第0号桶。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestConcurrentAlloc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout<span class="token operator">&lt;&lt;</span>p1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>p2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>p3<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>p4<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>p5<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>p6<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当线程第一次申请内存时，该线程需要通过TLS获取到自己专属的thread cache对象，然后通过这个thread cache对象进行内存申请。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031312714.png" alt="image-20220903131200629"></p>
<p>在申请内存时通过计算索引到了thread cache的第0号桶，但此时thread cache的第0号桶中是没有对象的，因此thread cache需要向central cache申请内存块。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031312418.png" alt="image-20220903131230326"></p>
<p>在向central cache申请内存块前，首先通过NumMoveSize函数计算得出，thread cache一次最多可向central cache申请8字节大小对象的个数是512，但由于我们采用的是慢开始算法，因此还需要将上限值与对应自由链表的<code>_maxSize</code>的值进行比较，而此时对应自由链表<code>_maxSize</code>的值是1，所以最终得出本次thread cache向central cache申请8字节对象的个数是1个。</p>
<p>并且在此之后会将该自由链表中<code>_maxSize</code>的值进行自增，下一次thread cache再向central cache申请8字节对象时最终申请对象的个数就会是2个了。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031313450.png" alt="image-20220903131330371"></p>
<p>在thread cache向central cache申请对象之前，需要先将central cache的0号桶的锁加上，然后再从该桶获取一个非空的span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031313502.png" alt="image-20220903131356425"></p>
<p>在central cache的第0号桶获取非空span时，先遍历对应的span双链表，看看有没有非空的span，但此时肯定是没有的，因此在这个过程中我们无法找到一个非空的span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031314713.png" alt="image-20220903131437626"></p>
<p>那么此时central cache就需要向page cache申请内存了，但在此之前需要先把central cache第0号桶的锁解掉，然后再将page cache的大锁给加上，之后才能向page cache申请内存。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031315386.png" alt="image-20220903131529306"></p>
<p>在向page cache申请内存时，由于central cache一次给thread cache8字节对象的上限是512，对应就需要4096字节，所需字节数不足一页就按一页算，所以这里central cache就需要向page cache申请一页的内存块。<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031315617.png" alt="image-20220903131546531"></p>
<p>但此时page cache的第1个桶以及之后的桶当中都是没有span的，因此page cache需要直接向堆申请一个128页的span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031316823.png" alt="image-20220903131622709"></p>
<p>这里通过监视窗口可以看到，用于管理申请到的128页内存的span信息。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031439178.png" alt="image-20220903143930932"></p>
<p>我们可以顺便验证一下，按页向堆申请的内存块的起始地址和页号之间是可以相互转换的。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031438711.png" alt="image-20220903143859483"></p>
<p>现在将申请到的128页的span插入到page cache的第128号桶当中，然后再调用一次NewSpan，在这次调用的时候，虽然在1号桶当中没有span，但是在往后找的过程中就一定会在第128号桶找到一个span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031442942.png" alt="image-20220903144200679"></p>
<blockquote>
<p><strong>出现一个报错</strong></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031328465.png" alt="报错信息"></p>
<p>调试一下发现原因</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031335979.png" alt="image-20220903133542836"></p>
<p>发现原来是函数写错了，应该是</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031337921.png" alt="image-20220903133729729"></p>
</blockquote>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031317251.png" alt="image-20220903131737169"></p>
<p>此时我们就可以把这个128页的span拿出来，切分成1页的span和127页的span，将1页的span返回给central cache，而把127页的span挂到page cache的第127号桶即可。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031445666.png" alt="image-20220903144531372"></p>
<p>从page cache返回后，就可以把page cache的大锁解掉了，但紧接着还要将获取到的1页的span进行切分，因此这里没有立刻重新加上central cache对应的桶锁。</p>
<blockquote>
<p>发现问题</p>
<p>这里的左移和右移搞反了，应该是乘以大小，拿到了总字节数</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031447247.png" alt="image-20220903144706992"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t bytes <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>改一下之后大小就对了</p>
</blockquote>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031318853.png" alt="image-20220903131838780"></p>
<p>在进行切分的时候，先通过该span的起始页号得到该span的起始地址，然后通过该span的页数得到该span所管理内存块的总的字节数。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031319901.png" alt="image-20220903131902820"></p>
<p>在确定内存块的开始和结束后，就可以将其切分成一个个8字节大小的对象挂到该span的自由链表中了。在调试过程中通过内存监视窗口可以看到，切分出来的每个8字节大小的对象的前四个字节存储的都是下一个8字节对象的起始地址。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031319217.png" alt="image-20220903131925113"></p>
<p>当切分结束后再获取central cache第0号桶的桶锁，然后将这个切好的span插入到central cache的第0号桶中，最后再将这个非空的span返回，此时就获取到了一个非空的span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031319892.png" alt="image-20220903131955834"></p>
<p>由于thread cache只向central cache申请了一个对象，因此拿到这个非空的span后，直接从这个span里面取出一个对象即可，此时该span的_useCount也由0变成了1。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031320286.png" alt="image-20220903132024159"></p>
<blockquote>
<p>出现报错</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031341233.png" alt="image-20220903134143017"></p>
<p>原因是起始这里的actualNum是可以等于1的，这里写错了，改成assert（actualNum&gt;=1）</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031353576.png" alt="image-20220903135310338"></p>
<p>同时发现这里没有更新，这里对后期的释放流程很有用</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">span<span class="token operator">-&gt;</span>_useCount <span class="token operator">+=</span> actualNum<span class="token punctuation">;</span> <span class="token comment">//更新被分配给thread cache的计数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

</blockquote>
<p>由于此时thread cache实际只向central cache申请到了一个对象，因此直接将这个对象返回给线程即可。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031320513.png" alt="image-20220903132057436"></p>
<p>当线程第二次申请内存块时就不会再创建thread cache了，因为第一次申请时就已经创建好了，此时该线程直接获取到对应的thread cache进行内存块申请即可。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031321235.png" alt="image-20220903132126164"></p>
<p>当该线程第二次申请8字节大小的对象时，此时thread cache的0号桶中还是没有对象的，因为第一次thread cache只向central cache申请了一个8字节对象，因此这次申请时还需要再向central cache申请对象。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031321361.png" alt="image-20220903132142288"></p>
<p>这时thread cache向central cache申请对象时，thread cache第0号桶中自由链表的_maxSize已经慢增长到2了，所以这次在向central cache申请对象时就会申请2个。如果下一次thread cache再向central cache申请8字节大小的对象，那么central cache会一次性给thread cache3个，这就是所谓的慢增长。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202210251615268.png" alt="image-20220903132223411"></p>
<p>但由于第一次central cache向page cache申请了一页的内存块，并将其切成了1024个8字节大小的对象，因此这次thread cache向central cache申请2两个8字节的对象时，central cache的第0号桶当中是有对象的，直接返回两个给thread cache即可，而不用再向page cache申请内存了。</p>
<p>但线程实际申请的只是一个8字节对象，因此thread cache除了将一个对象返回之外，还需要将剩下的一个对象挂到thread cache的第0号桶当中。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031323856.png" alt="image-20220903132315784"></p>
<p>这样一来，当线程第三次申请1字节的内存时，由于1字节对齐后也是8字节，此时thread cache也就不需要再向central cache申请内存块了，直接将第0号桶当中之前剩下的一个8字节对象返回即可。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031455666.png" alt="image-20220903145539405"></p>
<p>也就是说第一次申请了一块，第二次从central申请了两块内存，然后第三次就直接还有一块，就不用上去要了</p>
<p>最后测试成功</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031458901.png" alt="image-20220903145824785"></p>
<h3 id="UnionTest2"><a href="#UnionTest2" class="headerlink" title="UnionTest2"></a>UnionTest2</h3><p>第一次过了就基本怕跑通了，为了进一步测试代码的正确性，我们可以做这样一个测试：让线程申请1024次8字节的对象，然后通过调试观察在第1025次申请时，central cache是否会再向page cache申请内存块。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestConcurrentAlloc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout<span class="token operator">&lt;&lt;</span>p1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为central cache第一次就是向page cache申请的一页内存，这一页内存被切成了1024个8字节大小的对象，当这1024个对象全部被申请之后，再申请8字节大小的对象时central cache当中就没有对象了，此时就应该向page cache申请内存块。</p>
<p>通过调试我们可以看到，第1025次申请8字节大小的对象时，central cache第0号桶中的这个span的<code>_useCount</code>已经增加到了1024，也就是说这1024个对象都已经被线程申请了，此时central cache就需要再向page cache申请一页的span来进行切分了。<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031507441.png" alt="image-20220903150742232"></p>
<p>而这次central cache在向page cache申请一页的内存时，page cache就是将127页span切分成了1页的span和126页的span了，然后central cache拿到这1页的span后，又会将其切分成1024块8字节大小的内存块以供thread cache申请。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031508580.png" alt="image-20220903150808430"></p>
<h2 id="thread-cache回收内存"><a href="#thread-cache回收内存" class="headerlink" title="thread cache回收内存"></a>thread cache回收内存</h2><h3 id="Deallocate"><a href="#Deallocate" class="headerlink" title="Deallocate"></a>Deallocate</h3><p>当某个线程申请的对象不用了，可以将其释放给thread cache，然后thread cache将该对象插入到对应哈希桶的自由链表当中即可。</p>
<p>但是随着线程不断的释放，对应自由链表的长度也会越来越长，这些内存堆积在一个thread cache中就是一种浪费，我们应该将这些内存还给central cache，这样一来，这些内存对其他线程来说也是可申请的，因此当thread cache某个桶当中的自由链表太长时我们可以进行一些处理。</p>
<p><strong>如果thread cache某个桶当中自由链表的长度超过它一次批量向central cache申请的对象个数</strong>，那么此时我们就要把该自由链表当中的这些对象还给central cache。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">Deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//找到对应的桶插进去</span>
	size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 当链表长度大于一次批量申请的内存时就开始还一段list给central cache</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">ListTooLong</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="ListTooLong"><a href="#ListTooLong" class="headerlink" title="ListTooLong"></a>ListTooLong</h3><p>当自由链表的长度大于一次批量申请的对象时，我们具体的做法就是，从该自由链表中取出一次批量个数的对象，然后将取出的这些对象还给central cache中对应的span即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">ListTooLong</span><span class="token punctuation">(</span>FreeList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">void</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> end <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	list<span class="token punctuation">.</span><span class="token function">PopRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从上述代码可以看出，FreeList类需要支持用Size函数获取自由链表中对象的个数，还需要支持用PopRange函数从自由链表中取出指定个数的对象。因此我们需要给FreeList类增加一个对应的PopRange函数，然后再增加一个<code>_size</code>成员变量，该成员变量用于记录当前自由链表中对象的个数，当我们向自由链表插入或删除对象时，都应该更新<code>_size</code>的值。</p>
<h3 id="增加成员变量-size"><a href="#增加成员变量-size" class="headerlink" title="增加成员变量_size"></a>增加成员变量<code>_size</code></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FreeList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 头插</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>
		_size<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//头删</span>
		<span class="token keyword">void</span><span class="token operator">*</span> obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_size<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> end<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>
		_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>

		_size <span class="token operator">+=</span> n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//这里接口的设计最好不要一次取完，而是一次去一定数量的，这个可以自己控制</span>
	<span class="token keyword">void</span> <span class="token function">PopRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> _size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		start <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>

		<span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			end <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//直接跳过中间的</span>
		_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		_size <span class="token operator">-=</span> n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _freeList <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	size_t<span class="token operator">&amp;</span> <span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _maxSize<span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>

	size_t <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> _size<span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	size_t _maxSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	size_t _size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而对于FreeList类当中的PushRange成员函数，我们最好也像PopRange一样给它增加一个参数，表示插入对象的个数，不然我们这时还需要通过遍历统计插入对象的个数。</p>
<p>因此之前在调用PushRange的地方就需要修改一下，而我们实际就在一个地方调用过PushRange函数，并且此时插入对象的个数也是很容易知道的。当时thread cache从central cache获取了actualNum个对象，将其中的一个返回给了申请对象的线程，剩下的actualNum-1个挂到了thread cache对应的桶当中，所以这里插入对象的个数就是actualNum-1。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031605293.png" alt="image-20220903160515219"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>当thread cache的某个自由链表过长时，我们实际就是把这个自由链表当中全部的对象都还给central cache了，但这里在设计PopRange接口时还是设计的是取出指定个数的对象，因为在某些情况下当自由链表过长时，我们可能并不一定想把链表中全部的对象都取出来还给central cache，这样设计就是为了增加代码的可修改性。</p>
<p>其次，当我们判断thread cache是否应该还对象给central cache时，还可以综合考虑每个thread cache整体的大小。比如当某个thread cache的总占用大小超过一定阈值时，我们就将该thread cache当中的对象还一些给central cache，这样就尽量避免了某个线程的thread cache占用太多的内存。对于这一点，在tcmalloc当中就是考虑到了的。</p>
<h2 id="central-cache回收内存"><a href="#central-cache回收内存" class="headerlink" title="central cache回收内存"></a>central cache回收内存</h2><p>当thread cache中某个自由链表太长时，会将自由链表当中的这些对象还给central cache中的span。</p>
<p>但是需要注意的是，还给central cache的这些对象不一定都是属于同一个span的。central cache中的每个哈希桶当中可能都不止一个span，因此当我们计算出还回来的对象应该还给central cache的哪一个桶后，还需要知道这些对象到底应该还给这个桶当中的哪一个span。</p>
<h3 id="对象的地址-gt-对象所在的页号"><a href="#对象的地址-gt-对象所在的页号" class="headerlink" title="对象的地址->对象所在的页号"></a>对象的地址-&gt;对象所在的页号</h3><p>首先我们必须理解的是，某个页当中的所有地址除以页的大小都等该页的页号。比如我们这里假设一页的大小是100，那么地址<code>0~99</code>都属于第0页，它们除以100都等于0，而地址<code>100~199</code>都属于第1页，它们除以100都等于1。</p>
<h3 id="如何找到一个对象对应的span？"><a href="#如何找到一个对象对应的span？" class="headerlink" title="如何找到一个对象对应的span？"></a>如何找到一个对象对应的span？</h3><p>虽然我们现在可以通过对象的地址得到其所在的页号，但是我们还是不能知道这个对象到底属于哪一个span。因为一个span管理的可能是多个页。</p>
<p>为了解决这个问题，我们可以建立页号和span之间的映射。由于这个映射关系在page cache进行span的合并时也需要用到，因此我们直接将其存放到page cache里面。这时我们就需要在PageCache类当中添加一个映射关系了，这里可以用C++当中的unordered_map进行实现，并且添加一个函数接口，用于让central cache获取这里的映射关系。（下面代码中只展示了PageCache类当中新增的成员）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单例模式</span>
<span class="token keyword">class</span> <span class="token class-name">PageCache</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//获取从对象到span的映射</span>
	Span<span class="token operator">*</span> <span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>PAGE_ID<span class="token punctuation">,</span> Span<span class="token operator">*</span><span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每当page cache分配span给central cache时，都需要记录一下页号和span之间的映射关系。此后当thread cache还对象给central cache时，才知道应该具体还给哪一个span。</p>
<p>因此当central cache在调用NewSpan接口向page cache申请k页的span时，page cache在返回这个k页的span给central cache之前，应该建立这k个页号与该span之间的映射关系。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">//第K个桶里面有没有span</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			_idSpanMap<span class="token punctuation">[</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> kSpan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> kSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//检查一下后面的 桶里面有没有span，如果有的话，把它进行切分</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			Span<span class="token operator">*</span> nSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//切</span>
			Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>
			<span class="token comment">//在nSpan的头部切k页下来</span>
			kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> nSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>  <span class="token comment">//修改起始地址</span>
			kSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>		<span class="token comment">//获得k页</span>

			nSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+=</span> k<span class="token punctuation">;</span>	 <span class="token comment">//起始页号修改</span>
			nSpan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span>			<span class="token comment">//页数修改</span>
			<span class="token comment">//将剩下的挂到对应映射的位置</span>
			_spanLists<span class="token punctuation">[</span>nSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//建立id和span的映射</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				_idSpanMap<span class="token punctuation">[</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> kSpan<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>


			<span class="token keyword">return</span> kSpan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//已经没有任何Span了</span>
	Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//128</span>
	<span class="token comment">//指针转化页号</span>
	bigSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>  <span class="token comment">//初始页号</span>
	bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//挂载</span>
	_spanLists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//尽量避免代码重复，递归调用自己s，相当于第一遍走一个堆申请，第二遍返回span</span>
	<span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时我们就可以通过对象的地址找到该对象对应的span了，直接将该对象的地址除以页的大小得到页号，然后在unordered_map当中找到其对应的span即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//页号-&gt;id</span>
	<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>		<span class="token comment">//id-&gt;span</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意一下，当我们要通过某个页号查找其对应的span时，该页号与其span之间的映射一定是建立过的，如果此时我们没有在unordered_map当中找到，则说明我们之前的代码逻辑有问题，因此当没有找到对应的span时可以直接用断言结束程序，以表明程序逻辑出错。</p>
<h3 id="ReleaseListToSpans"><a href="#ReleaseListToSpans" class="headerlink" title="ReleaseListToSpans"></a>ReleaseListToSpans</h3><p>这时当thread cache还对象给central cache时，就可以依次遍历这些对象，将这些对象插入到其对应span的自由链表当中，并且及时更新该span的_useCount计数即可。</p>
<p>在thread cache还对象给central cache的过程中，如果central cache中某个span的_useCount减到0时，说明这个span分配出去的对象全部都还回来了，那么此时就可以将这个span再进一步还给page cache。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//加锁</span>
	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//怎么知道哪块内存对应的哪个span？</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>

		Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//头插来还</span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_useCount <span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_useCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token comment">//说明所有的小块内存都回来了</span>
			<span class="token comment">//span可以回收给page cache，page cache可以再去做前后页的合并</span>
			_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
			span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			span<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			span<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

			<span class="token comment">//还给下一层，桶锁解锁，其他线程也可以还</span>
			_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//后面还要加一个Page的大锁</span>
			<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//解了大锁之后加上桶锁</span>
			_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		start <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意，如果要把某个span还给page cache，我们需要先将这个span从central cache对应的双链表中移除，然后再将该span的自由链表置空，因为page cache中的span是不需要切分成一个个的小对象的，以及该span的前后指针也都应该置空，因为之后要将其插入到page cache对应的双链表中。但span当中记录的起始页号以及它管理的页数是不能清除的，否则对应内存块就找不到了。</p>
<p>并且在central cache还span给page cache时也存在锁的问题，此时需要先将central cache中对应的桶锁解掉，然后再加上page cache的大锁之后才能进入page cache进行相关操作，当处理完毕回到central cache时，除了将page cache的大锁解掉，还需要立刻获得central cache对应的桶锁，然后将还未还完对象继续还给central cache中对应的span。</p>
<h2 id="page-cache回收内存"><a href="#page-cache回收内存" class="headerlink" title="page cache回收内存"></a>page cache回收内存</h2><p>如果central cache中有某个span的<code>_useCount</code>减到0了，那么central cache就需要将这个span还给page cache了。</p>
<p>这个过程看似是非常简单的，page cache只需将还回来的span挂到对应的哈希桶上就行了。但实际为了缓解内存碎片的问题，page cache还需要尝试将还回来的span与其他空闲的span进行合并。</p>
<h3 id="前后页合并设计"><a href="#前后页合并设计" class="headerlink" title="前后页合并设计"></a>前后页合并设计</h3><p>合并的过程可以分为向前合并和向后合并。如果还回来的span的起始页号是num，该span所管理的页数是n。那么在向前合并时，就需要判断第num-1页对应span是否空闲，如果空闲则可以将其进行合并，并且合并后还需要继续向前尝试进行合并，直到不能进行合并为止。而在向后合并时，就需要判断第num+n页对应的span是否空闲，如果空闲则可以将其进行合并，并且合并后还需要继续向后尝试进行合并，直到不能进行合并为止。</p>
<p>因此page cache在合并span时，是<strong>需要通过页号获取到对应的span</strong>的，这就是我们要把页号与span之间的映射关系存储到page cache的原因。</p>
<h4 id="识别页的位置"><a href="#识别页的位置" class="headerlink" title="识别页的位置"></a>识别页的位置</h4><p>但需要注意的是，当我们通过页号找到其对应的span时，这个span此时可能挂在page cache，也可能挂在central cache。而在合并时我们只能合并挂在page cache的span，因为挂在central cache的span当中的对象正在被其他线程使用。</p>
<p>可是我们不能通过span结构当中的<code>_useCount</code>成员，来判断某个span到底是在central cache还是在page cache。因为当central cache刚向page cache申请到一个span时，这个span的<code>_useCount</code>就是等于0的，这时可能<strong>当我们正在对该span进行切分的时候，page cache就把这个span拿去进行合并了</strong>，这显然是不合理的。</p>
<p>鉴于此，我们可以在span结构中再增加一个<code>_isUse</code>成员，用于标记这个span是否正在被使用，而当一个span结构被创建时我们默认该span是没有被使用的。</p>
<p>这是我们就需要修改在centralcache申请完之后，就要设置为true</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041050044.png" alt="image-20220904105010897"></p>
<p>而当central cache将某个span还给page cache时，也就需要将该span的_isUse改成false。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041051282.png" alt="image-20220904105111197"></p>
<h4 id="再建立映射关系"><a href="#再建立映射关系" class="headerlink" title="再建立映射关系"></a>再建立映射关系</h4><p>由于在合并page cache当中的span时，需要通过页号找到其对应的span，而一个span是在被分配给central cache时，才建立的各个页号与span之间的映射关系，因此page cache当中的span也需要建立页号与span之间的映射关系。</p>
<p>与central cache中的span不同的是，在page cache中，只需建立一个span的首尾页号与该span之间的映射关系。因为当一个span在尝试进行合并时，如果是往前合并，那么只需要通过一个span的尾页找到这个span，如果是向后合并，那么只需要通过一个span的首页找到这个span。也就是说，在进行合并时我们只需要用到span与其首尾页之间的映射关系就够了。</p>
<p>因此当我们申请k页的span时，如果是将n页的span切成了一个k页的span和一个n-k页的span，我们除了需要建立k页span中每个页与该span之间的映射关系之外，还需要建立剩下的n-k页的span与其首尾页之间的映射关系。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041101402.png" alt="image-20220904110131298"></p>
<p>此时page cache当中的span就都与其首尾页之间建立了映射关系，现在我们就可以进行span的合并了，其合并逻辑如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//对span前后的页，尝试进行合并，缓解内存碎片问题</span>
	PAGE_ID prevID <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>prevID<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//向前合并</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//1. 前面页号没有，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//2. 前面相邻的span在使用，不合并了</span>
		Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token operator">-&gt;</span>second<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//3. 超过最大span页数，也不能管理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		_spanLists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">delete</span> prevSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 向后合并</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		PAGE_ID nextId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>nextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//1. 后面的页号没有，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//2. 后面相邻的span在使用，不合并了</span>
		Span<span class="token operator">*</span> nextSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//3. 超过最大span页数，也不能管理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		<span class="token comment">//对应的桶里面删掉</span>
		_spanLists<span class="token punctuation">[</span>nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">delete</span> nextSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//连入，然后建立映射，此时已经不在使用了,方便别人合并了</span>
	_spanLists<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	span<span class="token operator">-&gt;</span>_isUse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>
	_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageId<span class="token operator">+</span>span<span class="token operator">-&gt;</span>_n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="合并注意事项"><a href="#合并注意事项" class="headerlink" title="合并注意事项"></a>合并注意事项</h4><p>向前合并：</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041103029.png" alt="image-20220904110350922"></p>
<p>向后合并：</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041118502.png" alt="image-20220904111833433"></p>
<p>需要注意的是，在向前或向后进行合并的过程中：</p>
<blockquote>
<p><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果没有通过页号获取到其对应的span，说明对应到该页的内存块还未申请，此时需要停止合并。<br><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果通过页号获取到了其对应的span，但该span处于被使用的状态，那我们也必须停止合并。<br><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果合并后大于128页则不能进行本次合并，因为page cache无法对大于128页的span进行管理。<br><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在合并span时，由于这个span是在page cache的某个哈希桶的双链表当中的，因此在合并后需要将其从对应的双链表中移除，然后再将这个被合并了的span结构进行delete。</p>
</blockquote>
<p><strong>除此之外，在合并结束后，除了将合并后的span挂到page cache对应哈希桶的双链表当中，还需要建立该span与其首位页之间的映射关系，便于此后合并出更大的span。</strong></p>
<h2 id="释放内存过程联调"><a href="#释放内存过程联调" class="headerlink" title="释放内存过程联调"></a>释放内存过程联调</h2><h3 id="ConcurrentFree"><a href="#ConcurrentFree" class="headerlink" title="ConcurrentFree"></a>ConcurrentFree</h3><p>至此我们将thread cache、central cache以及page cache的释放流程也都写完了，此时我们就可以向外提供一个ConcurrentFree函数，用于释放内存块，释放内存块时每个线程通过自己的thread cache对象，调用thread cache中释放内存对象的接口即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t size<span class="token comment">/*暂时*/</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>

	pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="UnionTest1-1"><a href="#UnionTest1-1" class="headerlink" title="UnionTest1"></a>UnionTest1</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestConcurrentAlloc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p5 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p5<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先解决报错</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041405319.png" alt="image-20220904140527220"></p>
<p>因为end的赋值是nullptr，少了一行赋值，应该让end能够等于start</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041407696.png" alt="image-20220904140747605"></p>
<p>解决之后开始调试</p>
<p>首先，这三次申请和释放的对象大小进行对齐后都是8字节，因此对应操作的就是thread cache和central cache的第0号桶，以及page cache的第1号桶。</p>
<p>由于第三次对象申请时，刚好将thread cache第0号桶当中仅剩的一个对象拿走了，因此在三次对象申请后thread cache的第0号桶当中是没有对象的。</p>
<p>通过监视窗口可以看到，此时thread cache第0号桶中自由链表的<code>_maxSize</code>已经慢增长到了3，而当我们释放完第一个对象后，该自由链表当中对象的个数只有一个，因此不会将该自由链表当中的对象进一步还给central cache。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041356736.png" alt="image-20220904135647637"></p>
<p>当第二个对象释放给thread cache的第0号桶后，该桶对应自由链表当中对象的个数变成了2，也是不会进行ListTooLong操作的。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041357035.png" alt="image-20220904135709933"></p>
<p>直到第三个对象释放给thread cache的第0号桶时，此时该自由链表的<code>_size</code>的值变为3，与<code>_maxSize</code>的值相等，现在thread cache就需要将对象给central cache了。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041357030.png" alt="image-20220904135729932"></p>
<p>thread cache先是将第0号桶当中的对象弹出MaxSize个，在这里实际上就是全部弹出，此时该自由链表<code>_size</code>的值变为0，然后继续调用central cache当中的ReleaseListToSpans函数，将这三个对象还给central cache当中对应的span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041357016.png" alt="image-20220904135750937"></p>
<blockquote>
<p>下面这里是64位的，申请了6个对象的效果，可以看到映射这里是对的</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041417426.png" alt="image-20220904141750328"></p>
</blockquote>
<p>在进入central cache的第0号桶还对象之前，先把第0号桶对应的桶锁加上，然后通过查page cache中的映射表找到其对应的span，最后将这个对象头插到该span的自由链表中，并将该span的<code>_useCount</code>进行–。当第一个对象还给其对应的span时，可以看到该span的<code>_useCount</code>减到了2。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041358697.png" alt="image-20220904135852599"></p>
<p>而由于我们只进行了三次对象申请，并且这些对象大小对齐后大小都是8字节，因此我们申请的这三个对象实际都是同一个span切分出来的。当我们将这三个对象都还给这个span时，该span的_useCount就减为了0。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041359773.png" alt="image-20220904135914691"></p>
<p>现在central cache就需要将这个span进一步还给page cache，而在将该span交给page cache之前，会将该span的自由链表以及前后指针都置空。并且在进入page cache之前会先将central cache第0号桶的桶锁解掉，然后再加上page cache的大锁，之后才能进入page cache进行相关操作。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041359373.png" alt="image-20220904135945293"></p>
<p>由于这个一页的span是从128页的span的头部切下来的，在向前合并时由于前面的页还未向系统申请，因此在查映射关系时是无法找到的，此时直接停止了向前合并。</p>
<blockquote>
<p>（说明一下：由于下面是重新另外进行的一次调试，因此监视窗口显示的span的起始页号与之前的不同，实际应该与上面一致）</p>
</blockquote>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041400307.png" alt="image-20220904140014216"></p>
<p>而在向后合并时，由于page cache没有将该页后面的页分配给central cache，因此在向后合并时肯定能够找到一个127页的span进行合并。合并后就变成了一个128页的span，这时我们将原来127页的span从第127号桶删除，然后还需要将该127页的span结构进行delete，因为它管理的127页已经与1页的span进行合并了，不再需要它来管理了。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041400191.png" alt="image-20220904140035071"></p>
<blockquote>
<p>可以看到合并之后的效果是分出去的128页现在又还回来了<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041427340.png" alt="image-20220904142714243"></p>
</blockquote>
<p>紧接着将这个128页的span插入到第128号桶，然后建立该span与其首尾页的映射，便于下次被用于合并，最后再将该span的状态设置为未被使用的状态即可。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041400245.png" alt="image-20220904140056169"></p>
<p>当从page cache回来后，除了将page cache的大锁解掉，还需要立刻加上central cache中对应的桶锁，然后继续将对象还给central cache中的span，但此时实际上是还完了，因此再将central cache的桶锁解掉就行了。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041401763.png" alt="image-20220904140117686"></p>
<p>至此我们便完成了这三个对象的申请和释放流程。</p>
<h3 id="多线程场景测试"><a href="#多线程场景测试" class="headerlink" title="多线程场景测试"></a>多线程场景测试</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MultiThreadAlloc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">MultiThreadAlloc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestMultiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>MultiThreadAlloc1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>MultiThreadAlloc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>多线程情况下出现的错误</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041442757.png" alt="image-20220904144231662"></p>
<p>大佬认为在不同的模块分配的内存，释放的时候会出现此问题，而此问题，只在Debug模式会提示，Release模式不会提示。但不提示并不代表没有错误，一定要解决之。解决的方法是：在哪个模块分配的内存，就在哪个模块释放。</p>
<p>阅读往上大佬解决该问题的方法，发现改成Release版之后就可以使用了</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041443785.png" alt="image-20220904144330717"></p>
<p>由于这里我们没有涉及到动态库，所以应该是释放的问题</p>
<p>1，内存不能跨模块分配和释放，模块分配的内存必须由该模块自己来释放。应该在DLL中再加一个方法，比如MemRelease，主程序调用这个方法来释放内存。</p>
<p>2，就是绕过new和<a target="_blank" rel="noopener" href="http://www.so.com/s?q=delete&amp;ie=utf-8&amp;src=se_lighten_f">delete</a>，用GlobalAlloc()和GlobalFree()的方法</p>
<p>现在就去寻找delete，发现这里没有从桶中取出就delete了span</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041456119.png" alt="image-20220904145649014"></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041457241.png" alt="image-20220904145715143"></p>
<p>而且漏掉了一个break的逻辑，差点出错</p>
<p>现在运行通过了</p>
<h2 id="一次申请大于256KB的大块内存"><a href="#一次申请大于256KB的大块内存" class="headerlink" title="一次申请大于256KB的大块内存"></a>一次申请大于256KB的大块内存</h2><p>申请过程</p>
<p>之前说到，每个线程的thread cache是用于申请小于等于256KB的内存的，而对于大于256KB的内存，我们可以考虑直接向page cache申请，但page cache中最大的页也就只有128页，因此如果是大于128页的内存申请，就只能直接向堆申请了。</p>
<table>
<thead>
<tr>
<th>申请内存的大小</th>
<th>申请方式</th>
<th>注</th>
</tr>
</thead>
<tbody><tr>
<td>x≤256KB(32页)</td>
<td>向thread cache申请</td>
<td>当申请的内存大于256KB时，虽然不是从thread cache进行获取，但在分配内存时也是需要进行向上对齐的，</td>
</tr>
<tr>
<td>32页&lt;x≤128页</td>
<td>向page cache申请</td>
<td>对于大于256KB的内存我们可以直接按页进行对齐。</td>
</tr>
<tr>
<td>x≥128页</td>
<td>向堆申请</td>
<td></td>
</tr>
</tbody></table>
<p>而我们之前实现RoundUp函数时，对传入字节数大于256KB的情况直接做了断言处理，因此这里需要对RoundUp函数稍作修改。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取向上对齐后的字节数</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">RoundUp</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//大于256KB的按页对齐</span>
		<span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在对于之前的申请逻辑就需要进行修改了，当申请对象的大小大于256KB时，就不用向thread cache申请了，这时先计算出按页对齐后实际需要申请的页数，然后通过调用NewSpan申请指定页数的span即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		size_t kpage <span class="token operator">=</span> alignSize<span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>kpage<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			pTLSThreadCache <span class="token operator">=</span> <span class="token keyword">new</span> ThreadCache<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> pTLSThreadCache <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也就是说，申请大于256KB的内存时，会直接调用page cache当中的NewSpan函数进行申请，因此这里我们需要再对NewSpan函数进行改造，当需要申请的内存页数大于128页时，就直接向堆申请对应页数的内存块。而如果申请的内存页数是小于128页的，那就在page cache中进行申请，因此当申请大于256KB的内存调用NewSpan函数时也是需要加锁的，因为我们可能是在page cache中进行申请的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//堆中获取</span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>
        _idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>
		<span class="token keyword">return</span> span<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>###释放过程</p>
<p>当释放对象时，我们需要判断释放对象的大小：</p>
<table>
<thead>
<tr>
<th>释放内存的大小</th>
<th>释放方式</th>
</tr>
</thead>
<tbody><tr>
<td>x≤256KB(32页)</td>
<td>释放给thread cache</td>
</tr>
<tr>
<td>32页&lt;x≤128页</td>
<td>释放给page cache</td>
</tr>
<tr>
<td>x≥128页</td>
<td>释放给堆</td>
</tr>
</tbody></table>
<p>因此当释放对象时，我们需要先找到该对象对应的span，但是在释放对象时我们只知道该对象的起始地址。这也就是我们在申请大于256KB的内存时，也要给申请到的内存建立span结构，并建立起始页号与该span之间的映射关系的原因。此时我们就可以通过释放对象的起始地址计算出起始页号，进而通过页号找到该对象对应的span。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//指针转换成页号</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//还回去的时候要加锁</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此page cache在回收span时也需要进行判断，如果该span的大小是小于等于128页的，那么直接还给page cache进行了，page cache会尝试对其进行合并。而如果该span的大小是大于128页的，那么说明该span是直接向堆申请的，我们直接将这块内存释放给堆，然后将这个span结构进行delete就行了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//大于128页直接向堆申请</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//从id拿到指针地址</span>
		<span class="token function">SystemFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">delete</span> span<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// . . .</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>说明一下，直接向堆申请内存时我们调用的接口是VirtualAlloc，与之对应的将内存释放给堆的接口叫做VirtualFree，而Linux下的brk和mmap对应的释放接口叫做sbrk和unmmap。此时我们也可以将这些释放接口封装成一个叫做SystemFree的接口，当我们需要将内存释放给堆时直接调用SystemFree即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SystemFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>
    <span class="token function">VirtualFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MEM_RELEASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token comment">// sbrk unmmap等</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>下面我们对大于256KB的申请释放流程进行简单的测试：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//找page cache申请</span>
<span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">257</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//257KB</span>
<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token number">257</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//找堆申请</span>
<span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">129</span> <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//129页</span>
<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token number">129</span> <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>发现错误</strong></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041632397.png" alt="image-20220904163255236"></p>
<p>发现是这里桶里面找不到对象，所以就会直接走到assert的报错</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041635066.png" alt="image-20220904163524895"></p>
<p>原来是这里没有建立桶的映射，所以进去补一下</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041630049.png" alt="image-20220904163044895"></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041636369.png" alt="image-20220904163618219"></p>
<p>改一下就对了</p>
<p>当申请257KB的内存时，由于257KB的内存按页向上对齐后是33页，并没有大于128页，因此不会直接向堆进行申请，会向page cache申请内存，但此时page cache当中实际是没有内存的，最终page cache就会向堆申请一个128页的span，将其切分成33页的span和95页的span，并将33页的span进行返回。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041638486.png" alt="image-20220904163822336"></p>
<p>而在释放内存时，由于该对象的大小大于了256KB，因此不会将其还给thread cache，而是直接调用的page cache当中的释放接口。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041638287.png" alt="image-20220904163834138"></p>
<p>由于该对象的大小是33页，不大于128页，因此page cache也不会直接将该对象还给堆，而是尝试对其进行合并，最终就会把这个33页的span和之前剩下的95页的span进行合并，最终将合并后的128页的span挂到第128号桶中。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041638771.png" alt="image-20220904163849624"></p>
<p>当申请129页的内存时，由于是大于256KB的，于是还是调用的page cache对应的申请接口，但此时申请的内存同时也大于128页，因此会直接向堆申请。在申请后还会建立该span与其起始页号之间的映射，便于释放时可以通过页号找到该span。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041639407.png" alt="image-20220904163908236"></p>
<p>在释放内存时，通过对象的地址找到其对应的span，从span结构中得知释放内存的大小大于128页，于是会将该内存直接还给堆。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041639160.png" alt="image-20220904163922653"></p>
<h2 id="定长内存池配合脱离使用new"><a href="#定长内存池配合脱离使用new" class="headerlink" title="定长内存池配合脱离使用new"></a>定长内存池配合脱离使用new</h2><p>tcmalloc是要在高并发场景下替代malloc进行内存申请的，因此tcmalloc在实现的时，其内部是不能调用malloc函数的，我们当前的代码中存在通过new获取到的内存，而new在底层实际上就是封装了malloc。</p>
<p>为了完全脱离掉malloc函数，此时我们之前实现的定长内存池就起作用了，代码中使用new时基本都是为Span结构的对象申请空间，而span对象基本都是在page cache层创建的，因此我们可以在PageCache类当中定义一个<code>_spanPool</code>，用于span对象的申请和释放。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单例模式</span>
<span class="token keyword">class</span> <span class="token class-name">PageCache</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后将代码中使用new的地方替换为调用定长内存池当中的New函数，将代码中使用delete的地方替换为调用定长内存池当中的Delete函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//申请span对象</span>
Span<span class="token operator">*</span> span <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放span对象</span>
_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，当使用定长内存池当中的New函数申请Span对象时，New函数通过定位new也是对Span对象进行了初始化的。</p>
<p>此外，每个线程第一次申请内存时都会创建其专属的thread cache，而这个thread cache目前也是new出来的，我们也需要对其进行替换。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//通过TLS，每个线程无锁的获取自己专属的ThreadCache对象</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>mutex tcMtx<span class="token punctuation">;</span>
	<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>ThreadCache<span class="token operator">&gt;</span> tcPool<span class="token punctuation">;</span>
	tcMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	pTLSThreadCache <span class="token operator">=</span> tcPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tcMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里我们将用于申请ThreadCache类对象的定长内存池定义为静态的，保持全局只有一个，让所有线程创建自己的thread cache时，都在个定长内存池中申请内存就行了。</p>
<p>但注意在从该定长内存池中申请内存时需要加锁，防止多个线程同时申请自己的ThreadCache对象而导致线程安全问题。</p>
<p>最后在SpanList的构造函数中也用到了new，因为SpanList是带头循环双向链表，所以在构造期间我们需要申请一个span对象作为双链表的头结点。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span>
<span class="token keyword">class</span> <span class="token class-name">SpanList</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">SpanList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_head <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
		_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Span<span class="token operator">*</span> _head<span class="token punctuation">;</span>
	<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于每个span双链表只需要一个头结点，因此将这个定长内存池定义为静态的，保持全局只有一个，让所有span双链表在申请头结点时，都在一个定长内存池中申请内存就行了。</p>
<h2 id="优化使用和map相关锁"><a href="#优化使用和map相关锁" class="headerlink" title="优化使用和map相关锁"></a>优化使用和map相关锁</h2><h3 id="优化释放内存不需要传入大小"><a href="#优化释放内存不需要传入大小" class="headerlink" title="优化释放内存不需要传入大小"></a>优化释放内存不需要传入大小</h3><p>当我们使用malloc函数申请内存时，需要指明申请内存的大小；而当我们使用free函数释放内存时，只需要传入指向这块内存的指针即可。而我们目前实现的内存池，在释放对象时除了需要传入指向该对象的指针，还需要传入该对象的大小。</p>
<p>原因如下：</p>
<ul>
<li>如果释放的是大于256KB的对象，需要根据对象的大小来判断这块内存到底应该还给page cache，还是应该直接还给堆。</li>
<li>如果释放的是小于等于256KB的对象，需要根据对象的大小计算出应该还给thread cache的哪一个哈希桶。</li>
</ul>
<p>如果我们也想做到，在释放对象时不用传入对象的大小，那么我们就需要建立对象地址与对象大小之间的映射。由于现在可以通过对象的地址找到其对应的span，而span的自由链表中挂的都是相同大小的对象。<br>因此我们可以在Span结构中再增加一个<code>_objSize</code>成员，该成员代表着这个span管理的内存块被切成的一个个对象的大小。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Span</span>
<span class="token punctuation">{</span>
	PAGE_ID _pageId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//大块内存起始页的页号</span>
	size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//页的数量</span>

	Span<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//双链表结构</span>
	Span<span class="token operator">*</span> _prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	size_t objSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//切好的小对象的内存的大小</span>
	size_t _useCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//切好的小块内存，被分配给thread cache的计数</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//切好的小块内存的自由链表</span>
	<span class="token keyword">bool</span> _isUse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//是否在使用</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而所有的span都是从page cache中拿出来的，因此每当我们调用NewSpan获取到一个k页的span时，就应该将这个span的<code>_objSize</code>保存下来。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
span<span class="token operator">-&gt;</span>_objSize <span class="token operator">=</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>代码中有两处，一处是在central cache中获取非空span时，如果central cache对应的桶中没有非空的span，此时会调用NewSpan获取一个k页的span；另一处是当申请大于256KB内存时，会直接调用NewSpan获取一个k页的span。</p>
<p>此时当我们释放对象时，就可以直接从对象的span中获取到该对象的大小，准确来说获取到的是对齐以后的大小。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//这里释放的时候可以直接获取到span的size</span>
	size_t size <span class="token operator">=</span> span<span class="token operator">-&gt;</span>objSize<span class="token punctuation">;</span>  

	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//指针转换成页号</span>

		<span class="token comment">//还回去的时候要加锁</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="读取映射关系时的加锁问题"><a href="#读取映射关系时的加锁问题" class="headerlink" title="读取映射关系时的加锁问题"></a>读取映射关系时的加锁问题</h3><p>我们将页号与span之间的映射关系是存储在PageCache类当中的，当我们访问这个映射关系时是需要加锁的，因为STL容器是不保证线程安全的。</p>
<p>对于当前代码来说，如果我们此时正在page cache进行相关操作，那么访问这个映射关系是安全的，因为当进入page cache之前是需要加锁的，我们曾经是先解掉了central的桶锁，然后是加上了page锁，因此可以保证此时只有一个线程在进行访问。</p>
<p>但如果我们是在central cache访问这个映射关系，或是在调用ConcurrentFree函数释放内存时访问这个映射关系，那么就存在线程安全的问题，<strong>因为我要去读，但是有可能别人在写，所以说可能会造成了读的时候也在写，万一对方把这个节点删掉了，我还在读，这肯定是会出现线程安全问题的</strong>。因为此时可能其他线程正在page cache当中进行某些操作，并且该线程此时可能也在访问这个映射关系，因此当我们在page cache外部访问这个映射关系时是需要加锁的。</p>
<p>实际就是在调用page cache对外提供访问映射关系的函数时需要加锁，这里我们可以考虑使用C++当中的unique_lock，当然你也可以用普通的锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//访问的时候要加锁，这里使用unique锁，因为出了作用域可以自己解锁，使用方便</span>
	std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>_pagemtx<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多线程环境下对比malloc测试"><a href="#多线程环境下对比malloc测试" class="headerlink" title="多线程环境下对比malloc测试"></a>多线程环境下对比malloc测试</h2><p>之前我们只是对代码进行了一些基础的单元测试，下面我们在多线程场景下对比malloc进行测试。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BenchmarkMalloc</span><span class="token punctuation">(</span>size_t ntimes<span class="token punctuation">,</span> size_t nworks<span class="token punctuation">,</span> size_t rounds<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">vthread</span><span class="token punctuation">(</span>nworks<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> malloc_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> free_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nworks<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		vthread<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> k<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
			v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>ntimes<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
					v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//v.push_back(malloc((16 + i) % 8192 + 1));</span>
				<span class="token punctuation">}</span>
				size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
					<span class="token function">free</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				malloc_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span>
				free_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vthread<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次malloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次free %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发malloc&amp;free %u次，总计花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> nworks<span class="token operator">*</span>rounds<span class="token operator">*</span>ntimes<span class="token punctuation">,</span> malloc_costtime <span class="token operator">+</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">BenchmarkConcurrentMalloc</span><span class="token punctuation">(</span>size_t ntimes<span class="token punctuation">,</span> size_t nworks<span class="token punctuation">,</span> size_t rounds<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">vthread</span><span class="token punctuation">(</span>nworks<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> malloc_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> free_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nworks<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		vthread<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
			v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>ntimes<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
					v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//v.push_back(ConcurrentAlloc((16 + i) % 8192 + 1));</span>
				<span class="token punctuation">}</span>
				size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
					<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				malloc_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span>
				free_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vthread<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次concurrent alloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次concurrent dealloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发concurrent alloc&amp;dealloc %u次，总计花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> nworks<span class="token operator">*</span>rounds<span class="token operator">*</span>ntimes<span class="token punctuation">,</span> malloc_costtime <span class="token operator">+</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	size_t n <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=========================================================="</span> <span class="token operator">&lt;&lt;</span>
		endl<span class="token punctuation">;</span>
	<span class="token function">BenchmarkConcurrentMalloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">BenchmarkMalloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=========================================================="</span> <span class="token operator">&lt;&lt;</span>
		endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中测试函数各个参数的含义如下：</p>
<blockquote>
<p><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ntimes：单轮次申请和释放内存的次数。<br><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> nworks：线程数。<br><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> rounds：轮次。</p>
</blockquote>
<p>在测试函数中，我们通过clock函数分别获取到每轮次申请和释放所花费的时间，然后将其对应累加到malloc_costtime和free_costtime上。最后我们就得到了，nworks个线程跑rounds轮，每轮申请和释放ntimes次，这个过程申请所消耗的时间、释放所消耗的时间、申请和释放总共消耗的时间。</p>
<p>注意，我们创建线程时让线程执行的是lambda表达式，而我们这里在使用lambda表达式时，以值传递的方式捕捉了变量k，以引用传递的方式捕捉了其他父作用域中的变量，因此我们可以将各个线程消耗的时间累加到一起。</p>
<p>我们将所有线程申请内存消耗的时间都累加到malloc_costtime上， 将释放内存消耗的时间都累加到free_costtime上，此时malloc_costtime和free_costtime可能被多个线程同时进行累加操作的，所以存在线程安全的问题。鉴于此，我们在定义这两个变量时使用了atomic类模板，这时对它们的操作就是原子操作了。</p>
<p>此时报错1：</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209042058090.png" alt="image-20220904205806900"></p>
<p>判断应该是printf的问题%u不能格式化输出atomic，于是这里改成cout好了</p>
<p>报错2：这里显示了行数</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209042055660.png" alt="image-20220904205523408"></p>
<p>锁定报错位置</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209042100998.png" alt="image-20220904210002816"></p>
<p>这就是说明pos == head</p>
<h3 id="当前性能对比"><a href="#当前性能对比" class="headerlink" title="当前性能对比"></a>当前性能对比</h3><p>强制一个桶里：</p>
<p>10000</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051137306.png" alt="image-20220905113727210"></p>
<p>100000</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051144597.png" alt="image-20220905114402512"></p>
<p>不同的桶：</p>
<p>1000</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051208520.png" alt="image-20220905120849440"></p>
<p>10000</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051209797.png" alt="image-20220905120917711"></p>
<p>居然是高了</p>
<h2 id="复杂调试技巧"><a href="#复杂调试技巧" class="headerlink" title="复杂调试技巧"></a>复杂调试技巧</h2><p>多线程调试比单线程调试要复杂得多，调试时各个线程之间会相互切换，并且每次调试切换的时机也是不固定的，这就使得调试过程变得非常难以控制。</p>
<p>下面给出三个调试时的小技巧：</p>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>一般情况下我们可以直接运行程序，通过报错来查找问题。如果此时报的是断言错误，那么我们可以直接定位到报错的位置，然后将此处的断言改为与断言条件相反的if判断，在if语句里面打上一个断点，但注意空语句是无法打断点的，这时我们随便在if里面加上一句代码就可以打断点了。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050932564.png" alt="image-20220905093200425"></p>
<p>此外，条件断点也可以通过右击普通断点来进行设置。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050936880.png" alt="image-20220905093620795"></p>
<p>右击后即可设置相应的条件，程序运行到此处时如果满足该条件则会停下来。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050936713.png" alt="image-20220905093640627"></p>
<p>运行到条件断点处后，我们就可以对当前程序进行进一步分析，找出断言错误的被触发原因。</p>
<h3 id="查看函数栈帧"><a href="#查看函数栈帧" class="headerlink" title="查看函数栈帧"></a>查看函数栈帧</h3><p>当程序运行到断点处时，我们需要对当前位置进行分析，如果检查后发现当前函数是没有问题的，这时可能需要回到调用该函数的地方进行进一步分析，此时我们可以依次点击“调试→窗口→调用堆栈”。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050937849.png" alt="image-20220905093728747"></p>
<p>此时我们就可以看到当前函数栈帧的调用情况，其中黄色箭头指向的是当前所在的函数栈帧。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050936029.png" alt="image-20220905093604933"></p>
<p>根据根据函数栈帧我们走到了上一层，发现是这里调用了该函数</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050938831.png" alt="image-20220905093850738"></p>
<p>发现这里的front的prev和next都等于他自己，说明这里是空的</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050939943.png" alt="image-20220905093946878"></p>
<p>再往上走发现问题了，这里少写了一个，应该是判断这个桶非空之后，删除这一个桶，如果没有写[k]的话，默认就是删除了第一个桶，所以错误</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050946208.png" alt="image-20220905094659121"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//第K个桶里面有没有span</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="疑似死循环时中断程序"><a href="#疑似死循环时中断程序" class="headerlink" title="疑似死循环时中断程序"></a>疑似死循环时中断程序</h3><p>当你在某个地方设置断点后，如果迟迟没有运行到断点处，而程序也没有崩溃，这时有可能是程序进入到某个死循环了。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051144930.png" alt="image-20220905114451823"></p>
<p>这时我们可以依次点击“调试→全部中断”。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051145306.png" alt="image-20220905114503218"></p>
<h3 id="更多的BUG记录"><a href="#更多的BUG记录" class="headerlink" title="更多的BUG记录"></a>更多的BUG记录</h3><h4 id="BUG1"><a href="#BUG1" class="headerlink" title="BUG1"></a>BUG1</h4><p>再次尝试的时候发现100轮的时候没有问题，但是走到1000轮的时候出现新的问题，再次重试的时候发现新的问题，现在函数栈帧打开，找到上一级的NewSpan</p>
<p>第一次运行报错<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050955605.png" alt="image-20220905095502502"></p>
<p>回去查找发现这里没有建立映射，因为这里是一开始pagecache还给centralcache的时候，如果桶里还有span的话要切下来，然后切走的时候需要建立span的映射，这里是桶里还有的情况下，忘记了写，下面如果桶里面灭有的情况下，反而写了，说明这里忘记了</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051111158.png" alt="image-20220905111116073"></p>
<p>修改一下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//第K个桶里面有没有span</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_idSpanMap<span class="token punctuation">[</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> kSpan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> kSpan<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="BUG2"><a href="#BUG2" class="headerlink" title="BUG2"></a>BUG2</h4><p>第二次运行报错<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051109196.png" alt="image-20220905110941093"></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051122148.png" alt="image-20220905112226028"></p>
<p>查找之后发现是一个很难找的问题，这里放在了外面while循环，很恶心</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051140019.png" alt="image-20220905114033890"></p>
<p>这就导致了向前合并这里的ret和prevID虽然循环，但是是始终不变的，这就出问题，出了一堆不可预知性的 问题</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">/</span>向前合并
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//对span前后的页，尝试进行合并，缓解内存碎片问题</span>
		PAGE_ID prevID <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>prevID<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//1. 前面页号没有，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//2. 前面相邻的span在使用，不合并了</span>
		Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token operator">-&gt;</span>second<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//3. 超过最大span页数，也不能管理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		<span class="token comment">//对应的桶里面移除</span>
		_spanLists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// delete prevSpan;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="性能瓶颈分析"><a href="#性能瓶颈分析" class="headerlink" title="性能瓶颈分析"></a>性能瓶颈分析</h2><p>经过前面的测试可以看到，我们的代码此时与malloc之间还是有差距的，此时我们就应该分析分析我们当前项目的瓶颈在哪里，但这不能简单的凭感觉，我们应该用性能分析的工具来进行分析。</p>
<h3 id="VS编译器下性能分析的操作步骤"><a href="#VS编译器下性能分析的操作步骤" class="headerlink" title="VS编译器下性能分析的操作步骤"></a>VS编译器下性能分析的操作步骤</h3><p>VS编译器中就带有性能分析的工具的，我们可以依次点击“调试→性能和诊断”进行性能分析，注意该操作要在Debug模式下进行。</p>
<blockquote>
<p>注：VS2022中，已经没有了性能和诊断，只有这个性能探查器</p>
</blockquote>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051210991.png" alt="image-20220905121053895"></p>
<p>接下来我们选择这个</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051211009.png" alt="image-20220905121149905"></p>
<p>同时我们将代码中n的值由10000调成了1000，否则该分析过程可能会花费较多时间，并且将malloc的测试代码进行了屏蔽，因为我们要分析的是我们实现的高并发内存池。</p>
<h2 id="分析性能瓶颈"><a href="#分析性能瓶颈" class="headerlink" title="分析性能瓶颈"></a>分析性能瓶颈</h2><p>通过分析结果可以看到，光是Deallocate和MapObjectToSpan这两个函数就占用了一半多的时间。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051522832.png" alt="image-20220905152232691"></p>
<p>而在Deallocate函数中，调用ListTooLong函数时消耗的时间是最多的。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051523490.png" alt="image-20220905152328383"></p>
<p>继续往下看，在ListTooLong函数中，调用ReleaseListToSpans函数时消耗的时间是最多的。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051524535.png" alt="image-20220905152445444"></p>
<p>再进一步看，在ReleaseListToSpans函数中，调用MapObjectToSpan函数时消耗的时间是最多的。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051525845.png" alt="image-20220905152505752"></p>
<p>也就是说，最终消耗时间最多的实际就是MapObjectToSpan函数，我们这时再来看看为什么调用MapObjectToSpan函数会消耗这么多时间。通过观察我们最终发现，调用该函数时会消耗这么多时间就是因为锁的原因。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051525650.png" alt="image-20220905152523551"></p>
<p>因此当前项目的瓶颈点就在锁竞争上面，需要解决调用MapObjectToSpan函数访问映射关系时的加锁问题。tcmalloc当中针对这一点使用了<strong>基数树</strong>进行优化，使得在读取这个映射关系时可以做到不加锁。</p>
<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>基数树实际上就是一个分层的哈希表，根据所分层数不同可分为单层基数树、二层基数树、三层基数树等。</p>
<h3 id="单层基数树"><a href="#单层基数树" class="headerlink" title="单层基数树"></a>单层基数树</h3><p>单层基数树实际采用的就是直接定址法，每一个页号对应span的地址就存储数组中在以该页号为下标的位置。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051441592.png" alt="image-20220905144144516"></p>
<p>最坏的情况下我们需要建立所有页号与其span之间的映射关系，因此这个数组中元素个数应该与页号的数目相同，数组中每个位置存储的就是对应span的指针。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单层基数树</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap1</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span>
	<span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span> <span class="token comment">//需要开辟数组的大小</span>
		size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeClass</span><span class="token double-colon punctuation">::</span><span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按页对齐后的大小</span>
		array_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>alignSize <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向堆申请空间</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>array_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对申请到的内存进行清理</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//k的范围不在[0, 2^BITS-1]</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> array_<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回该页号对应的span</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//k的范围必须在[0, 2^BITS-1]</span>
		array_<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">//建立映射</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> array_<span class="token punctuation">;</span> <span class="token comment">//存储映射关系的数组</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span> <span class="token comment">//页的数目</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时当我们需要建立映射时就调用set函数，需要读取映射关系时，就调用get函数就行了。</p>
<p>代码中的非类型模板参数BITS表示存储页号最多需要比特位的个数。在32位下我们传入的是32-PAGE_SHIFT，在64位下传入的是64-PAGE_SHIFT。而其中的LENGTH成员代表的就是页号的数目，即2^BITS^</p>
<p>比如32位平台下，以一页大小为8K为例，此时页的数目就是2^32^ ÷ 2^13^ = 2^19^ ，因此存储页号最多需要19个比特位，此时传入非类型模板参数的值就是32 − 13 = 19。由于32位平台下指针的大小是4字节，因此该数组的大小就是2 ^19^ × 4 = 2 ^21^ = 2 M，内存消耗不大，是可行的。但如果是在64位平台下，此时该数组的大小是2 ^51^ × 8 = 2 ^54^ = 2 ^24^这显然是不可行的，实际上对于64位的平台，我们需要使用三层基数树。</p>
<h3 id="二层基数树"><a href="#二层基数树" class="headerlink" title="二层基数树"></a>二层基数树</h3><p>  这里还是以32位平台下，一页的大小为8K为例来说明，此时存储页号最多需要19个比特位。而二层基数树实际上就是把这19个比特位分为两次进行映射。</p>
<p>  比如用前5个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号对应的span指针。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051444068.png" alt="image-20220905144456983"></p>
<p>在二层基数树中，第一层的数组占用2^5^ × 4 = 2^7^ Byte空间，第二层的数组最多占用2^5^× 2^14^× 4 = 2^21^ =2M。二层基数树相比一层基数树的好处就是，一层基数树必须一开始就把2 M的数组开辟出来，而二层基数树一开始时只需将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//二层基数树</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap2</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_BITS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                <span class="token comment">//第一层对应页号的前5个比特位</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> ROOT_BITS<span class="token punctuation">;</span> <span class="token comment">//第一层存储元素的个数</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> ROOT_BITS<span class="token punctuation">;</span> <span class="token comment">//第二层对应页号的其余比特位</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span> <span class="token comment">//第二层存储元素的个数</span>
	<span class="token comment">//第一层数组中存储的元素类型</span>
	<span class="token keyword">struct</span> <span class="token class-name">Leaf</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	Leaf<span class="token operator">*</span> root_<span class="token punctuation">[</span>ROOT_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第一层数组</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span>
	<span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>root_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将第一层的空间进行清理</span>
		<span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//直接将第二层全部开辟</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>        <span class="token comment">//第一层对应的下标</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//页号值不在范围或没有建立过映射</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回该页号对应span的指针</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>        <span class="token comment">//第一层对应的下标</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>i1 <span class="token operator">&lt;</span> ROOT_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">//建立该页号与对应span的映射</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//确保映射[start,start_n-1]页号的空间是开辟好了的</span>
	<span class="token keyword">bool</span> <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> ROOT_LENGTH<span class="token punctuation">)</span> <span class="token comment">//页号超出范围</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//第一层i1下标指向的空间未开辟</span>
			<span class="token punctuation">{</span>
				<span class="token comment">//开辟对应空间</span>
				<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Leaf<span class="token operator">&gt;</span> leafPool<span class="token punctuation">;</span>
				Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> <span class="token punctuation">(</span>Leaf<span class="token operator">*</span><span class="token punctuation">)</span>leafPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> leaf<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span> <span class="token comment">//继续后续检查</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">Ensure</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将第二层的空间全部开辟好</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此在二层基数树中有一个Ensure函数，当需要建立某一页号与其span之间的映射关系时，需要先调用该Ensure函数确保用于映射该页号的空间是开辟了的，如果没有开辟则会立即开辟。</p>
<p>而在32位平台下，就算将二层基数树第二层的数组全部开辟出来也就消耗了2 M 2M2M的空间，内存消耗也不算太多，因此我们可以在构造二层基数树时就把第二层的数组全部开辟出来。</p>
<h3 id="三层基数树"><a href="#三层基数树" class="headerlink" title="三层基数树"></a>三层基数树</h3><p>上面一层基数树和二层基数树都适用于32位平台，而对于64位的平台就需要用三层基数树了。三层基数树与二层基数树类似，三层基数树实际上就是把存储页号的若干比特位分为三次进行映射。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051446337.png" alt="image-20220905144659241"></p>
<p>此时只有当要建立某一页号的映射关系时，再开辟对应的数组空间，而没有建立映射的页号就可以不用开辟其对应的数组空间，此时就能在一定程度上节省内存空间。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//三层基数树</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap3</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_BITS <span class="token operator">=</span> <span class="token punctuation">(</span>BITS <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>       <span class="token comment">//第一、二层对应页号的比特位个数</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INTERIOR_BITS<span class="token punctuation">;</span> <span class="token comment">//第一、二层存储元素的个数</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> INTERIOR_BITS<span class="token punctuation">;</span> <span class="token comment">//第三层对应页号的比特位个数</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>         <span class="token comment">//第三层存储元素的个数</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span>
	<span class="token punctuation">{</span>
		Node<span class="token operator">*</span> ptrs<span class="token punctuation">[</span>INTERIOR_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">Leaf</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	Node<span class="token operator">*</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> nodePool<span class="token punctuation">;</span>
		Node<span class="token operator">*</span> result <span class="token operator">=</span> nodePool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token function">memset</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	Node<span class="token operator">*</span> root_<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span>
	<span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		root_ <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//第一层对应的下标</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span>
		<span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//第三层对应的下标</span>
		<span class="token comment">//页号超出范围，或映射该页号的空间未开辟</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回该页号对应span的指针</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//第一层对应的下标</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span>
		<span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//第三层对应的下标</span>
		<span class="token function">Ensure</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//确保映射第k页页号的空间是开辟好了的</span>
		<span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">//建立该页号与对应span的映射</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//确保映射[start,start+n-1]页号的空间是开辟好了的</span>
	<span class="token keyword">bool</span> <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//第一层对应的下标</span>
			<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> INTERIOR_LENGTH <span class="token operator">||</span> i2 <span class="token operator">&gt;=</span> INTERIOR_LENGTH<span class="token punctuation">)</span> <span class="token comment">//下标值超出范围</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//第一层i1下标指向的空间未开辟</span>
			<span class="token punctuation">{</span>
				<span class="token comment">//开辟对应空间</span>
				Node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//第二层i2下标指向的空间未开辟</span>
			<span class="token punctuation">{</span>
				<span class="token comment">//开辟对应空间</span>
				<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Leaf<span class="token operator">&gt;</span> leafPool<span class="token punctuation">;</span>
				Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> leafPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>leaf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>leaf<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span> <span class="token comment">//继续后续检查</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此当我们要建立某一页号的映射关系时，需要先确保存储该页映射的数组空间是开辟好了的，也就是调用代码中的Ensure函数，如果对应数组空间未开辟则会立马开辟对应的空间。</p>
<h2 id="基数树优化"><a href="#基数树优化" class="headerlink" title="基数树优化"></a>基数树优化</h2><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p>现在我们用基数树对代码进行优化，此时将PageCache类当中的unorder_map用基数树进行替换即可，由于当前是32位平台，因此这里随便用几层基数树都可以。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单例模式</span>
<span class="token keyword">class</span> <span class="token class-name">PageCache</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">//std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;</span>
	TCMalloc_PageMap1<span class="token operator">&lt;</span><span class="token number">32</span> <span class="token operator">-</span> PAGE_SHIFT<span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时当我们需要建立页号与span的映射时，就调用基数树当中的set函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 而当我们需要读取某一页号对应的span时，就调用基数树当中的get函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>并且现在PageCache类向外提供的，用于读取映射关系的MapObjectToSpan函数内部就不需要加锁了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取从对象到span的映射</span>
Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span> <span class="token comment">//页号</span>
	Span<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="为什么读取基数树映射关系时不需要加锁？"><a href="#为什么读取基数树映射关系时不需要加锁？" class="headerlink" title="为什么读取基数树映射关系时不需要加锁？"></a>为什么读取基数树映射关系时不需要加锁？</h3><p>当某个线程在读取映射关系时，可能另外一个线程正在建立其他页号的映射关系，而此时无论我们用的是C++当中的map还是<code>unordered_map</code>，在读取映射关系时都是需要加锁的。</p>
<p>因为C++中map的底层数据结构是红黑树，<code>unordered_map</code>的底层数据结构是哈希表，而无论是红黑树还是哈希表，当我们在插入数据时其底层的结构都有可能会发生变化。比如红黑树在插入数据时可能会引起树的旋转，而哈希表在插入数据时可能会引起哈希表扩容。此时要避免出现数据不一致的问题，就不能让插入操作和读取操作同时进行，因此我们在读取映射关系的时候是需要加锁的。</p>
<p>而对于基数树来说就不一样了，基数树的空间一旦开辟好了就不会发生变化，因此无论什么时候去读取某个页的映射，都是对应在一个固定的位置进行读取的。并且我们不会同时对同一个页进行读取映射和建立映射的操作，因为我们只有在释放对象时才需要读取映射，而建立映射的操作都是在page cache进行的。也就是说，读取映射时读取的都是对应span的<code>_useCount</code>不等于0的页，而建立映射时建立的都是对应span的<code>_useCount</code>等于0的页，所以说我们不会同时对同一个页进行读取映射和建立映射的操作。</p>
<h2 id="再次对比malloc进行测试"><a href="#再次对比malloc进行测试" class="headerlink" title="再次对比malloc进行测试"></a>再次对比malloc进行测试</h2><p>还是同样的代码，只不过我们用基数树对代码进行了优化，这时测试固定大小内存的申请和释放的结果如下：</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051613138.png" alt="image-20220905161327059"></p>
<p>可以看到，这时就算申请释放的是固定大小的对象，其效率还是不太行</p>
<p>下面在申请释放不同大小的对象时，由于central cache的桶锁起作用了，其效率更是变成了malloc的好几倍。</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051610479.png" alt="image-20220905161032404"></p>
<p>这肯定还是不对的，所以查找一下原因试试看</p>
<p>首先看看锁的问题，应该是比较容易看出来的</p>
<p>下面性能分析发现Free和Alloc都是很慢的，说明肯定是alloc的时候有问题，导致了整体的时候慢下来了</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051930134.png" alt="image-20220905193025051"></p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051926113.png" alt="image-20220905192641730"></p>
<p>这导致了慢开始算法出错，每次都让第一个桶增长，而不会影响其他的桶</p>
<p>这次可以了</p>
<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051931940.png" alt="image-20220905193156857"></p>
<h2 id="打包成动静态库"><a href="#打包成动静态库" class="headerlink" title="打包成动静态库"></a>打包成动静态库</h2><p>实际Google开源的tcmalloc是会直接用于替换malloc的，不同平台替换的方式不同。比如基于Unix的系统上的glibc，使用了weak alias的方式替换；而对于某些其他平台，需要使用hook的钩子技术来做。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> THROW <span class="token function">attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span> <span class="token punctuation">(</span>tc_malloc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>于我们当前实现的项目，可以考虑将其打包成静态库或动态库。我们先右击解决方案资源管理器当中的项目名称，然后选择属性。</p>
<p>以上的所有代码，均已经提交到了Github中，可以参考<a target="_blank" rel="noopener" href="https://github.com/Allen9012/ConcurrentMemoryPool">https://github.com/Allen9012/ConcurrentMemoryPool</a></p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/persistentsnail/p/3442185.html">https://www.cnblogs.com/persistentsnail/p/3442185.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29216091">https://zhuanlan.zhihu.com/p/29216091</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenlong_cxy/article/details/122819562?spm=1001.2014.3001.5502">https://blog.csdn.net/chenlong_cxy/article/details/122819562?spm=1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384022573">一文了解，Linux内存管理，malloc、free 实现原理</a></p>
<p><a target="_blank" rel="noopener" href="http://azhao.net/index.php/archives/81/">malloc()背后的实现原理——内存池</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/z_ryan/article/details/79950737">malloc的底层实现（ptmalloc）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xixixing/p/16049270.html">C++中出现_CrtlsValidHeapPointer(block)错误</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/BlogNet/about" rel="external nofollow noreferrer">Allen</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://allen9012.github.io/BlogNet/BlogNet/2022/08/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">https://allen9012.github.io/BlogNet/BlogNet/2022/08/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/BlogNet/about" target="_blank">Allen</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/BlogNet/tags/%E9%A1%B9%E7%9B%AE/">
                                    <span class="chip bg-color">项目</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/BlogNet/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/BlogNet/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/BlogNet/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/BlogNet/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/BlogNet/2022/08/25/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="/BlogNet/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-08-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Allen
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/BlogNet/2022/08/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">
                    <div class="card-image">
                        
                        
                        <img src="/BlogNet/medias/featureimages/14.jpg" class="responsive-img" alt="高并发内存池">
                        
                        <span class="card-title">高并发内存池</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Allen
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/BlogNet/tags/%E9%A1%B9%E7%9B%AE/">
                        <span class="chip bg-color">项目</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/BlogNet/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/BlogNet/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/BlogNet/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/BlogNet/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/BlogNet/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/BlogNet/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/BlogNet/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/BlogNet/about" target="_blank">Allen</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/BlogNet/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/BlogNet/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/BlogNet/libs/materialize/materialize.min.js"></script>
    <script src="/BlogNet/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/BlogNet/libs/aos/aos.js"></script>
    <script src="/BlogNet/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/BlogNet/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/BlogNet/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/BlogNet/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/BlogNet/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/BlogNet/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
