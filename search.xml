<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Red-Black Tree</title>
      <link href="/BlogNet/2022/09/03/Red-Black-Tree/"/>
      <url>/BlogNet/2022/09/03/Red-Black-Tree/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205040918814.jpg" alt="BingWallpaper27"></p><p>[toc]</p><h1 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h1><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205200902972.png" alt="image-20220520090154798"></p><h2 id="0-Intro"><a href="#0-Intro" class="headerlink" title="0.Intro"></a>0.Intro</h2><p><strong>红黑树</strong>是一种自平衡二叉搜索树。每个节点存储一个表示“颜色”（“红色”或“黑色”）的额外位，用于确保树在插入和删除期间保持平衡。当树被修改时，新树被重新排列并“重新绘制”以恢复限制树在最坏情况下可能变得多么不平衡的着色属性。这些属性被设计成可以有效地执行这种重新排列和重新着色。</p><blockquote><p>From <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</a></p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205042105325.png" alt="image-20220504210510276"></p><h2 id="1-Red-Black-Tree"><a href="#1-Red-Black-Tree" class="headerlink" title="1. Red-Black Tree"></a>1. Red-Black Tree</h2><p>通过对任何一条从根到叶子的路径上各个结点着色方式的限制，==红黑树确保没有一条路径会比其他路径长出两倍==，因而是接近平衡的。接近平衡其实比平衡更好一点，因为相对平衡对于计算机来说实际上差别不大（对计算机来说其实logN和2logN差别不是很大），但是严格平衡是通过不断旋转来提高效率的，基于这样的原因，红黑树效率不必AVL差，但是反而旋转更少，因此总体效率更优，因此现在使用红黑树更多一点，而不是AVL树</p><h3 id="1-1-红黑树的性质"><a href="#1-1-红黑树的性质" class="headerlink" title="1.1  红黑树的性质"></a>1.1  红黑树的性质</h3><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 每个结点不是红色就是黑色<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 根节点是黑色的<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果一个节点是红色的，则它的两个孩子结点是黑色的(<strong>没有连续的红色节点</strong>)<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<strong>每条路上包含相同数量黑色节点</strong>）</p><p>每个叶子结点都是黑色的(==此处的叶子结点指的是空结点/NIL==)</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051231892.png" alt="image-20220505123105834"></p><h3 id="1-2-红黑树推论"><a href="#1-2-红黑树推论" class="headerlink" title="1.2 红黑树推论"></a>1.2 红黑树推论</h3><p><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 路径：<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最短路径：全部由黑色节点构成<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最长路径：一黑一红，黑色节点数量等于红色节点<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 假设黑色节点有N个：<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最短路径长度：logN<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最长路径长度：2logN</p><h2 id="2-实现红黑树"><a href="#2-实现红黑树" class="headerlink" title="2. 实现红黑树"></a>2. 实现红黑树</h2><h3 id="2-0-红黑树节点结构"><a href="#2-0-红黑树节点结构" class="headerlink" title="2.0 红黑树节点结构"></a>2.0 红黑树节点结构</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    RED<span class="token punctuation">,</span>    BLACK<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">RBTreeNode</span><span class="token punctuation">{</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _left<span class="token punctuation">;</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _right<span class="token punctuation">;</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _parent<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>    Color _col<span class="token punctuation">;</span>    <span class="token function">RBTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token operator">&amp;</span>  kv<span class="token punctuation">)</span>    <span class="token operator">:</span><span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_col</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候我们有一个问题，为什么要将节点的默认颜色给成红色的？</p><p>黑的好还是红的好?</p><blockquote><p>插入红的会破坏规则：</p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果一个节点是红色的，则它的两个孩子结点是黑色的(<strong>没有连续的红色节点</strong>)</p><p>插入黑的会破坏规则：</p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<strong>每条路上包含相同数量黑色节点</strong>）</p></blockquote><p>我们选择消耗低的，还是插入默认红的比较好</p><h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert"></a>2.2 Insert</h3><h4 id="2-2-0-处理搜索部分"><a href="#2-2-0-处理搜索部分" class="headerlink" title="2.2.0 处理搜索部分"></a>2.2.0 处理搜索部分</h4><p>搜索树部分类似于AVL和BSTree的插入逻辑</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//空树</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token comment">//根必须是黑的</span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span><span class="token comment">//1. 找适当的空位置</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span><span class="token comment">//重复</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//2. cur走到空 可以链接</span>Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>newnode<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">{</span>    parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span>cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//处理</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>kv<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键是处理红黑节点</p><h4 id="2-2-1-处理红黑节点"><a href="#2-2-1-处理红黑节点" class="headerlink" title="2.2.1 处理红黑节点"></a>2.2.1 处理红黑节点</h4><p>因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不<br>需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三不能有连在一起的红色节点，此<br>时需要对红黑树分情况来讨论：</p><table><thead><tr><th>parent.color</th><th>条件</th><th>处理</th></tr></thead><tbody><tr><td>BLACK</td><td>不需要调整</td><td>插入完成</td></tr><tr><td>RED</td><td>违反规则3</td><td>需要处理</td></tr></tbody></table><p>如果parent节点是红的，那么就会出现多种情况，需要处理，情况1可以通变色处理，但是情况2+3则因为<strong>最长路径已经超过最短路径的两倍所以无法变色解决，需要旋转</strong></p><p>下面的图中我们约定:cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点</p><table><thead><tr><th>情况</th><th>cur</th><th>parent</th><th>grandparent</th><th>uncle</th><th>处理方案</th></tr></thead><tbody><tr><td>情况一：<br>叔叔存在且为红</td><td>RED</td><td>RED</td><td>BLACK</td><td>exist &amp;&amp; RED</td><td>pu变黑，g变红，继续往上走</td></tr><tr><td>情况二:<br>叔叔不存在或为黑（直线）</td><td>RED</td><td>RED</td><td>BLACK</td><td>!exist || <br>exist &amp;&amp; BLACK</td><td>单旋转+变色</td></tr><tr><td>情况三;<br>叔叔不存在或为黑（折线）</td><td>RED</td><td>RED</td><td>BLACK</td><td>!exist ||<br>exist &amp;&amp; BLACK</td><td>双旋转+变色</td></tr></tbody></table><h4 id="2-2-2-Situation1"><a href="#2-2-2-Situation1" class="headerlink" title="2.2.2 Situation1"></a>2.2.2 Situation1</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况一: cur为红，p为红，g为黑，u存在且为红</strong></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051325666.png" alt="image-20220505132556579"></p><table><thead><tr><th>具象图</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>g已经到顶了</td><td>pu变黑，g变红</td></tr><tr><td>具象图2：</td><td>符合具象图1但是修改完其他节点不符合</td><td>不断执行情况1，直到parent为空时，p存在且为黑，或者p不存在停止（把根变黑）</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051326419.png" alt="image-20220505132610350"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051351735.png" alt="image-20220505135120634"></p><h4 id="2-2-3-Situation2"><a href="#2-2-3-Situation2" class="headerlink" title="2.2.3 Situation2"></a>2.2.3 Situation2</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况二: cur为红，p为红，g为黑，u不存在/u为黑</strong><br>情况二中，无非是还会出现一种情况是左旋，但是说到底都是单旋转中的一种,关键在于</p><table><thead><tr><th>parent/grandparent/cur关系</th><th>旋转操作</th><th>变色操作</th></tr></thead><tbody><tr><td>p为g的左孩子，cur为p的左孩子</td><td>右单旋转</td><td>p、g变色–p变黑，g变红</td></tr><tr><td>p为g的右孩子，cur为p的右孩子</td><td>左单旋转</td><td>p、g变色–p变黑，g变红</td></tr></tbody></table><p><font><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 为什么不能直接染色?</font></p><p>看到下图可能会有一些疑问：为什么我不能把p变黑，g变红，简单来就可以了，还要搞什么旋转呢？这是因为首先原来插入之前是一棵红黑树，那么右路如果有uncle就是需要整一条右路上要两个黑节点才能满足规则五，如果没有uncle节点就要满足至少有一个黑，所以说如果直接改变颜色，那么会导致要么右路只有一个黑节点，要么就是右路干脆没有黑节点，所以说一定要采取旋转方式，才能满足规则五</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061006661.png"></p><table><thead><tr><th>具象图（以右单旋为例）</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>`uncle  !exist</td><td></td></tr><tr><td>具象图2：</td><td>符合情况一且处理之后产生情况二</td><td>处理情况一+右单旋+p变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205060953867.png" alt="image-20220506095327691"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061035548.png" alt="image-20220506103556352"></p><h4 id="2-2-4-Situation3"><a href="#2-2-4-Situation3" class="headerlink" title="2.2.4 Situation3"></a>2.2.4 Situation3</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况三: cur为红，p为红，g为黑，u不存在/u为黑</strong></p><p>情况三看上去好像和情况二很像，其实差别在于情况三的结构，同时他是一个双旋</p><table><thead><tr><th>parent/grandparent/cur关系</th><th>旋转操作1</th><th>旋转操作2</th><th>变色操作</th></tr></thead><tbody><tr><td>p为g的左孩子，cur为p的右孩子</td><td>左单旋转</td><td>右单旋转</td><td>cur、g变色–cur变黑，g变红</td></tr><tr><td>p为g的右孩子，cur为p的左孩子</td><td>右单旋转</td><td>左单旋转</td><td>cur、g变色–cur变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205071403059.png" alt="image-20220507140351911"></p><table><thead><tr><th>具象图（以右单旋为例）</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>`uncle  !exist</td><td></td></tr><tr><td>具象图2：</td><td>符合情况一且处理之后产生情况三</td><td>处理情况一+左单旋+右单旋+cur变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061039461.png" alt="image-20220506103931331"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061104810.png" alt="image-20220506110459705"></p><h4 id="2-2-5-分类讨论总结"><a href="#2-2-5-分类讨论总结" class="headerlink" title="2.2.5 分类讨论总结"></a>2.2.5 分类讨论总结</h4><p>插入一个新节点，新节点必是红的</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205072102026.png" alt="image-20220507210143404"></p><h4 id="2-2-6-实现插入"><a href="#2-2-6-实现插入" class="headerlink" title="2.2.6 实现插入"></a>2.2.6 实现插入</h4><h5 id="2-2-6-1-插入本体"><a href="#2-2-6-1-插入本体" class="headerlink" title="2.2.6.1 插入本体"></a>2.2.6.1 插入本体</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//插入</span>pair<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//空树</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token comment">//根必须是黑的</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token comment">//1. 找适当的空位置</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&gt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span><span class="token comment">//重复</span>            <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//2. cur走到空 可以链接</span>    Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>        newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>        newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    <span class="token comment">//3.判断处理条件</span>    <span class="token comment">//如果父亲存在，且颜色为红色就需要处理</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//抓住叔叔是关键</span>        Node<span class="token operator">*</span> grandfather <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>    <span class="token comment">//a. 首先父亲在祖父左边的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">==</span>grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Node<span class="token operator">*</span> uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>            <span class="token comment">//情况1：uncle 存在且为红</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">==</span>RED<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token comment">//继续往上处理</span>                cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>                parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//情况2+3 uncle不存在或者uncle存在且为黑</span>            <span class="token keyword">else</span><span class="token comment">//此时变色无法处理</span>            <span class="token punctuation">{</span>                <span class="token comment">//情况2：单旋</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">==</span>parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>                <span class="token punctuation">{</span>   <span class="token comment">//1. 右单旋</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//2. 变色</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                    parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span><span class="token comment">//情况3：双旋</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//根是黑的了，不会往上影响直接break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         <span class="token comment">//b. 首先父亲在祖父左边的情况</span>        <span class="token keyword">else</span><span class="token comment">//parent == grandfather-&gt;_right</span>        <span class="token punctuation">{</span>            Node<span class="token operator">*</span> uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>            <span class="token comment">//情况1：uncle 存在且为红 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                uncle<span class="token operator">-&gt;</span>_col<span class="token operator">=</span>parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token comment">//继续往上递归</span>                cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>                parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span><span class="token comment">//这个肯定有父亲</span>            <span class="token punctuation">}</span>             <span class="token comment">//情况 2+3： uncle不存在或为黑</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_right<span class="token operator">==</span>cur<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//默认修改根节点为黑色</span>    _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>newnode<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-6-2-旋转函数"><a href="#2-2-6-2-旋转函数" class="headerlink" title="2.2.6.2 旋转函数"></a>2.2.6.2 旋转函数</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> subL <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>Node<span class="token operator">*</span> subLR <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span><span class="token comment">//1.旋转</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subLR<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>subLR<span class="token punctuation">)</span><span class="token punctuation">{</span>subLR<span class="token operator">-&gt;</span>_parent<span class="token operator">=</span>parent<span class="token punctuation">;</span><span class="token punctuation">}</span>subL<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> parent<span class="token punctuation">;</span>Node<span class="token operator">*</span> grandparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span><span class="token comment">//记录爷爷</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subL<span class="token punctuation">;</span><span class="token comment">//2. 修改父子关系</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> _root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//原来的父亲做了根节点</span>_root <span class="token operator">=</span> subL<span class="token punctuation">;</span>_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//修改爷爷和父亲链接</span><span class="token keyword">if</span> <span class="token punctuation">(</span>grandparent<span class="token operator">-&gt;</span>_left<span class="token operator">==</span>parent<span class="token punctuation">)</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subL<span class="token punctuation">;</span><span class="token keyword">else</span>grandparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subL<span class="token punctuation">;</span>subL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> grandparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> subR <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>Node<span class="token operator">*</span> subRL <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span><span class="token comment">//1. 旋转</span>parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subRL<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>subRL<span class="token punctuation">)</span><span class="token punctuation">{</span>subRL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span>subR<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> parent<span class="token punctuation">;</span>Node<span class="token operator">*</span> grandparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subR<span class="token punctuation">;</span><span class="token comment">//2. 修改父子关系</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>_root <span class="token operator">=</span> subR<span class="token punctuation">;</span>_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> parent<span class="token punctuation">)</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subR<span class="token punctuation">;</span><span class="token keyword">else</span>grandparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subR<span class="token punctuation">;</span>subR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> grandparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-Erase"><a href="#2-3-Erase" class="headerlink" title="2.3 Erase"></a>2.3 Erase</h3><p>和AVL树类似，红黑树的删除只谈谈思想</p><ul><li>删除节点一定是左为空或者右为空，然后让父亲链接自己的孩子<ul><li><p>删除的是红色节点，直接就没有什么问题</p></li><li><p>删除的是黑色节点，可能导致连续的红节点，或者一条路径上少了一个黑节点</p><ul><li><p>后继还有红节点，变色成黑的</p></li><li><p>后继没有红节点可能还要旋转</p></li></ul></li></ul></li></ul><p>具体有很多种情况可以参照<a href="https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html">https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html</a></p><h3 id="2-4-Find"><a href="#2-4-Find" class="headerlink" title="2.4 Find"></a>2.4 Find</h3><p>和搜索树如出一辙</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Node<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&gt;</span>key<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>key<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-析构函数"><a href="#2-5-析构函数" class="headerlink" title="2.5 析构函数"></a>2.5 析构函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_Destroy</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//析构</span><span class="token operator">~</span><span class="token function">AVLTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>    _root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-拷贝构造和赋值运算符"><a href="#2-6-拷贝构造和赋值运算符" class="headerlink" title="2.6 拷贝构造和赋值运算符"></a>2.6 拷贝构造和赋值运算符</h3><p>可以参考搜索二叉树，和之前的如出一辙</p><p><a href="https://blog.csdn.net/Allen9012/article/details/124435568">https://blog.csdn.net/Allen9012/article/details/124435568</a></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205071453328.png" alt="image-20220507145354216"></p><h3 id="2-7-CheckBalance"><a href="#2-7-CheckBalance" class="headerlink" title="2.7 CheckBalance"></a>2.7 CheckBalance</h3><p>我们需要写一个树来查一下我们的插入操作正不正确，是否插入形成了一个红黑树</p><p>为了验证是否是红黑树，我们还是利用几点原则</p><h4 id="2-7-1-黑色的根"><a href="#2-7-1-黑色的根" class="headerlink" title="2.7.1 黑色的根"></a>2.7.1 黑色的根</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//1.黑根</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"root是红色"</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-没有连续的红色节点"><a href="#2-7-2-没有连续的红色节点" class="headerlink" title="2.7.2 没有连续的红色节点"></a>2.7.2 没有连续的红色节点</h4><p>方法就是遍历，然后找到红色节点，去查找父亲是不是红色节点，如果是红色就返回false</p><h4 id="2-7-3-每条路径上的黑色节点数量相等"><a href="#2-7-3-每条路径上的黑色节点数量相等" class="headerlink" title="2.7.3 每条路径上的黑色节点数量相等"></a>2.7.3 每条路径上的黑色节点数量相等</h4><p>前序遍历，从根节点走到每一个NIL节点，只要是黑色就count++，如果走到了NIL节点就return，然后此时上一层栈帧的++不影响其他层的count，于是可以实现</p><ol><li>用一个vector去记录每个路径的黑色接点数量，如果最后都是相等的，那么就是说明是红黑树</li><li>不想要走完每条路线才最后比较，可不可以找一条路径作为标准，只要其他路和这条路线不相等就说明不是红黑树，可以找最左路径做黑色节点的参考值<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>Node<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> black_num<span class="token punctuation">,</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> black_num<span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token comment">//3.路径黑节点数相等</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"路径上黑色节点的数量不相等"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2.遍历红节点，查父亲是不是红的，不要查孩子因为孩子可能没有</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED <span class="token operator">&amp;&amp;</span> root<span class="token operator">-&gt;</span>_parent<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"存在连续的红色节点"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>BLACK<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span>  <span class="token function">CheckBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//1.黑根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"root是红色"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2. 每条路径走到NIL节点，遇到黑++，找最左路径做黑色节点的参考值</span>    <span class="token keyword">int</span> black_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> left <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>BLACK<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            black_num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        left <span class="token operator">=</span> left<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//count计算该条路的值</span>    <span class="token comment">//3. 用子函数来递归遍历</span>    <span class="token keyword">return</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="3-红黑树-V-S-AVL树"><a href="#3-红黑树-V-S-AVL树" class="headerlink" title="3. 红黑树 V.S. AVL树"></a>3. 红黑树 V.S. AVL树</h2><p>红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是<br>$$<br>O(log_2N)<br>$$</p><p>，红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。</p><h2 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h2><ol><li>C++ STL库 – map/set、mutil_map/mutil_set</li><li>Java 库</li><li>linux内核</li><li>其他一些库</li></ol><p>相关代码放在了我的GitHub仓库<a href="https://github.com/Allen9012/cpp/tree/main/C++%E8%BF%9B%E9%98%B6/RBTree">https://github.com/Allen9012/cpp/tree/main/C%2B%2B%E8%BF%9B%E9%98%B6/RBTree</a></p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h3 id="关于AVL树和红黑树的区别说法不正确的是（）"><a href="#关于AVL树和红黑树的区别说法不正确的是（）" class="headerlink" title="关于AVL树和红黑树的区别说法不正确的是（）"></a>关于AVL树和红黑树的区别说法不正确的是（）</h3><p>A.AVL树和红黑树保证平衡性的方式不同</p><p>B.AVL树和红黑树都是平衡树，因此查找的时间复杂度都是O(log_2N)</p><p>C.AVL树和红黑树的性质遭到破坏时，都需要进行旋转</p><p>D.AVL树和红黑树中序遍历都可以得到有序序列，因为它们都是二叉搜索树</p><blockquote><p> A：正确，AVL树通过节点的平衡因子保证，红黑树通过节点的颜色以及红黑树的特性保证</p><p> B：正确，AVL树是严格平衡的，红黑树虽然是近似平衡，但其性能往往比AVL树好，而且实现简 单，因此他们的查找  效率都是O(logN)</p><p> C：错误，AVL树是一定需要旋转，红黑树不一定，红黑树有时只需要改变节点的颜色即可</p><p> D：正确，参考概念</p><p> 因此：选择C</p></blockquote><h3 id="关于红黑树以下说法正确的是（）"><a href="#关于红黑树以下说法正确的是（）" class="headerlink" title="关于红黑树以下说法正确的是（）"></a>关于红黑树以下说法正确的是（）</h3><p>A.空树不是红黑树，因为红黑树要求根节点必须为黑色，而空树中没有根节点</p><p>B.红黑树也是二叉搜索树，因此其按照前序遍历可以得到有序序列</p><p>C.红黑树是一棵真正平衡的二叉树</p><p>D.红黑树最长路径中节点个数可能会等于最短路径中节点个数的两倍</p><blockquote><p> A：错误，空树也是红黑树，性质5中规定树中的空指针域为叶子节点，因此空树也是有节点的</p><p> B：错误，红黑树也是二叉搜索树，按照中序遍历才可以得到有序序列</p><p> C：红黑树不像AVL树那么严格，是一棵近似平衡的二叉搜索树</p><p> D：正确，比如红黑树中只有两个节点</p><p> 因此：选择D</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 高阶数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/BlogNet/2022/08/25/hello-world/"/>
      <url>/BlogNet/2022/08/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Allen’s Blog! This is your very first post. you can ask me on <a href="https://github.com/Allen9012">GitHub</a>.</p><p>Following is my blog on <a href="https://blog.csdn.net/Allen9012?spm=1000.2115.3001.5343">CSDN</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
