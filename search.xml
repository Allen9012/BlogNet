<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hash 容器</title>
      <link href="/BlogNet/2022/09/04/Hash-%E5%AE%B9%E5%99%A8/"/>
      <url>/BlogNet/2022/09/04/Hash-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091927697.jpg" alt="BingWallpaper29"></p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>[toc]</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205302000044.png" alt="image-20220530200053766"></p><h2 id="1-unordered系列关联式容器"><a href="#1-unordered系列关联式容器" class="headerlink" title="1. unordered系列关联式容器"></a>1. unordered系列关联式容器</h2><p>在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到logN，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091242639.png" alt="image-20220509124203576"></p><p>同样的容器在Java中就很接地气</p><table><thead><tr><th>c++</th><th>Java</th></tr></thead><tbody><tr><td>map</td><td>TreeMap</td></tr><tr><td>set</td><td>TreeSet</td></tr><tr><td>unordered_map</td><td>HashMap</td></tr><tr><td>unordered_set</td><td>HashSet</td></tr></tbody></table><h2 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2. unordered_map"></a>2. unordered_map</h2><h3 id="2-1-unordered-map快速入门"><a href="#2-1-unordered-map快速入门" class="headerlink" title="2.1 unordered_map快速入门"></a>2.1 unordered_map快速入门</h3><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091934716.png" alt="image-20220509193444666"></p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> unordered_map是存储<key, value="">键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。</key,><br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在内部,unordered_map没有对<kye, value="">按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。</kye,><br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> unordered_maps实现了直接访问操作符<code>(operator[])</code>，它允许使用key作为参数直接访问value。<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 它的迭代器至少是前向接口迭代器。</p><h3 id="2-2-unordered-map常用接口"><a href="#2-2-unordered-map常用接口" class="headerlink" title="2.2 unordered_map常用接口"></a>2.2 unordered_map常用接口</h3><p>哈希表的话其实和map和set的诸多接口都是类似的</p><h4 id="2-2-1-unordered-map"><a href="#2-2-1-unordered-map" class="headerlink" title="2.2.1 unordered_map()"></a>2.2.1 unordered_map()</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>unordered_map()</td><td>构造不同格式的unordered_map对象</td></tr></tbody></table><h4 id="2-2-2-unordered-map-capacity"><a href="#2-2-2-unordered-map-capacity" class="headerlink" title="2.2.2 unordered_map capacity"></a>2.2.2 unordered_map capacity</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>bool empty() const</td><td>检测unordered_map是否为空</td></tr><tr><td>size_t size() const</td><td>获取unordered_map的有效元素个数</td></tr></tbody></table><h4 id="2-2-3-unordered-map-iterator"><a href="#2-2-3-unordered-map-iterator" class="headerlink" title="2.2.3 unordered_map:: iterator"></a>2.2.3 unordered_map:: iterator</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>begin</td><td>返回unordered_map第一个元素的迭代器</td></tr><tr><td>end</td><td>返回unordered_map最后一个元素下一个位置的迭代器</td></tr><tr><td>cbegin</td><td>返回unordered_map第一个元素的const迭代器</td></tr><tr><td>cend</td><td>返回unordered_map最后一个元素下一个位置的const迭代器</td></tr></tbody></table><p>所有的容器使用迭代器遍历的时候都是类似的方式</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>范围for也是一样的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> us<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-element元素访问"><a href="#2-2-4-element元素访问" class="headerlink" title="2.2.4 element元素访问"></a>2.2.4 element元素访问</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>operator[]</td><td>返回与key对应的value，没有一个默认值</td></tr></tbody></table><p>该函数中实际调用哈希桶的插入操作，用参数key与V()构造一个默认值往底层哈希桶中插入，如<br>果key不在哈希桶中，插入成功，返回V()，插入失败，说明key已经在哈希桶中，将key对应的value返回。</p><h4 id="2-2-5-Element-lookup"><a href="#2-2-5-Element-lookup" class="headerlink" title="2.2.5 Element lookup"></a>2.2.5 Element lookup</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>iterator find(const K&amp; key)</td><td>返回key在哈希桶中的位置</td></tr><tr><td>size_t count(const K&amp; key)</td><td>返回哈希桶中关键码为key的键值对的个数</td></tr></tbody></table><p>由于unordered_map中key是不能重复的，因此count函数的返回值最大为1</p><h5 id="herb-find"><a href="#herb-find" class="headerlink" title=":herb:find"></a><span class="github-emoji"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>find</h5><p>其实我们的查找是由两种方法的</p><p><span class="github-emoji"><span>🌸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f338.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果是哈希表的专有查找</p><p>优点是：利用率hash特性，效率很高– O(1)</p><p><span class="github-emoji"><span>🌸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f338.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果是使用通用算法（来自于<code>&lt;algorithm&gt;</code>）</p><p>优点：每个容器都可以使用，泛型算法。 缺点：暴力查找  – O(N)</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>p.s. 如果使用的不是hash的而是普通的set的话，那么红黑树查找效率是O(logN)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// unordered_set专用查找算法。优点：使用哈希特性去查找，效率高 -- O(1)  </span><span class="token comment">// 类似如果是set的，效率是O(logN)</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通用算法，优点：每个容器都可以使用，泛型算法。 缺点：暴力查找  -- O(N)</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>us<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"找到了"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"找不到"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-6-Modifiers"><a href="#2-2-6-Modifiers" class="headerlink" title="2.2.6 Modifiers"></a>2.2.6 Modifiers</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/insert/"><strong>insert</strong></a></td><td>Insert elements (public member function )</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/erase/"><strong>erase</strong></a></td><td>Erase elements (public member function )</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/clear/"><strong>clear</strong></a></td><td>Clear content (public member function )</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/swap/"><strong>swap</strong></a></td><td>Swap content (public member function)</td></tr></tbody></table><h4 id="2-2-7-Buckets"><a href="#2-2-7-Buckets" class="headerlink" title="2.2.7 Buckets"></a>2.2.7 Buckets</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>size_t <strong>bucket_count</strong>()const</td><td>返回哈希桶中桶的总个数</td></tr><tr><td>size_t <strong>bucket_size</strong>(size_t n)const</td><td>返回n号桶中有效元素的总个数</td></tr><tr><td>size_t <strong>bucket</strong>(const K&amp; key)</td><td>返回元素key所在的桶号</td></tr><tr><td>size_t <strong>max_bucket_count()</strong> const</td><td>返回潜在可拥有的最大桶数</td></tr></tbody></table><h4 id="2-2-8-Hash-policy"><a href="#2-2-8-Hash-policy" class="headerlink" title="2.2.8 Hash policy"></a>2.2.8 Hash policy</h4><table><thead><tr><th><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/load_factor/"><strong>load_factor</strong></a></th><th>当前负载因子</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/max_load_factor/"><strong>max_load_factor</strong></a></td><td>容器的当前最大负载因子</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/rehash/"><strong>rehash</strong></a></td><td>相当于reserve，预留空间，将容器中的桶数设置为<em>n</em>或更多</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/reserve/"><strong>reserve</strong></a></td><td>将容器中的桶数设置为最适合包含至少n 个元素的桶数</td></tr></tbody></table><h2 id="3-unordered-set"><a href="#3-unordered-set" class="headerlink" title="3. unordered_set"></a>3. unordered_set</h2><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205092007265.png" alt="image-20220509200751201"></p><p>类似结合set和unordered_map</p><h2 id="4-unordered-V-S-ordered"><a href="#4-unordered-V-S-ordered" class="headerlink" title="4. unordered V.S. ordered"></a>4. unordered V.S. ordered</h2><p>下面通过一段代码，来演示一下差别</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> us<span class="token punctuation">;</span>    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>    size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"set insert:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_set insert:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    size_t begin3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t begin4 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end4 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"set find:"</span> <span class="token operator">&lt;&lt;</span> end3 <span class="token operator">-</span> begin3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_set find:"</span> <span class="token operator">&lt;&lt;</span> end4 <span class="token operator">-</span> begin4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    size_t begin5 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end5 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t begin6 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end6 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"set erase:"</span> <span class="token operator">&lt;&lt;</span> end5 <span class="token operator">-</span> begin5 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_set erase:"</span> <span class="token operator">&lt;&lt;</span> end6 <span class="token operator">-</span> begin6 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205101919853.png" alt="image-20220510191942796"></p><p>可见unordered_map的效率是显著的高的</p><h2 id="Hash底层"><a href="#Hash底层" class="headerlink" title="Hash底层"></a>Hash底层</h2><p>unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。Hash结构其实又可以叫散列结构，本质上是一种建立映射，计数排序中可以说就是用到了哈希</p><p>Hash是一种数学函数，可将任意长度的输入转换为固定长度的加密输出。因此，无论所涉及的原始数据量或文件大小如何，其唯一的哈希值始终是相同的大小。此外，散列不能用于“逆向工程”来自散列输出的输入，因为散列函数是“单向”的（就像绞肉机；你不能把碎牛肉放回牛排中）。尽管如此，如果您对相同的数据使用这样的函数，它的哈希值将是相同的，因此如果您已经知道它的哈希值，您可以验证数据是否相同（即未更改）。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205112014478.png" alt="image-20220511201434374"></p><h3 id="Intro-of-Hash"><a href="#Intro-of-Hash" class="headerlink" title="Intro of Hash"></a>Intro of Hash</h3><h4 id="非哈希"><a href="#非哈希" class="headerlink" title="非哈希"></a>非哈希</h4><p><strong>顺序结构以及平衡树</strong>中，元素关键码与其存储位置之间没有对应的关系，因此**在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(logN)**，搜索的效率取决于搜索过程中元素的比较次数。</p><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。</p><p><span class="github-emoji"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 插入元素<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放<br><span class="github-emoji"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 搜索元素<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功</p><p><span alt="modern">该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)</span></p><h3 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h3><p>引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则：<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哈希函数计算出来的地址能均匀分布在整个空间中<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哈希函数应该比较简单</p><h4 id="直接定址法-常用"><a href="#直接定址法-常用" class="headerlink" title="直接定址法(常用)"></a>直接定址法(常用)</h4><p>取关键字的某个线性函数为散列地址：<br>$$<br>Hash(Key)= A*Key + B<br>$$</p><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 优点：简单、均匀 ，速度快O(1)</p><p><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 缺点：需要事先知道关键字的分布情况， 不能处理浮点数，字符串等等，如果给定一个很大范围，会浪费很多空间</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：适合查找比较小且连续的情况，只能是整数，而且数据范围比较集中 </p><h4 id="除留余数法-常用"><a href="#除留余数法-常用" class="headerlink" title="除留余数法(常用)"></a>除留余数法(常用)</h4><p>设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：<br>$$<br>Hash(key) = key\  %\ p   \ (p&lt;=m)<br>$$<br>将关键码转换成哈希地址</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205102204698.png" alt="image-20220510220448631"></p><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 优点：数据范围可以很大，使用场景一下子广起来了</p><p><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 缺点：不同的值会映射到同一个位置上：哈希冲突，冲突越多，效率下降越厉害</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：数据范围很大</p><h4 id="平方取中法-少用"><a href="#平方取中法-少用" class="headerlink" title="平方取中法(少用)"></a>平方取中法(少用)</h4><p>假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；</p><p>再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 </p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：不知道关键字的分布，而位数又不是很大的情况</p><h4 id="折叠法-少用"><a href="#折叠法-少用" class="headerlink" title="折叠法(少用)"></a>折叠法(少用)</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加<br>求和，并按散列表表长，取后几位作为散列地址。</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：事先不需要知道关键字的分布，适合关键字位数比较多的情况</p><h4 id="随机数法-少用"><a href="#随机数法-少用" class="headerlink" title="随机数法(少用)"></a>随机数法(少用)</h4><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为<br>随机数函数。</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：通常应用于关键字长度不等时采用此法</p><h4 id="数学分析法-少用"><a href="#数学分析法-少用" class="headerlink" title="数学分析法(少用)"></a>数学分析法(少用)</h4><p>设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。</p><p>假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是 相同的，那么我<br>们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现 冲突，还可以对抽取出来的数字<br>进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移位、前两数与后两数叠加(如1234改<br>成12+34=46)等方法。<br><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布<br>较均匀的情况 </p><blockquote><p>哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</p></blockquote><h3 id="Hash-collision"><a href="#Hash-collision" class="headerlink" title="Hash collision"></a>Hash collision</h3><p>哈希冲突是哈希表中的两条数据共享相同的哈希值。 在这种情况下，哈希值来自一个哈希函数，该函数接受数据输入并返回固定长度的位。</p><p>尽管哈希算法的创建是为了防止冲突，但它们有时仍然可以将不同的数据映射到同一个哈希（根据<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">鸽巢原理</a>）。恶意用户可以利用这一点来模仿、访问或更改数据</p><p>对于两个数据元素的关键字k<sub>i</sub> 和k<sub>j</sub>和 (i != j)，有k<sub>i</sub> != k<sub>j</sub> ，但有：<br>$$<br>Hash(k_i) ==Hash(k_j)<br>$$<br>即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。<br>我们把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。</p><h2 id="Resolve-Hash-collisions"><a href="#Resolve-Hash-collisions" class="headerlink" title="Resolve Hash collisions"></a>Resolve Hash collisions</h2><p>解决哈希冲突两种常见的方法是：闭散列和开散列</p><p>当发生Collision时，Chaining会将所有被Hash Function分配到同一格slot的资料透过Linked list串起来，像是在书桌的抽屉下面绑绳子般，把所有被分配到同一格抽屉的物品都用绳子吊在抽屉下面。</p><p>相较于Chaining提供额外空间(node)来存放被分配到相同slot的资料，Open Addressing则是将每笔资料都放在书桌(Table)本身配备的抽屉(slot)，一格抽屉只能放一个物品，如果抽屉都满了，就得换张书桌(重新配置记忆体给新的Table)。</p><h3 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h3><p><strong>闭散列：也叫开放定址法，在开放空间内找一个位置定值，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。</strong></p><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>已知模出来映射的位置已经冲突，那线性探测的想法很简单，我们采用一个固定大小的哈希表，每次遇到哈希冲突时，我们以循环方式线性遍历该表以找到下一个空槽。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">0</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">2</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">4</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">5</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205110931435.png" alt="image-20220511093148389"></p><p>在这种情况下，我们的哈希函数可以被认为是：<br>$$<br>H(x, i) = (H(x) + i)%len<br>$$<br>其中 N 是表的大小，i 表示从 1 开始的线性递增变量（直到找到空桶）。</p><p>我们可以发现空间越大冲突的可能性会越小，然而，冲突还是会存在，没有被完全解决</p><h5 id="线性探测举例"><a href="#线性探测举例" class="headerlink" title="线性探测举例"></a>线性探测举例</h5><p>下面的哈希函数取得是：<br>$$<br>Hash(key) = key%len + i<br>$$<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205111006501.png" alt="image-20220511100608445"></p><h5 id="线性探测优缺点"><a href="#线性探测优缺点" class="headerlink" title="线性探测优缺点"></a>线性探测优缺点</h5><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 优点：实现非常简单<br><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 缺点：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即：不同关键码占据<br>了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降低。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题</p><p>这种方法处于高速缓存性能和集群问题的中间。总体思路保持不变，唯一的区别是我们在寻找空桶时查看每次迭代的 Q(i) 增量，其中 Q(i) 是 i 的某个二次表达式。Q 的一个简单表达式是 Q(i) = i^2^，在这种情况下，哈希函数看起来像这样：<br>$$<br>H(x, i) = (H(x) + i^2)%len<br>$$</p><h5 id="二次探测举例"><a href="#二次探测举例" class="headerlink" title="二次探测举例"></a>二次探测举例</h5><p>下面的哈希函数取得是：<br>$$<br>Hash(key)=key%len+i^2<br>$$<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205111004110.png" alt="image-20220511100437056"></p><blockquote><p>如果加太多超过了capacity，又会从头开始找，相当于再mod一下capacity</p></blockquote><h5 id="二次探测优缺点"><a href="#二次探测优缺点" class="headerlink" title="二次探测优缺点"></a>二次探测优缺点</h5><p>二次探测可以解决数据“堆积”</p><h3 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h3><p>开散列法又叫链地址法(开链法)，也可一叫做哈希桶首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205112015952.png" alt="image-20220511201501850"></p><p>本质上我们可以看出来，它就是一个指针数组 </p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>哈希表总是需要扩容的，这里就涉及到了负载因子</p><p><strong>负载因子/载荷因子=存储的有效个数/空间的大小</strong></p><p><span class="github-emoji"><span>#⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0023-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 负载因子越大，冲突的概率越高，增删改查的效率越低</p><p><span class="github-emoji"><span>#⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0023-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 负载因子越小，冲突的概率越高，增删改查的效率越高，但是空间的浪费越多，利用率越低</p><h5 id="闭散列-1"><a href="#闭散列-1" class="headerlink" title="闭散列"></a>闭散列</h5><blockquote><p>研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122052429.png" alt="image-20220512205202349"></p><h5 id="开散列-1"><a href="#开散列-1" class="headerlink" title="开散列"></a>开散列</h5><p>已知桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希表进行增容，那该条件怎么确认呢？<strong>开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容。</strong></p><blockquote><p>还是要控制一个负载因子，负载因子越小，冲突概率越低，效率越高，但是浪费的空间越多，反之冲突概率越高，效率越低</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122045951.png"></p><h4 id="素数优化"><a href="#素数优化" class="headerlink" title="素数优化"></a>素数优化</h4><p>有人说，除留余数法，最好模一个素数，这次不是直接扩容翻倍那么如何每次快速取一个类似两倍关系的素数，STL源码中给出了如下的操作，记录下了一些素数，就可以更好的解决冲突</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> PRIMECOUNT <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span><span class="token keyword">const</span> size_t primeList<span class="token punctuation">[</span>PRIMECOUNT<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token number">53ul</span><span class="token punctuation">,</span> <span class="token number">97ul</span><span class="token punctuation">,</span> <span class="token number">193ul</span><span class="token punctuation">,</span> <span class="token number">389ul</span><span class="token punctuation">,</span> <span class="token number">769ul</span><span class="token punctuation">,</span>    <span class="token number">1543ul</span><span class="token punctuation">,</span> <span class="token number">3079ul</span><span class="token punctuation">,</span> <span class="token number">6151ul</span><span class="token punctuation">,</span> <span class="token number">12289ul</span><span class="token punctuation">,</span> <span class="token number">24593ul</span><span class="token punctuation">,</span>    <span class="token number">49157ul</span><span class="token punctuation">,</span> <span class="token number">98317ul</span><span class="token punctuation">,</span> <span class="token number">196613ul</span><span class="token punctuation">,</span> <span class="token number">393241ul</span><span class="token punctuation">,</span> <span class="token number">786433ul</span><span class="token punctuation">,</span>    <span class="token number">1572869ul</span><span class="token punctuation">,</span> <span class="token number">3145739ul</span><span class="token punctuation">,</span> <span class="token number">6291469ul</span><span class="token punctuation">,</span> <span class="token number">12582917ul</span><span class="token punctuation">,</span> <span class="token number">25165843ul</span><span class="token punctuation">,</span>    <span class="token number">50331653ul</span><span class="token punctuation">,</span> <span class="token number">100663319ul</span><span class="token punctuation">,</span> <span class="token number">201326611ul</span><span class="token punctuation">,</span> <span class="token number">402653189ul</span><span class="token punctuation">,</span> <span class="token number">805306457ul</span><span class="token punctuation">,</span>    <span class="token number">1610612741ul</span><span class="token punctuation">,</span> <span class="token number">3221225473ul</span><span class="token punctuation">,</span> <span class="token number">4294967291ul</span><span class="token punctuation">}</span><span class="token punctuation">;</span>size_t <span class="token function">GetNextPrime</span><span class="token punctuation">(</span>size_t prime<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PRIMECOUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> prime<span class="token punctuation">)</span>        <span class="token keyword">return</span> primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-开散列-V-S-闭散列"><a href="#6-4-开散列-V-S-闭散列" class="headerlink" title="6.4 开散列 V.S. 闭散列"></a>6.4 开散列 V.S. 闭散列</h3><p>实际当中哈希桶结构其实相对来说更加实用</p><table><thead><tr><th>Situation</th><th>哈希桶（开散列）</th><th>闭散列</th><th>描述</th></tr></thead><tbody><tr><td>空间</td><td>空间利用率高</td><td>略低</td><td>负载因子哈希桶可以大一点</td></tr><tr><td>极端情况</td><td>极端情况还有解决方案</td><td>极端情况不好解决</td><td>极端情况是数据不多，负载因子很低，但是这些数据还是大部分冲突了</td></tr><tr><td>解决方案</td><td>冲突数据过多的桶，进行红黑树树化（Java）</td><td>解决不了</td><td>树化操作</td></tr></tbody></table><p>Java中的解决方案</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122113688.png" alt="image-20220512211357503"></p><blockquote><p>当然如果数据被删除到小于8的时候也要把数据还原成链表</p></blockquote><p>类似的我们可以这么写</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122140672.png" alt="image-20220512214014603"></p><p>如何统计个数，其实每次插入的时候都需要遍历一遍链表，这时如果还是链表的话，可以计算长度</p><p>第二种实现方式是一种复用，一种封装，写起来稍微简单一点，如果forward_list超过8就可以把数据导入到set里面去</p><p>拓展阅读：</p><p><a href="https://www.cnblogs.com/leoo2sk/archive/2010/10/01/hash-and-encrypt.html">哈希与加密</a></p><p><a href="https://www.cnblogs.com/lpfuture/p/5796398.html">一致性Hash算法原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 高阶数据结构 Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red-Black Tree</title>
      <link href="/BlogNet/2022/09/03/Red-Black-Tree/"/>
      <url>/BlogNet/2022/09/03/Red-Black-Tree/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205040918814.jpg" alt="BingWallpaper27"></p><p>[toc]</p><h1 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h1><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205200902972.png" alt="image-20220520090154798"></p><h2 id="0-Intro"><a href="#0-Intro" class="headerlink" title="0.Intro"></a>0.Intro</h2><p><strong>红黑树</strong>是一种自平衡二叉搜索树。每个节点存储一个表示“颜色”（“红色”或“黑色”）的额外位，用于确保树在插入和删除期间保持平衡。当树被修改时，新树被重新排列并“重新绘制”以恢复限制树在最坏情况下可能变得多么不平衡的着色属性。这些属性被设计成可以有效地执行这种重新排列和重新着色。</p><blockquote><p>From <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</a></p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205042105325.png" alt="image-20220504210510276"></p><h2 id="1-Red-Black-Tree"><a href="#1-Red-Black-Tree" class="headerlink" title="1. Red-Black Tree"></a>1. Red-Black Tree</h2><p>通过对任何一条从根到叶子的路径上各个结点着色方式的限制，==红黑树确保没有一条路径会比其他路径长出两倍==，因而是接近平衡的。接近平衡其实比平衡更好一点，因为相对平衡对于计算机来说实际上差别不大（对计算机来说其实logN和2logN差别不是很大），但是严格平衡是通过不断旋转来提高效率的，基于这样的原因，红黑树效率不必AVL差，但是反而旋转更少，因此总体效率更优，因此现在使用红黑树更多一点，而不是AVL树</p><h3 id="1-1-红黑树的性质"><a href="#1-1-红黑树的性质" class="headerlink" title="1.1  红黑树的性质"></a>1.1  红黑树的性质</h3><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 每个结点不是红色就是黑色<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 根节点是黑色的<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果一个节点是红色的，则它的两个孩子结点是黑色的(<strong>没有连续的红色节点</strong>)<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<strong>每条路上包含相同数量黑色节点</strong>）</p><p>每个叶子结点都是黑色的(==此处的叶子结点指的是空结点/NIL==)</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051231892.png" alt="image-20220505123105834"></p><h3 id="1-2-红黑树推论"><a href="#1-2-红黑树推论" class="headerlink" title="1.2 红黑树推论"></a>1.2 红黑树推论</h3><p><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 路径：<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最短路径：全部由黑色节点构成<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最长路径：一黑一红，黑色节点数量等于红色节点<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 假设黑色节点有N个：<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最短路径长度：logN<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最长路径长度：2logN</p><h2 id="2-实现红黑树"><a href="#2-实现红黑树" class="headerlink" title="2. 实现红黑树"></a>2. 实现红黑树</h2><h3 id="2-0-红黑树节点结构"><a href="#2-0-红黑树节点结构" class="headerlink" title="2.0 红黑树节点结构"></a>2.0 红黑树节点结构</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    RED<span class="token punctuation">,</span>    BLACK<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">RBTreeNode</span><span class="token punctuation">{</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _left<span class="token punctuation">;</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _right<span class="token punctuation">;</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _parent<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>    Color _col<span class="token punctuation">;</span>    <span class="token function">RBTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token operator">&amp;</span>  kv<span class="token punctuation">)</span>    <span class="token operator">:</span><span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_col</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候我们有一个问题，为什么要将节点的默认颜色给成红色的？</p><p>黑的好还是红的好?</p><blockquote><p>插入红的会破坏规则：</p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果一个节点是红色的，则它的两个孩子结点是黑色的(<strong>没有连续的红色节点</strong>)</p><p>插入黑的会破坏规则：</p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<strong>每条路上包含相同数量黑色节点</strong>）</p></blockquote><p>我们选择消耗低的，还是插入默认红的比较好</p><h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert"></a>2.2 Insert</h3><h4 id="2-2-0-处理搜索部分"><a href="#2-2-0-处理搜索部分" class="headerlink" title="2.2.0 处理搜索部分"></a>2.2.0 处理搜索部分</h4><p>搜索树部分类似于AVL和BSTree的插入逻辑</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//空树</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token comment">//根必须是黑的</span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span><span class="token comment">//1. 找适当的空位置</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span><span class="token comment">//重复</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//2. cur走到空 可以链接</span>Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>newnode<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">{</span>    parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span>cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//处理</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>kv<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键是处理红黑节点</p><h4 id="2-2-1-处理红黑节点"><a href="#2-2-1-处理红黑节点" class="headerlink" title="2.2.1 处理红黑节点"></a>2.2.1 处理红黑节点</h4><p>因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不<br>需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三不能有连在一起的红色节点，此<br>时需要对红黑树分情况来讨论：</p><table><thead><tr><th>parent.color</th><th>条件</th><th>处理</th></tr></thead><tbody><tr><td>BLACK</td><td>不需要调整</td><td>插入完成</td></tr><tr><td>RED</td><td>违反规则3</td><td>需要处理</td></tr></tbody></table><p>如果parent节点是红的，那么就会出现多种情况，需要处理，情况1可以通变色处理，但是情况2+3则因为<strong>最长路径已经超过最短路径的两倍所以无法变色解决，需要旋转</strong></p><p>下面的图中我们约定:cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点</p><table><thead><tr><th>情况</th><th>cur</th><th>parent</th><th>grandparent</th><th>uncle</th><th>处理方案</th></tr></thead><tbody><tr><td>情况一：<br>叔叔存在且为红</td><td>RED</td><td>RED</td><td>BLACK</td><td>exist &amp;&amp; RED</td><td>pu变黑，g变红，继续往上走</td></tr><tr><td>情况二:<br>叔叔不存在或为黑（直线）</td><td>RED</td><td>RED</td><td>BLACK</td><td>!exist || <br>exist &amp;&amp; BLACK</td><td>单旋转+变色</td></tr><tr><td>情况三;<br>叔叔不存在或为黑（折线）</td><td>RED</td><td>RED</td><td>BLACK</td><td>!exist ||<br>exist &amp;&amp; BLACK</td><td>双旋转+变色</td></tr></tbody></table><h4 id="2-2-2-Situation1"><a href="#2-2-2-Situation1" class="headerlink" title="2.2.2 Situation1"></a>2.2.2 Situation1</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况一: cur为红，p为红，g为黑，u存在且为红</strong></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051325666.png" alt="image-20220505132556579"></p><table><thead><tr><th>具象图</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>g已经到顶了</td><td>pu变黑，g变红</td></tr><tr><td>具象图2：</td><td>符合具象图1但是修改完其他节点不符合</td><td>不断执行情况1，直到parent为空时，p存在且为黑，或者p不存在停止（把根变黑）</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051326419.png" alt="image-20220505132610350"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051351735.png" alt="image-20220505135120634"></p><h4 id="2-2-3-Situation2"><a href="#2-2-3-Situation2" class="headerlink" title="2.2.3 Situation2"></a>2.2.3 Situation2</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况二: cur为红，p为红，g为黑，u不存在/u为黑</strong><br>情况二中，无非是还会出现一种情况是左旋，但是说到底都是单旋转中的一种,关键在于</p><table><thead><tr><th>parent/grandparent/cur关系</th><th>旋转操作</th><th>变色操作</th></tr></thead><tbody><tr><td>p为g的左孩子，cur为p的左孩子</td><td>右单旋转</td><td>p、g变色–p变黑，g变红</td></tr><tr><td>p为g的右孩子，cur为p的右孩子</td><td>左单旋转</td><td>p、g变色–p变黑，g变红</td></tr></tbody></table><p><font><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 为什么不能直接染色?</font></p><p>看到下图可能会有一些疑问：为什么我不能把p变黑，g变红，简单来就可以了，还要搞什么旋转呢？这是因为首先原来插入之前是一棵红黑树，那么右路如果有uncle就是需要整一条右路上要两个黑节点才能满足规则五，如果没有uncle节点就要满足至少有一个黑，所以说如果直接改变颜色，那么会导致要么右路只有一个黑节点，要么就是右路干脆没有黑节点，所以说一定要采取旋转方式，才能满足规则五</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061006661.png"></p><table><thead><tr><th>具象图（以右单旋为例）</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>`uncle  !exist</td><td></td></tr><tr><td>具象图2：</td><td>符合情况一且处理之后产生情况二</td><td>处理情况一+右单旋+p变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205060953867.png" alt="image-20220506095327691"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061035548.png" alt="image-20220506103556352"></p><h4 id="2-2-4-Situation3"><a href="#2-2-4-Situation3" class="headerlink" title="2.2.4 Situation3"></a>2.2.4 Situation3</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况三: cur为红，p为红，g为黑，u不存在/u为黑</strong></p><p>情况三看上去好像和情况二很像，其实差别在于情况三的结构，同时他是一个双旋</p><table><thead><tr><th>parent/grandparent/cur关系</th><th>旋转操作1</th><th>旋转操作2</th><th>变色操作</th></tr></thead><tbody><tr><td>p为g的左孩子，cur为p的右孩子</td><td>左单旋转</td><td>右单旋转</td><td>cur、g变色–cur变黑，g变红</td></tr><tr><td>p为g的右孩子，cur为p的左孩子</td><td>右单旋转</td><td>左单旋转</td><td>cur、g变色–cur变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205071403059.png" alt="image-20220507140351911"></p><table><thead><tr><th>具象图（以右单旋为例）</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>`uncle  !exist</td><td></td></tr><tr><td>具象图2：</td><td>符合情况一且处理之后产生情况三</td><td>处理情况一+左单旋+右单旋+cur变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061039461.png" alt="image-20220506103931331"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061104810.png" alt="image-20220506110459705"></p><h4 id="2-2-5-分类讨论总结"><a href="#2-2-5-分类讨论总结" class="headerlink" title="2.2.5 分类讨论总结"></a>2.2.5 分类讨论总结</h4><p>插入一个新节点，新节点必是红的</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205072102026.png" alt="image-20220507210143404"></p><h4 id="2-2-6-实现插入"><a href="#2-2-6-实现插入" class="headerlink" title="2.2.6 实现插入"></a>2.2.6 实现插入</h4><h5 id="2-2-6-1-插入本体"><a href="#2-2-6-1-插入本体" class="headerlink" title="2.2.6.1 插入本体"></a>2.2.6.1 插入本体</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//插入</span>pair<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//空树</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token comment">//根必须是黑的</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token comment">//1. 找适当的空位置</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&gt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span><span class="token comment">//重复</span>            <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//2. cur走到空 可以链接</span>    Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>        newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>        newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    <span class="token comment">//3.判断处理条件</span>    <span class="token comment">//如果父亲存在，且颜色为红色就需要处理</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//抓住叔叔是关键</span>        Node<span class="token operator">*</span> grandfather <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>    <span class="token comment">//a. 首先父亲在祖父左边的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">==</span>grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Node<span class="token operator">*</span> uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>            <span class="token comment">//情况1：uncle 存在且为红</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">==</span>RED<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token comment">//继续往上处理</span>                cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>                parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//情况2+3 uncle不存在或者uncle存在且为黑</span>            <span class="token keyword">else</span><span class="token comment">//此时变色无法处理</span>            <span class="token punctuation">{</span>                <span class="token comment">//情况2：单旋</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">==</span>parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>                <span class="token punctuation">{</span>   <span class="token comment">//1. 右单旋</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//2. 变色</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                    parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span><span class="token comment">//情况3：双旋</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//根是黑的了，不会往上影响直接break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         <span class="token comment">//b. 首先父亲在祖父左边的情况</span>        <span class="token keyword">else</span><span class="token comment">//parent == grandfather-&gt;_right</span>        <span class="token punctuation">{</span>            Node<span class="token operator">*</span> uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>            <span class="token comment">//情况1：uncle 存在且为红 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                uncle<span class="token operator">-&gt;</span>_col<span class="token operator">=</span>parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token comment">//继续往上递归</span>                cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>                parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span><span class="token comment">//这个肯定有父亲</span>            <span class="token punctuation">}</span>             <span class="token comment">//情况 2+3： uncle不存在或为黑</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_right<span class="token operator">==</span>cur<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//默认修改根节点为黑色</span>    _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>newnode<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-6-2-旋转函数"><a href="#2-2-6-2-旋转函数" class="headerlink" title="2.2.6.2 旋转函数"></a>2.2.6.2 旋转函数</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> subL <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>Node<span class="token operator">*</span> subLR <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span><span class="token comment">//1.旋转</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subLR<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>subLR<span class="token punctuation">)</span><span class="token punctuation">{</span>subLR<span class="token operator">-&gt;</span>_parent<span class="token operator">=</span>parent<span class="token punctuation">;</span><span class="token punctuation">}</span>subL<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> parent<span class="token punctuation">;</span>Node<span class="token operator">*</span> grandparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span><span class="token comment">//记录爷爷</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subL<span class="token punctuation">;</span><span class="token comment">//2. 修改父子关系</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> _root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//原来的父亲做了根节点</span>_root <span class="token operator">=</span> subL<span class="token punctuation">;</span>_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//修改爷爷和父亲链接</span><span class="token keyword">if</span> <span class="token punctuation">(</span>grandparent<span class="token operator">-&gt;</span>_left<span class="token operator">==</span>parent<span class="token punctuation">)</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subL<span class="token punctuation">;</span><span class="token keyword">else</span>grandparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subL<span class="token punctuation">;</span>subL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> grandparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> subR <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>Node<span class="token operator">*</span> subRL <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span><span class="token comment">//1. 旋转</span>parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subRL<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>subRL<span class="token punctuation">)</span><span class="token punctuation">{</span>subRL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span>subR<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> parent<span class="token punctuation">;</span>Node<span class="token operator">*</span> grandparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subR<span class="token punctuation">;</span><span class="token comment">//2. 修改父子关系</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>_root <span class="token operator">=</span> subR<span class="token punctuation">;</span>_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> parent<span class="token punctuation">)</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subR<span class="token punctuation">;</span><span class="token keyword">else</span>grandparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subR<span class="token punctuation">;</span>subR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> grandparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-Erase"><a href="#2-3-Erase" class="headerlink" title="2.3 Erase"></a>2.3 Erase</h3><p>和AVL树类似，红黑树的删除只谈谈思想</p><ul><li>删除节点一定是左为空或者右为空，然后让父亲链接自己的孩子<ul><li><p>删除的是红色节点，直接就没有什么问题</p></li><li><p>删除的是黑色节点，可能导致连续的红节点，或者一条路径上少了一个黑节点</p><ul><li><p>后继还有红节点，变色成黑的</p></li><li><p>后继没有红节点可能还要旋转</p></li></ul></li></ul></li></ul><p>具体有很多种情况可以参照<a href="https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html">https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html</a></p><h3 id="2-4-Find"><a href="#2-4-Find" class="headerlink" title="2.4 Find"></a>2.4 Find</h3><p>和搜索树如出一辙</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Node<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&gt;</span>key<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>key<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-析构函数"><a href="#2-5-析构函数" class="headerlink" title="2.5 析构函数"></a>2.5 析构函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_Destroy</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//析构</span><span class="token operator">~</span><span class="token function">AVLTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>    _root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-拷贝构造和赋值运算符"><a href="#2-6-拷贝构造和赋值运算符" class="headerlink" title="2.6 拷贝构造和赋值运算符"></a>2.6 拷贝构造和赋值运算符</h3><p>可以参考搜索二叉树，和之前的如出一辙</p><p><a href="https://blog.csdn.net/Allen9012/article/details/124435568">https://blog.csdn.net/Allen9012/article/details/124435568</a></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205071453328.png" alt="image-20220507145354216"></p><h3 id="2-7-CheckBalance"><a href="#2-7-CheckBalance" class="headerlink" title="2.7 CheckBalance"></a>2.7 CheckBalance</h3><p>我们需要写一个树来查一下我们的插入操作正不正确，是否插入形成了一个红黑树</p><p>为了验证是否是红黑树，我们还是利用几点原则</p><h4 id="2-7-1-黑色的根"><a href="#2-7-1-黑色的根" class="headerlink" title="2.7.1 黑色的根"></a>2.7.1 黑色的根</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//1.黑根</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"root是红色"</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-没有连续的红色节点"><a href="#2-7-2-没有连续的红色节点" class="headerlink" title="2.7.2 没有连续的红色节点"></a>2.7.2 没有连续的红色节点</h4><p>方法就是遍历，然后找到红色节点，去查找父亲是不是红色节点，如果是红色就返回false</p><h4 id="2-7-3-每条路径上的黑色节点数量相等"><a href="#2-7-3-每条路径上的黑色节点数量相等" class="headerlink" title="2.7.3 每条路径上的黑色节点数量相等"></a>2.7.3 每条路径上的黑色节点数量相等</h4><p>前序遍历，从根节点走到每一个NIL节点，只要是黑色就count++，如果走到了NIL节点就return，然后此时上一层栈帧的++不影响其他层的count，于是可以实现</p><ol><li>用一个vector去记录每个路径的黑色接点数量，如果最后都是相等的，那么就是说明是红黑树</li><li>不想要走完每条路线才最后比较，可不可以找一条路径作为标准，只要其他路和这条路线不相等就说明不是红黑树，可以找最左路径做黑色节点的参考值<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>Node<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> black_num<span class="token punctuation">,</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> black_num<span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token comment">//3.路径黑节点数相等</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"路径上黑色节点的数量不相等"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2.遍历红节点，查父亲是不是红的，不要查孩子因为孩子可能没有</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED <span class="token operator">&amp;&amp;</span> root<span class="token operator">-&gt;</span>_parent<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"存在连续的红色节点"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>BLACK<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span>  <span class="token function">CheckBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//1.黑根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"root是红色"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2. 每条路径走到NIL节点，遇到黑++，找最左路径做黑色节点的参考值</span>    <span class="token keyword">int</span> black_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> left <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>BLACK<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            black_num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        left <span class="token operator">=</span> left<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//count计算该条路的值</span>    <span class="token comment">//3. 用子函数来递归遍历</span>    <span class="token keyword">return</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="3-红黑树-V-S-AVL树"><a href="#3-红黑树-V-S-AVL树" class="headerlink" title="3. 红黑树 V.S. AVL树"></a>3. 红黑树 V.S. AVL树</h2><p>红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是<br>$$<br>O(log_2N)<br>$$</p><p>，红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。</p><h2 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h2><ol><li>C++ STL库 – map/set、mutil_map/mutil_set</li><li>Java 库</li><li>linux内核</li><li>其他一些库</li></ol><p>相关代码放在了我的GitHub仓库<a href="https://github.com/Allen9012/cpp/tree/main/C++%E8%BF%9B%E9%98%B6/RBTree">https://github.com/Allen9012/cpp/tree/main/C%2B%2B%E8%BF%9B%E9%98%B6/RBTree</a></p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h3 id="关于AVL树和红黑树的区别说法不正确的是（）"><a href="#关于AVL树和红黑树的区别说法不正确的是（）" class="headerlink" title="关于AVL树和红黑树的区别说法不正确的是（）"></a>关于AVL树和红黑树的区别说法不正确的是（）</h3><p>A.AVL树和红黑树保证平衡性的方式不同</p><p>B.AVL树和红黑树都是平衡树，因此查找的时间复杂度都是O(log_2N)</p><p>C.AVL树和红黑树的性质遭到破坏时，都需要进行旋转</p><p>D.AVL树和红黑树中序遍历都可以得到有序序列，因为它们都是二叉搜索树</p><blockquote><p> A：正确，AVL树通过节点的平衡因子保证，红黑树通过节点的颜色以及红黑树的特性保证</p><p> B：正确，AVL树是严格平衡的，红黑树虽然是近似平衡，但其性能往往比AVL树好，而且实现简 单，因此他们的查找  效率都是O(logN)</p><p> C：错误，AVL树是一定需要旋转，红黑树不一定，红黑树有时只需要改变节点的颜色即可</p><p> D：正确，参考概念</p><p> 因此：选择C</p></blockquote><h3 id="关于红黑树以下说法正确的是（）"><a href="#关于红黑树以下说法正确的是（）" class="headerlink" title="关于红黑树以下说法正确的是（）"></a>关于红黑树以下说法正确的是（）</h3><p>A.空树不是红黑树，因为红黑树要求根节点必须为黑色，而空树中没有根节点</p><p>B.红黑树也是二叉搜索树，因此其按照前序遍历可以得到有序序列</p><p>C.红黑树是一棵真正平衡的二叉树</p><p>D.红黑树最长路径中节点个数可能会等于最短路径中节点个数的两倍</p><blockquote><p> A：错误，空树也是红黑树，性质5中规定树中的空指针域为叶子节点，因此空树也是有节点的</p><p> B：错误，红黑树也是二叉搜索树，按照中序遍历才可以得到有序序列</p><p> C：红黑树不像AVL树那么严格，是一棵近似平衡的二叉搜索树</p><p> D：正确，比如红黑树中只有两个节点</p><p> 因此：选择D</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 高阶数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/BlogNet/2022/08/25/hello-world/"/>
      <url>/BlogNet/2022/08/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Allen’s Blog! This is your very first post. you can ask me on <a href="https://github.com/Allen9012">GitHub</a>.</p><p>Following is my blog on <a href="https://blog.csdn.net/Allen9012?spm=1000.2115.3001.5343">CSDN</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
