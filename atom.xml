<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen 的 blog</title>
  
  <subtitle>博客记录学习</subtitle>
  <link href="https://allen9012.github.io/BlogNet/atom.xml" rel="self"/>
  
  <link href="https://allen9012.github.io/BlogNet/"/>
  <updated>2022-09-18T01:22:06.327Z</updated>
  <id>https://allen9012.github.io/BlogNet/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>八大排序算法</title>
    <link href="https://allen9012.github.io/BlogNet/2022/09/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://allen9012.github.io/BlogNet/2022/09/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-18T01:20:10.000Z</published>
    <updated>2022-09-18T01:22:06.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h1><p>[toc]</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260924128.png" alt="image-20211209180855524"></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>数据结构和算法是不分家的，接下来的排序算法中，有的算法可能会用到某种数据结构</p><p>排序算法是什么呢？百度百科一下</p><blockquote><p>排序就是把集合中的元素按照一定的次序排序在一起。一般来说有升序排列和降序排列2种排序，在算法中有8种基本排序</p><p>往往评价一个排序算法的好坏往往可以从几个方面入手：</p><p>（1）时间复杂度：即从序列的初始状态到经过排序算法的变换移位等操作变到最终排序好的结果状态的过程所花费的时间度量。</p><p>（2）空间复杂度：就是从序列的初始状态经过排序移位变换的过程一直到最终的状态所花费的空间开销。</p><p>（3）使用场景：排序算法有很多，不同种类的排序算法适合不同种类的情景，可能有时候需要节省空间对时间要求没那么多，反之，有时候则是希望多考虑一些时间，对空间要求没那么高，总之一般都会必须从某一方面做出抉择。</p><p>（4）稳定性：稳定性是不管考虑时间和空间必须要考虑的问题，往往也是非常重要的影响选择的因素。</p></blockquote><p>就像<a href="https://www.bilibili.com/video/BV1EW411u7th?p=13">Crash Course Computer Science 13. Intro to Algorithm</a>所说，记载最多的算法之一是“排序”，我们在生活中也常常会排序，比如名字，比如数字<strong>Computer sort all the time</strong>,比如说找出最便宜的机票，按最新时间排邮件，按姓氏排联系……</p><blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260924623.png" alt="image-20211208164800370"></p><p>本图片来源于Crash Course Computer Science,举了飞机飞到印第安纳波利斯的机票价钱排序</p></blockquote><p>那么接下来开始介绍八大排序，之后的排序算法实例都是以排升序为示例</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序其实可以联想到当我们在打扑克牌的时候，把同样大的摆在一起，把大的排在小的后面，每次摸一张牌的时候，就插入手中有序的拍的序列之中，找到合适的位置插入进去</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260924119.gif"></p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>假设插入前的排序已经排好顺序，用要插入的数据进行一一比较，找到相应位置将其插入</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260924648.png" alt="image-20211204205050543"></p><h3 id="实现插入排序"><a href="#实现插入排序" class="headerlink" title="实现插入排序"></a>实现插入排序</h3><p>实现排序要想到先拆解问题，然后再画图思考</p><p>先对问题的拆解</p><ol><li><p>单趟怎么走？</p></li><li><p>单趟实现了，那多趟怎么走？</p></li></ol><h4 id="先写单趟排序"><a href="#先写单趟排序" class="headerlink" title="先写单趟排序"></a>先写单趟排序</h4><ul><li>先确定要插入的数组的最后一个是下标是end，然后要插入的值是tmp</li><li>然后比较数组中下标为end的值和tmp的大小<ul><li>如果tmp小，那么当前指向的值向后移动一位，然后end往前走一个</li><li>如果tmp大，就放入当前end位置的后面一个</li><li>如果一样大就放在你这个数的后面</li><li>如果<code>end==-1</code>走出数组，那么还是放在end位置的后面一个，也就是数组下标为0的位置</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tmp<span class="token punctuation">;</span><span class="token keyword">int</span> end<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//挪动数据</span>         <span class="token operator">--</span>end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//循环结束或者end==-1</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="再写多趟，控制end的位置和插入的值"><a href="#再写多趟，控制end的位置和插入的值" class="headerlink" title="再写多趟，控制end的位置和插入的值"></a>再写多趟，控制end的位置和插入的值</h4><ul><li>end的值等于i</li><li>tmp相当于end的后一个位置，所以是end+1</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span>   <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>   <span class="token punctuation">{</span>   <span class="token comment">//把tmp插入到数组的[0，end]的有序区间</span>   <span class="token keyword">int</span> end<span class="token operator">=</span>i<span class="token punctuation">;</span>   <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>   a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token operator">--</span>end<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">else</span>   <span class="token punctuation">{</span>   <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token comment">//循环结束或者end==-1</span>   a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以代码是这样</p><h3 id="直接插排复杂度"><a href="#直接插排复杂度" class="headerlink" title="直接插排复杂度"></a>直接插排复杂度</h3><table><thead><tr><th>最好与最坏</th><th>复杂度</th><th>发生情况</th></tr></thead><tbody><tr><td>最坏的情况</td><td>O（N^2^）</td><td>逆序的一个数组</td></tr><tr><td>最好的情况</td><td>O（N）</td><td>顺序有序的数组</td></tr></tbody></table><p>分析这样一个表格说明：直接插入排序比较适合接近于顺序有序的数组</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925241.gif"></p><p>希尔排序也叫缩小增量排序，希尔他分析了一下直接插入排序时间复杂度，他发现了问题，也解决了问题，实现了对直接插入排序的优化</p><p>希尔排序分为了两个目的：</p><ol><li>预排序，使得数组接近有序</li><li>直接插入排序</li></ol><p>效果：只要最后结果的方法复杂度小于O（N^2^），就是有效的进步</p><h3 id="实现希尔排序"><a href="#实现希尔排序" class="headerlink" title="实现希尔排序"></a>实现希尔排序</h3><ul><li>想法：</li></ul><p>间隔为gap分为一组数据，对一组插入排序，假如说如上图的gap=5</p><p>这样之后相比原来的会更加接近有序，并且大的数会被更快的挪到后面，小的更快挪到后面</p><ul><li>gap越大，大的和小的数可以更快地挪到对应的方向，但是越不接近有序</li><li>gap越小，大的和小的就会越慢地挪到对应的方向，但是gap越小就会越接近有序</li></ul><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925266.png" alt="image-20211205105314224"></p><p>希尔排序的思想就是一开始gap要相对于整个数据地总量来说是一个大的值，要求快速接近相应位置，然后gap要减小，为了接近有序， 最后<code>gap==1</code>的时候本质就是一个直接插入排序</p><p>还是先对复杂的问题进行拆解</p><ol><li>先写一次希尔排序</li><li>再把多趟排序完成</li></ol><h4 id="一次希尔排序"><a href="#一次希尔排序" class="headerlink" title="一次希尔排序"></a>一次希尔排序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">   <span class="token keyword">int</span> gap<span class="token punctuation">;</span><span class="token keyword">int</span> end<span class="token punctuation">;</span><span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>end<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>end <span class="token operator">-=</span> gap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到其实<code>gap==1</code>的时候就是直接插入排序 </p><h4 id="完成多次排序，改变gap让其越来越接近顺序"><a href="#完成多次排序，改变gap让其越来越接近顺序" class="headerlink" title="完成多次排序，改变gap让其越来越接近顺序"></a>完成多次排序，改变gap让其越来越接近顺序</h4><p>我们按照<code>gap==3</code>来举一个栗子</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202206140938949.png" alt="image-20211205130527024"></p><p>我们的想法是这样的，先对i所在位置的蓝色区间9排列，排完一次之后立马往后移一个i然后对红区间的1，然后是绿区间的2，然后再是蓝5，然后再是……，最后到<code>size-gap</code>即蓝8排完的时候结束算排序完</p><p>这样就可以把gap和end相应的赋值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> gap<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz <span class="token operator">-</span> gap<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>end <span class="token operator">-=</span> gap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是gap肯定不能只是3不变，这里我们使用推荐的做法，每次gap都<code>gap=gap/3+1</code>，为的是使得最后一次能够保证最后一次一定是<code>gap==1</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//多组并排</span><span class="token comment">//gap&gt;1的时候，预排序</span><span class="token comment">//gap==1的时候，直接插入排序</span><span class="token keyword">int</span> gap<span class="token operator">=</span>sz<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    gap <span class="token operator">=</span> <span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//保证最后一次是1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz <span class="token operator">-</span> gap<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>                end <span class="token operator">-=</span> gap<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然gap每次/5，/7都是可以的</p><p>用一个逆序的栗子可以看希尔排序更直接</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">11</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925991.png" alt="image-20211205133408477"></p><h3 id="希尔排序时间复杂度"><a href="#希尔排序时间复杂度" class="headerlink" title="希尔排序时间复杂度"></a>希尔排序时间复杂度</h3><p>对于时间复杂度的问题上面来看，这里我们通过100000个数的伪随机数来试试看排序的速度（单位是毫秒）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> a2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">InsertSort</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ShellSort</span><span class="token punctuation">(</span>a2<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"InsertSort:%d\n"</span><span class="token punctuation">,</span> end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ShellSort:%d\n"</span><span class="token punctuation">,</span> end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925007.png" alt="image-20211205134311210"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925157.png" alt="image-20211205135007396"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925521.png" alt="image-20211205135051245"></p><blockquote><p>可见差别还是很明显的</p><p>希尔排序的复杂度非常难算,平均来说是O(N^1.3^)</p><p>当取<code>gap/3</code>的时候是<br>$$<br>O(log_3^N*N)<br>$$</p></blockquote><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260925022.gif" alt="选择排序"></p><h3 id="直接选择排序的想法"><a href="#直接选择排序的想法" class="headerlink" title="直接选择排序的想法"></a>直接选择排序的想法</h3><p>直接选择排序也就是暴力排序一波，排升序的时候找到剩下数组中最小的那一个放在剩下区间的头</p><p>当然现在我们可以稍稍优化一下，就是每遍历一遍数组，把最大和最小放在合适的位置，然后再去选择次小的和次大的，依次这样走，直到该区间只剩一个值或没有</p><blockquote><p>优化了一点，但还是，因为要考虑最差的时间复杂度<br>$$<br>O(N^2)<br>$$</p></blockquote><h3 id="实现选择排序-不完全对"><a href="#实现选择排序-不完全对" class="headerlink" title="实现选择排序(不完全对)"></a>实现选择排序(不完全对)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找出=最大的和最小的</span><span class="token keyword">int</span> minIndex <span class="token operator">=</span> left<span class="token punctuation">,</span> maxIndex <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是我们用逆序数组的栗子发现这样仍然不对，需要找一下问题</p><pre class="line-numbers language-none"><code class="language-none">int a[] = { 10,9,8,7,6,5,4,3,2,1,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11 };<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260926369.png" alt="image-20211205142131357"></p><h3 id="改正选择排序"><a href="#改正选择排序" class="headerlink" title="改正选择排序"></a>改正选择排序</h3><p>其实我们的选择排序缺的是很重要的一步，通过调试我们可以发现，如果当<code>a[left]</code>正好就是数组中<code>max</code>的时候，因为有这样的一步</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以相当于<code>a[left]</code>的值被交换到了<code>minIndex</code>，那个数组中的最大值已经不是原先记录在<code>maxIndex</code>的下标，所以导致执行下一步的时候</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把<code>a[right]</code>换成了<code>a[minIndex]</code>，如果遇到<code>left == maxIndex</code>的情况时，会产生大问题，遇到逆序数组更是白排序了一遍</p><blockquote><p>于是我们需要下面一步排除问题</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>maxIndex <span class="token operator">=</span> minIndex<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正确的选择排序"><a href="#正确的选择排序" class="headerlink" title="正确的选择排序"></a>正确的选择排序</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span><span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找出=最大的和最小的</span><span class="token keyword">int</span> minIndex <span class="token operator">=</span> left<span class="token punctuation">,</span> maxIndex <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>maxIndex <span class="token operator">=</span> minIndex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260926698.png" alt="image-20211205143418661"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>还有一种选择排序就是通过堆的特性来选择排序</p><p>堆排序就还是通过建堆，然后向上调整和向下调整来实现，具体的实现思路与方法会在数据结构堆中仔细展开，到时候可以参见那篇专门谈堆的博客</p><blockquote><p><img src="https://www.codesdope.com/staticroot/images/algorithm/heapsort2.gif" alt="Heapsort and its analysis"><br>注：本图片来源于<a href="https://www.codesdope.com/staticroot/images/algorithm%EF%BC%8C%E5%9B%BE%E7%89%87%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%B8%8D%E6%B6%89%E5%8F%8A%E5%95%86%E4%B8%9A%E7%94%A8%E9%80%94%EF%BC%8C%E5%A6%82%E6%9C%89%E4%BE%B5%E6%9D%83%EF%BC%8C%E8%AF%B7%E8%81%94%E7%B3%BB%E5%88%A0%E9%99%A4">https://www.codesdope.com/staticroot/images/algorithm，图片仅供参考学习，不涉及商业用途，如有侵权，请联系删除</a></p></blockquote><h3 id="实现堆排序"><a href="#实现堆排序" class="headerlink" title="实现堆排序"></a>实现堆排序</h3><p>一定要记住，==排升序要建大堆，排降序要建小堆==</p><ul><li>分解问题<ol><li>先建大堆</li><li>向下调整排序</li></ol></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span><span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">,</span><span class="token keyword">int</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parent <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//先检查再访问</span><span class="token punctuation">{</span><span class="token operator">++</span>child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent <span class="token operator">=</span> child<span class="token punctuation">;</span>child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//已经小了就直接跳出循环  </span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>sz <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">AdjustDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向下调整建一个大堆</span><span class="token punctuation">}</span><span class="token keyword">int</span> end <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//头放到最后，次大的放到倒数第二个……</span><span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">AdjustDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h3><p>$$<br>O(N*log_2 ^N)<br>$$<br>这时候我们再通过100000个数的伪随机数来试试看排序的速度（单位是毫秒）</p><p>效果很明显</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260926612.png" alt="image-20211205220552877"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260926908.png" alt="image-20211206111256120"></p><p>空间复杂度是<br>$$<br>O(1)<br>$$</p><h1 id="3-交换排序"><a href="#3-交换排序" class="headerlink" title="3. 交换排序"></a>3. 交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本想法"><a href="#基本想法" class="headerlink" title="基本想法"></a>基本想法</h3><p>起源于水里的气泡随着上升，越来越大</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260926563.gif" alt="在这里插入图片描述"></p><h3 id="实现冒泡排序"><a href="#实现冒泡排序" class="headerlink" title="实现冒泡排序"></a>实现冒泡排序</h3><ul><li>问题拆解<ol><li>单趟</li><li>多趟</li></ol></li></ul><p>单趟</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多趟</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token operator">-</span>j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化</p><p>创建一个优化的标志，某一次如果没有交换，直接跳出循环，因为已经有序</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">bool</span> exchange <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>algorithm<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>exchange <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><table><thead><tr><th>最好与最坏</th><th>复杂度</th><th>发生情况</th></tr></thead><tbody><tr><td>最坏的情况</td><td>O（N^2^）</td><td>逆序的一个数组</td></tr><tr><td>最好的情况</td><td>O（N）</td><td>顺序有序的数组</td></tr></tbody></table><p>看上去好像和插入排序是一样的，那么到底谁更好呢？</p><p>顺序有序的话，一样好</p><p>接近有序的话，插入好</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927905.gif"></p><blockquote><p>注：本图片来源于<a href="https://commons.wikimedia.org,图片仅供参考学习,不涉及商业用途,如有侵权,请联系删除/">https://commons.wikimedia.org，图片仅供参考学习，不涉及商业用途，如有侵权，请联系删除</a></p></blockquote><p>快排，如其名说明很快，且了解后发现其变形多</p><h3 id="基本想法（Hoare）"><a href="#基本想法（Hoare）" class="headerlink" title="基本想法（Hoare）"></a>基本想法（Hoare）</h3><p><strong>Hoare的实现</strong></p><ul><li><p>单趟排序</p><p>选出一个key，一般是最左边的或者是最右边的，key放到正确的位置去，左边比key要小，右边的比key要大</p></li></ul><p> 这里看图来举个例子：</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927670.png" alt="image-20211206173207110"></p><p>假设我们把这个数组里面的<strong>最左边的6选作为key</strong>，<strong>让right先走</strong></p><p>其中right找小数，left找大数，目的其实是为了让左边的比key小右边的比key大</p><p>找完之后互相交换</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927041.png" alt="image-20211206173753284"></p><p>继续找，继续交换</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927024.png" alt="image-20211206173840027"></p><p>直到相遇，<strong>发现该值比key小</strong>，交换一下</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927882.png" alt="image-20211206181349075"></p><p>这样的话就走完一趟了</p><blockquote><ul><li>这里有人会提出疑问</li></ul><ol><li>我们在之前为什么要求让right先走？</li><li>那如果我发现相遇的时候的值比key大怎么办？</li></ol><p>其实我们让right先走这样设置的目的就是为了防止相遇的时候的值比key大的情况产生，就能保证始终比key小了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927073.png" alt="image-20211206181257621"></p><p>当走到最后一步时，如果先走的是left而不是right的话，left在找大的时候直接略过了3，使得相遇的时候的数字变成9，那最后一步要让比key小的数字和key互换就实现不了，所以最左边数字为key的时候，要让右边的right先走 。<span alt="modern">也正是右边先走才能使得两种相遇形式，即左遇右（右边先找到小数就停，左边没找到继续走使得相遇）和右遇左（右边找不到小数直接走使得和左所在位置相遇）</span>，这两种情况都会使right找到小的（仔细画图分析）</p></blockquote><p>那如果右边做key怎么来？左边先走<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204172103880.png" alt="image-20220417210257710"></p><p>接下来，我们来完成多趟</p><p>在确定了之前的key之后我们把中间的现在放着key的左右两边拆开，就像分成左子树和右子树一样</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927575.png" alt="image-20211206184029563"></p><p>对左一段和右一段分别重复上述操作，左边和右边就成了这样</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260927804.png" alt="image-20211206184434997"></p><p>继续如上操作</p><p>发现已经是有序的了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928226.png" alt="image-20211206184658660"></p><p>当最后只剩下一个的时候就是有序的</p><h3 id="实现快速排序"><a href="#实现快速排序" class="headerlink" title="实现快速排序"></a>实现快速排序</h3><p>对于单次排序，我们需要排除一种可能，也就是顺序数组可能会使得right一直找不到，使得right最后越界也没有完成任务</p><p>开始进入的时候<code>while (left&lt;right)</code>,并不能排除right越界，要在找大和找小的时候再判断一次</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928744.png" alt="image-20211206200655936"></p><p><font>还要注意在找大和找小的时候<code>=</code>不能忘记</font>，如果忘记就会使得当left和right遇到同样大的时候不++和–，最后直接交换陷入死循环，所以找大别带上等于，找小也别带上等于</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202206151404324.png" alt="image-20211206201816417"></p><p>所以细节很多，最后正确的单趟应该是这样</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找大</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//找小</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后交换一下key的值和相遇的值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来完成多趟，完整实现</p><p>首先为了要递归，那么函数的参数肯定还用sz是不合适的，那么改成start和end，同时增加一个递归终止条件</p><blockquote><p>那么这样就是Hoare版的快速排序</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">,</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找大</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//找小</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> meeti <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后交换一下key的值和相遇的值</span><span class="token comment">//左[begin,meeti-1] 右[meeti+1,end]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> meeti <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> meeti<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>那么这个思想就是类似于二叉树的–“分治”排序</p></blockquote><h3 id="实现多种方法"><a href="#实现多种方法" class="headerlink" title="实现多种方法"></a>实现多种方法</h3><p>这里我们把单趟排序抽离出来，将单趟返回参数来递归，那么</p><p><code>PartSort(a, begin, end)</code>其实是由多种写法的，接下来分析多种写法</p><p>首先这个本体是不变的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传key值</span><span class="token comment">//左[begin,meeti-1] 右[meeti+1,end]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span alt="modern">为什么begin要&gt;=而不是判断=，这是因为可能begin会超过end</span></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204191020524.png" alt="image-20220419102024192"></p><h4 id="Hoare法（左右指针法）"><a href="#Hoare法（左右指针法）" class="headerlink" title="Hoare法（左右指针法）"></a>Hoare法（左右指针法）</h4><p>这里我们称之前所讲的方法为Hoare法，或许命名可能是最早发现这个方法的人</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找大</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//找小</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后交换一下key的值和相遇的值</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>试试看其他几种方法实现单趟排序</p><h4 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h4><ol><li><p>还是取出left的值用key保存，比如说下图的6</p></li><li><p>这里不同的点在于当前left所指向的变成了一个坑，也就是该位置可以覆盖</p></li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928145.png" alt="image-20211206221615831"></p><ol start="3"><li>同样的还是右边的right开始走，找小，找到小数之后这次不一样了，不是交换，而是把right的值放到坑里面，于是形成了新的坑</li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928078.png" alt="image-20211206222417444"></p><ol start="4"><li>再然后left找大，填到坑里面，再产生新坑</li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928572.png" alt="image-20211206222451890"></p><ol start="5"><li>最后会相遇，然后放进去key就好了</li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928505.png" alt="image-20211206222717080"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928285.png" alt="image-20211206223113656"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">PartSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> key <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找小</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//放到左边的坑中，右边形成新的坑</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//找大</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//放到右边的坑中，左边形成新的坑</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token keyword">return</span> left<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font>那么这就是挖坑法，理解一下优点,本质上没有区别</font>还有就是右边坑的话，左边先走</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204191040082.png" alt="image-20220419104044804"></p><h4 id="前后指针法"><a href="#前后指针法" class="headerlink" title="前后指针法"></a>前后指针法</h4><ol><li><p>先是有两个指针，分别是cur和prev，开始的时候分别在一前一后</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260928025.png" alt="image-20211207180937635"></p></li><li><p>然后cur去找比key小的值，<font>找到以后++prev</font>，再交换prev和cur位置的值</p></li></ol><ul><li><p>前两次的交换之后没什么变化,因为<code>cur==prev</code>，所以等会写代码的时候可以排除这个可能性   </p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929256.png" alt="image-20211207181158098"></p></li><li><p>第三次之后看到了变化，其实观察这个操作的意义是在把大的往后放，小的往前放<br> <img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929830.png" alt="image-20211207181429109"></p></li></ul><ol start="3"><li>直到cur走出数组尾之后停止</li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929205.png" alt="image-20211207181711640"></p><ol start="4"><li><p>最后把key位置和prev位置互相交换</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929472.png" alt="image-20211207182002968"></p></li></ol><blockquote><p>这样的单趟的目的是什么呢，就是使得prev左边的数都比key小，右边的数都比key大</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">PartSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">int</span> cur <span class="token operator">=</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token operator">++</span>prev<span class="token operator">!=</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">++</span>cur<span class="token punctuation">;</span><span class="token comment">//不进或者交换之后都要往后走</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> prev<span class="token punctuation">;</span><span class="token comment">//返回分隔的值 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前后指针法如果右边做key，那么其实还是从左边走，错位一下，到key左边就可以停了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204191558352.png" alt="image-20220419155839116"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204191600974.png" alt="image-20220419160019739"></p><h3 id="时间复杂度测试"><a href="#时间复杂度测试" class="headerlink" title="时间复杂度测试"></a>时间复杂度测试</h3><p>接下来用同样的方法，随机生成数组感受一下快排的速度</p><p>debug版在优化递归的时候不太好，性能不会太明显，建议用release来测性能</p><p>debug版 100000</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929219.png" alt="image-20211206224805210"></p><p>release版 1000000</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929365.png" alt="image-20211206225131593"></p><h3 id="理想时间复杂度计算"><a href="#理想时间复杂度计算" class="headerlink" title="理想时间复杂度计算"></a>理想时间复杂度计算</h3><p>最好的情况是：</p><p>理想的快排应该是每次的key恰巧是中位数，然后相当于二分法一样的走下去</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929387.png" alt="image-20211206230129273"></p><p><strong>时间复杂度是</strong><br>$$<br>O(log_2^N*N)<br>$$</p><p>最坏的情况是</p><p>有序的数组，则此时每个排序都取最左边为key</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260929961.png" alt="image-20211206230814871"></p><p><strong>这样的时间复杂度是</strong><br>$$<br>O(N^2)<br>$$<br>因此这样的话来看，我们之前写的快排太不稳定，这样不是一个合格排序，我们要对这个快排优化，让它对所有的情况都好用，我们发现问题出在key的选取</p><p>于是我们可以采取</p><ol><li>三数取中法（通过采取改进选key的方法来优化）</li><li>小区间排序优化</li></ol><p><strong>空间复杂度是</strong><br>$$<br>O(logN)<br>$$</p><h3 id="优化快排"><a href="#优化快排" class="headerlink" title="优化快排"></a>优化快排</h3><h4 id="三数取中法（通过采取改进选key的方法来优化）"><a href="#三数取中法（通过采取改进选key的方法来优化）" class="headerlink" title="三数取中法（通过采取改进选key的方法来优化）"></a>三数取中法（通过采取改进选key的方法来优化）</h4><p>既然问题出在选key，那么我们使得选恰好中间的数能够最优时间复杂度，于是我们可以每次找出头尾和中间那个三个数字中的中间数，并返回给key，使key的选取变得优化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找出头尾和中间那个三个数字中的中间数</span><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&gt;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左[begin,meeti-1] 右[meeti+1,end]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="三数取中法-Hoare"><a href="#三数取中法-Hoare" class="headerlink" title="三数取中法+Hoare"></a>三数取中法+Hoare</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> midIndex <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>midIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//到这步left里的值将会使头中尾的中间值</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//找大</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//找小</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后交换一下key的值和相遇的值</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="三数取中法-前后指针"><a href="#三数取中法-前后指针" class="headerlink" title="三数取中法+前后指针"></a>三数取中法+前后指针</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">PartSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> midIndex <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>midIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//到这步left里的值将会使头中尾的中间值</span><span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">int</span> cur <span class="token operator">=</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token operator">++</span>prev<span class="token operator">!=</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">++</span>cur<span class="token punctuation">;</span><span class="token comment">//不进或者交换之后都要往后走</span><span class="token punctuation">}</span><span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> prev<span class="token punctuation">;</span><span class="token comment">//返回分隔的值 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下图是对100000个数量的有序数组排序的比较，可以看出三数取中法有 效解决了左右指针的缺陷,甚至当遇到顺序数组的时候效率反而最高</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260930615.png" alt=" "></p><h4 id="小区间排序优化"><a href="#小区间排序优化" class="headerlink" title="小区间排序优化"></a>小区间排序优化</h4><p>也就是递归型的快排，是从头至尾一直是递归的，不断左右分段，像二叉树，不过即使到了最后几个数没有顺序，都要一直递归，于是想法是最后分割到数据到10个的时候用插排或选择解决，毕竟再用希尔和堆排序还要建堆和产生gap，那么又因为之前测过的插排优于选排，所以最后一个小区间里面就使用插排</p><blockquote><p>那么我们改变这个本体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传key值</span><span class="token comment">//左[begin,meeti-1] 右[meeti+1,end]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//1.如果这个区间是数据多，继续选key单趟，分割子区间</span><span class="token comment">//2.如果子区间数据量太小，再去递归不合适，不划算</span><span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort3</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左[begin,meeti-1] 右[meeti+1,end]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">InsertSort</span><span class="token punctuation">(</span>a <span class="token operator">+</span> begin<span class="token punctuation">,</span> end <span class="token operator">-</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然如果用编译器其实优化效果不是很明显，因为 编译器已经就递归做到了一些优化，但不像三数取中，优化来的好</p><p>==注意==：优化可以通过改变<code>end-begin</code>的值，具体多少要还是看数据的数量</p><h4 id="非递归快排"><a href="#非递归快排" class="headerlink" title="非递归快排"></a>非递归快排</h4><p>注意可以用栈也可以用队列，如果非递归就观察一下三数取中可能会有问题</p><blockquote><p>递归，现代编译器优化的比较好，性能问题不是很大，最大的问题在于，递归的深度太深，程序本身没问题，但是栈空间不够，导致栈溢出，只能改非递归==stack overflow警告==<span class="github-emoji"><span>😁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>如果能递归，还是递归，只要不会爆栈的话，递归还是香的</p></blockquote><p>改成非递归有两种方式：</p><ol><li>直接改循环，比如斐波那契数列</li><li>树遍历非递归和快排非递归，只能用栈模拟递归过程</li></ol><p>接下来我们用栈来模拟递归过程</p><blockquote><p>其实分治递归的思想和从栈中放入数据再取出来一样，不是递归，但是和递归很像</p><p>我们把单趟排序的区间给入栈，然后依次取栈里面的区间出来单趟排序，再循环需要处理的子区间入栈，直到栈为空。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">QuickSortNonR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>Stack st<span class="token punctuation">;</span><span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>right <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>left <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>keyi <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">StackDestroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：非递归方法中栈的实现就放在GitHub中，码上来显得文章冗长，所以不写上来了，那么后期也会就栈这个数据结构仔细展开</p></blockquote><p>如果用队列的话就有点像是层序遍历，用栈的话有点像是左子树走完再走you’zi’shu</p><h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260930643.gif" alt="在这里插入图片描述"></p><h2 id="基本想法-1"><a href="#基本想法-1" class="headerlink" title="基本想法"></a>基本想法</h2><p>先把这个区间分成两半，然后均分成两个数组进行排序，最后得出两个有序的子区间之后再归并在一起就成为了有序数组</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260930667.png" alt="image-20211208171230101"></p><p>怎么归并？</p><blockquote><p>设置左右指针两个互相比一比，取小的尾插到下面的数据，然后往后走，直到一个区间结束，再把另外一个区间尾插到结束</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260930688.png" alt="image-20211208172257306"></p></blockquote><p>但是要归并的前提是有序，如果我还是没有序怎么办？就继续拆拆拆</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260930353.png" alt="image-20211208172544007"></p><p>拆到一个的时候就是有序的，然后归并就可以了</p><p>那么也就是说这样一个区间经过这样的过程就是有序的了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260930875.png" alt="image-20211208172814824"></p><h2 id="实现归并排序"><a href="#实现归并排序" class="headerlink" title="实现归并排序"></a>实现归并排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">_MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//[left,mid] [mid+1,right]</span><span class="token function">_MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">_MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//两段有序子区间归并tmp，并拷贝回去</span><span class="token keyword">int</span> begin1 <span class="token operator">=</span> left<span class="token punctuation">,</span>end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token keyword">int</span> begin2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end2 <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin1<span class="token operator">&lt;=</span>end1<span class="token operator">&amp;&amp;</span>begin2<span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">//把剩下一个区间走完，两个区间总有一个没走完</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span><span class="token punctuation">{</span>tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span><span class="token punctuation">{</span>tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//归并完之后，拷回原数组</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">_MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        tmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cpp version</p><ol><li>开一个额外空间</li><li>获取mid，递归分到最小子区间</li><li>一步步回溯，进行归并</li><li>双指针比大小归并</li><li>剩下的没有归并完的直接归并</li><li>反过来这时候tmp修改</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">_MergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//分割</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//[begin, mid] [mid+1,end]</span><span class="token function">_MergeSort</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> mid <span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">_MergeSort</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//归并</span><span class="token keyword">int</span> begin1 <span class="token operator">=</span> begin<span class="token punctuation">,</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token keyword">int</span> begin2 <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end2 <span class="token operator">=</span> end<span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> begin<span class="token punctuation">;</span><span class="token comment">//printf("归并[%d,%d][%d,%d]\n", begin1, end1, begin2, end2);</span><span class="token comment">//比大小拷到数组</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin1<span class="token operator">&lt;=</span>end1 <span class="token operator">&amp;&amp;</span> begin2<span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//没走完的全部归并</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin1<span class="token operator">&lt;=</span>end1<span class="token punctuation">)</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//v = tmp;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>begin<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">_MergeSort</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并的复杂度"><a href="#归并的复杂度" class="headerlink" title="归并的复杂度"></a>归并的复杂度</h2><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td>归并排序</td><td>O(N*log^N^)</td><td align="center">O(N)</td></tr></tbody></table><p>release版海量数据排序，所需时间如下</p><blockquote><p>注：这里的快排是三数取中+Hoare</p></blockquote><p>100000数据</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931372.png" alt="image-20211208182032545"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931283.png" alt="image-20211208182259655"></p><p>1000000数据</p><p>这里忽略前三个排序</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931425.png" alt="image-20211208182404118"></p><h2 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h2><p>类似的，我们知道递归带给快排的问题，也会给归并排序带来，所以我们尝试用非递归方式实现归并排序</p><h3 id="思路和注意事项"><a href="#思路和注意事项" class="headerlink" title="思路和注意事项"></a>思路和注意事项</h3><h4 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h4><p>要一半一半分开这个区间，放入tmp中，然后再取回来放到a中，使开始的gap=1，然后每次gap翻一倍，每次以gap为大小的区间是有序的，直到最后总长一半</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>随着两两划分是有可能到最后一个只有一个数，<code>[i+gap,i+2*gap-1]</code>，也就是说第二个区间可能是不存在的</li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931781.png" alt="image-20211208214444692"></p><blockquote><p>那需要修改一下，不存在就不要归了</p></blockquote><ol start="2"><li><p>还有一种可能性是第二组区间有但是不完整<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931977.png" alt="image-20211208222554521"></p></li><li><p>还有一种可能性是第二组区间没有，第一组区间也不完整<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931178.png" alt="image-20211208222851834"><br>把1和3归为一类去处理，直接不去归并了</p></li></ol><p>要检查的是第二种可能，要修正一下</p><h3 id="修改1"><a href="#修改1" class="headerlink" title="修改1"></a>修改1</h3><p>如果修正方法是越界就把end–，但是还是会导致同样的数字被重复写</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// end1 越界，修正</span><span class="token keyword">if</span> <span class="token punctuation">(</span>end1 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>end1 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// begin2 越界，第二个区间不存在</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>begin2 <span class="token operator">=</span> n<span class="token punctuation">;</span>end2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204220937167.png" alt="image-20220422093720847"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204220944882.png" alt="image-20220422094457716"></p><p>发现这种问题实际上我们可以打一个条件断点来寻找问题</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 条件断点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin1 <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">&amp;&amp;</span> end1 <span class="token operator">==</span> <span class="token number">9</span> <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">==</span> <span class="token number">9</span> <span class="token operator">&amp;&amp;</span> end2 <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改2"><a href="#修改2" class="headerlink" title="修改2"></a>修改2</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 时间复杂度：O(N*logN) 空间复杂度：O(N)</span><span class="token keyword">void</span> <span class="token function">MergeSortNonR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 间距为gap是一组，两两归并</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> gap<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> begin1 <span class="token operator">=</span> i<span class="token punctuation">,</span> end1 <span class="token operator">=</span> i <span class="token operator">+</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> begin2 <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">,</span> end2 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// end1 越界，修正</span><span class="token keyword">if</span> <span class="token punctuation">(</span>end1 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>end1 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// begin2 越界，第二个区间不存在</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>begin2 <span class="token operator">=</span> n<span class="token punctuation">;</span>end2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// begin2 ok， end2越界，修正end2即可</span><span class="token keyword">if</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> end2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>end2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 条件断点</span><span class="token comment">/*if (begin1 == 8 &amp;&amp; end1 == 9 &amp;&amp; begin2 == 9 &amp;&amp; end2 == 9){int x = 0;}*/</span><span class="token comment">//printf("归并[%d,%d][%d,%d] -- gap=%d\n", begin1, end1, begin2, end2, gap);</span><span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">else</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">memcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>gap <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cpp version</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token comment">//类似于后序，不像快排好用栈，其实循环就可以</span><span class="token keyword">void</span> <span class="token function">MergeSortNonR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap<span class="token operator">&lt;</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//间距为gap的一组数据分组归并</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token operator">*</span>gap<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//修改越界现象，原因是gap*2一下子只能覆盖2的指数</span>            <span class="token keyword">int</span> begin1 <span class="token operator">=</span> i<span class="token punctuation">,</span> end1 <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//控制的是个数下标要-1</span>            <span class="token keyword">int</span> begin2 <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">,</span> end2 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//越界修正</span>            <span class="token comment">//end1越界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end1 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>                end1 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//begin2修正，第二个区间不存在，直接停止</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>begin2<span class="token operator">&gt;=</span>n<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                begin2 <span class="token operator">=</span> n<span class="token punctuation">;</span>                end2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//begin2 ok ,2区间end结束</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>begin2<span class="token operator">&lt;</span>n <span class="token operator">&amp;&amp;</span> end2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>                end2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">//比大小拷到数组</span>          <span class="token comment">//  printf("归并[%d,%d][%d,%d]\n", begin1, end1, begin2, end2);</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>                    tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                    tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//没走完的全部归并</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span>                tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>                tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        gap <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我们这里要提到外排序和内排序，如何对大数据文件进行排序</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260931286.png" alt="image-20211208225649476"></p><p><font>归并排序天然支持外排序</font></p><ul><li>举个栗子：</li></ul><p>假如我们有10亿个整数在文件中，需要排序,计算后大小约等于4个G，不能直接放在内存中运算假如我们的内存是0.5G</p><p>我们可以对文件每次读1/8，也就是512M到内存中去排序（这里的排序不能用归并，因为归并空间复杂度O（N），可以用快排），然后写到文件里，再继续重复这个过程，最后将这几个有序小文件分别读数进行归并，两两归就成为4个，再两两归，两两归，最后合成一个<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260932359.png" alt="image-20211209085241562"></p><blockquote><ol start="2"><li>第二种可能性是第一个文件和第二个文件归并，然后第二个和第三个文件归并大文件，最后使得</li></ol><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260932921.png" alt="image-20211209085428177"></p></blockquote><h1 id="5-计数排序"><a href="#5-计数排序" class="headerlink" title="5. 计数排序"></a>5. 计数排序</h1><p>计数排序有成为鸽巢原理，是对哈希直接定址法的变形应用</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260932751.gif" alt="a"></p><p>之前的排序都是比较大小来进行排序的，计数排序采取一种新思路，他的思想是</p><ol><li>统计相同元素出现个数</li><li>根据统计结果将序列回收到原来的序列中</li></ol><h2 id="基本想法-2"><a href="#基本想法-2" class="headerlink" title="基本想法"></a>基本想法</h2><p>如何统计每个数的次数<br>这里我们有一个A[i]数组，A[i]的值就是对Count数组该位置++</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sz<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>Count<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260932288.png" alt="image-20211209091009653"><br>然后根据count数组按照count数组的数据的下标和值是多少，产生相应值数量的下标区间<br>这个叫做绝对映射<br>注：<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260932376.png" alt="image-20211209091544170"><br>加入我给了如上几个数字，有一半多都没有映射，那我不可能去浪费0-9存空<br>所以我为什么不把下标为0的保存10然后下标为5的保存15，跳过1-9呢？<br>这就叫相对映射</p><p>那么因为绝对映射还是存在浪费的，所以在这里的计数排序我们采用相对映射</p><h2 id="实现计数排序"><a href="#实现计数排序" class="headerlink" title="实现计数排序"></a>实现计数排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> max <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>max <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>min <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> range <span class="token operator">=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token operator">+</span>min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cpp-version</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    T max <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    T min <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>max<span class="token operator">-</span>min<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        tmp<span class="token punctuation">[</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> range <span class="token operator">=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 排序</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            v<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>计数排序的复杂度</p><table><thead><tr><th>排序名</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>计数排序</td><td>O(N+range)</td><td>O(range)</td></tr></tbody></table><p>所以说其实是和range有关的,最好是这组数据中,数据的范围都比较集中,很适合用计数排序,这个排序还是很优秀的,也有局限性,该排序只适合整数,浮点数字符串都不行,数据不集中也不行</p><h1 id="分析八大排序"><a href="#分析八大排序" class="headerlink" title="分析八大排序"></a>分析八大排序</h1><h2 id="八大排序分析"><a href="#八大排序分析" class="headerlink" title="八大排序分析"></a>八大排序分析</h2><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202204210943012.png" alt="img"></p><blockquote><p>该表格不建议去背,而是应该去理解</p></blockquote><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><ul><li>什么是稳定性?</li></ul><p>数组中相同的值排完序之后,其相对位置不变,就是稳定,否则就是不稳定<br>eg:下面的数组中如果排完序之后橙5被换到蓝5后面去了,就是不稳定的,反之是稳定的<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260932475.png" alt="image-20211209124724412"></p><ul><li>那稳定的价值是什么呢?</li></ul><blockquote><p>比如说考试系统,考完之后要排名,考试的时候提交试卷以后自动判卷拿到成绩,成绩按照交卷顺序排到数组中,我们对数组排序,进行排名</p><p>要求:分数相同,先交卷的排在前面</p><p>如果稳定性差的排序肯定是可能会颠倒顺序,这不满足我们的要求</p></blockquote><blockquote><p>==注:==</p><ol><li><p>直接选择排序是不保证稳定的(保证选大的时候只选后一个大的,选小的可以选前面的那一个)</p><p>如果我们按照图中的要求去排序</p></li></ol><p><strong><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202203260933009.png" alt="image-20211209130542416"></strong></p><ol start="2"><li>希尔排序是不稳定的,因为有可能相同大小的值被放预排到了不同组里面去,很有可能变</li><li>堆排序不稳定,当建完堆之后,把root和最后一个叶子一换,就把顺序变了</li><li>快排不稳定,由于找大找小的过程中可能存在交换,一换顺序有可能发生变化</li></ol></blockquote><h2 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h2><p>就高效性来看的话,快排,堆排和归并都是<br>$$<br>O(N*log_2^N)<br>$$<br>综合来说最好的还是快排,堆排效率总体来说还是略慢快排,然后归并需要更多空间复杂度,另外希尔排序gap取值不同,效果不同</p><p>然后就是插入-&gt;冒泡-&gt;选择,选择很可惜是最次的</p><h1 id="摩拳擦掌"><a href="#摩拳擦掌" class="headerlink" title="摩拳擦掌"></a>摩拳擦掌</h1><h3 id="1-快速排序算法是基于（-）的一个排序算法。"><a href="#1-快速排序算法是基于（-）的一个排序算法。" class="headerlink" title="1. 快速排序算法是基于（ ）的一个排序算法。"></a>1. 快速排序算法是基于（ ）的一个排序算法。</h3><ul><li><input checked="" disabled="" type="checkbox"> 分治法</li><li><input disabled="" type="checkbox"> 贪心法</li><li><input disabled="" type="checkbox"> 递归法</li><li><input disabled="" type="checkbox"> 动态规划法</li></ul><h3 id="2-对记录（54-38-96-23-15-72-60-45-83）进行从小到大的直接插入排序时，当把第8个记录45插入到有序表时，为找到插入位置需比较（-）次？（采用从后往前比较）"><a href="#2-对记录（54-38-96-23-15-72-60-45-83）进行从小到大的直接插入排序时，当把第8个记录45插入到有序表时，为找到插入位置需比较（-）次？（采用从后往前比较）" class="headerlink" title="2. 对记录（54,38,96,23,15,72,60,45,83）进行从小到大的直接插入排序时，当把第8个记录45插入到有序表时，为找到插入位置需比较（ ）次？（采用从后往前比较）"></a>2. 对记录（54,38,96,23,15,72,60,45,83）进行从小到大的直接插入排序时，当把第8个记录45插入到有序表时，为找到插入位置需比较（ ）次？（采用从后往前比较）</h3><ul><li><input disabled="" type="checkbox"> 3</li><li><input disabled="" type="checkbox"> 4</li><li><input checked="" disabled="" type="checkbox"> 5</li><li><input disabled="" type="checkbox"> 6</li></ul><h3 id="3-以下排序方式中占用O（n）辅助存储空间的是"><a href="#3-以下排序方式中占用O（n）辅助存储空间的是" class="headerlink" title="3. 以下排序方式中占用O（n）辅助存储空间的是"></a>3. 以下排序方式中占用O（n）辅助存储空间的是</h3><ul><li><input disabled="" type="checkbox"> 简单排序</li><li><input disabled="" type="checkbox"> 快速排序</li><li><input disabled="" type="checkbox"> 堆排序</li><li><input checked="" disabled="" type="checkbox"> 归并排序</li></ul><h3 id="4-下列排序算法中稳定且时间复杂度为O-n-2-的是（-）"><a href="#4-下列排序算法中稳定且时间复杂度为O-n-2-的是（-）" class="headerlink" title="4.下列排序算法中稳定且时间复杂度为O(n^2^)的是（ ）"></a>4.下列排序算法中稳定且时间复杂度为O(n^2^)的是（ ）</h3><ul><li><input disabled="" type="checkbox"> 快速排序</li><li><input disabled="" type="checkbox"> 冒泡排序</li><li><input checked="" disabled="" type="checkbox"> 直接选择排序</li><li><input disabled="" type="checkbox"> 归并排序</li></ul><h3 id="5-关于排序，下面说法不正确的是"><a href="#5-关于排序，下面说法不正确的是" class="headerlink" title="5.关于排序，下面说法不正确的是"></a>5.关于排序，下面说法不正确的是</h3><ul><li><input disabled="" type="checkbox"> 快排时间复杂度为O(N*logN)，空间复杂度为O(logN)</li><li><input disabled="" type="checkbox"> 归并排序是一种稳定的排序,堆排序和快排均不稳定</li><li><input disabled="" type="checkbox"> 序列基本有序时，快排退化成冒泡排序，直接插入排序最快</li><li><input checked="" disabled="" type="checkbox"> 归并排序空间复杂度为O(N), 堆排序空间复杂度的为O(logN)</li></ul><h3 id="6-下列排序法中，最坏情况下时间复杂度最小的是（-）"><a href="#6-下列排序法中，最坏情况下时间复杂度最小的是（-）" class="headerlink" title="6.下列排序法中，最坏情况下时间复杂度最小的是（ ）"></a>6.下列排序法中，最坏情况下时间复杂度最小的是（ ）</h3><ul><li><input checked="" disabled="" type="checkbox"> 堆排序</li><li><input disabled="" type="checkbox"> 快速排序</li><li><input disabled="" type="checkbox"> 希尔排序</li><li><input disabled="" type="checkbox"> 冒泡排序</li></ul><blockquote><p>快排是不稳定的，快排时间复杂度最差是O(N^2^)</p></blockquote><h3 id="7-设一组初始记录关键字序列为-65-56-72-99-86-25-34-66-，则以第一个关键字65为基准而得到的一趟快速排序结果是（）-挖坑"><a href="#7-设一组初始记录关键字序列为-65-56-72-99-86-25-34-66-，则以第一个关键字65为基准而得到的一趟快速排序结果是（）-挖坑" class="headerlink" title="7.设一组初始记录关键字序列为(65,56,72,99,86,25,34,66)，则以第一个关键字65为基准而得到的一趟快速排序结果是（）(挖坑)"></a>7.设一组初始记录关键字序列为(65,56,72,99,86,25,34,66)，则以第一个关键字65为基准而得到的一趟快速排序结果是（）(挖坑)</h3><ul><li><input checked="" disabled="" type="checkbox"> 34，56，25，65，86，99，72，66</li><li><input disabled="" type="checkbox"> 25，34，56，65，99，86，72，66</li><li><input disabled="" type="checkbox"> 34，56，25，65，66，99，86，72</li><li><input disabled="" type="checkbox"> 34，56，25，65，99，86，72，66</li></ul><h3 id="8-排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。用冒泡排序对数列4-5-6-3-2-1进行升序排序，则第3趟之后的结果是（-）"><a href="#8-排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。用冒泡排序对数列4-5-6-3-2-1进行升序排序，则第3趟之后的结果是（-）" class="headerlink" title="8. 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。用冒泡排序对数列4 5 6 3 2 1进行升序排序，则第3趟之后的结果是（ ）"></a>8. 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。用冒泡排序对数列4 5 6 3 2 1进行升序排序，则第3趟之后的结果是（ ）</h3><ul><li><input disabled="" type="checkbox"> 4 3 2 1 5 6</li><li><input disabled="" type="checkbox"> 4 5 3 2 1 6</li><li><input disabled="" type="checkbox"> 2 1 3 4 5 6</li><li><input checked="" disabled="" type="checkbox"> 3 2 1 4 5 6<blockquote><p>冒泡是周围2个一次次排序交换，然后每一趟只做size-外层循环次</p></blockquote></li></ul><h3 id="9-使用选择排序对长度为100的数组进行排序，则比较的次数为（-）"><a href="#9-使用选择排序对长度为100的数组进行排序，则比较的次数为（-）" class="headerlink" title="9. 使用选择排序对长度为100的数组进行排序，则比较的次数为（ ）"></a>9. 使用选择排序对长度为100的数组进行排序，则比较的次数为（ ）</h3><ul><li><input checked="" disabled="" type="checkbox"> 5050</li><li><input disabled="" type="checkbox"> 4950</li><li><input disabled="" type="checkbox"> 4851</li><li><input disabled="" type="checkbox"> 2475<blockquote><p>选择排序，每次都要在未排序的所有元素中找到最值，如果有n个元素，则<br>第一次比较次数： n - 1<br>第二次比较次数： n - 2<br>….<br>第n - 1次比较次数： 1<br>所有如果n = 100<br>则比较次数的总和：99 + 98 + …… + 1<br>共4950次。</p></blockquote></li></ul><h3 id="10-有字符序列-FBJGEAIDCH，现在打算对它按字母的字典顺序用希尔排序进行排序，那么在第一趟后（步长为5）的序列为（-）"><a href="#10-有字符序列-FBJGEAIDCH，现在打算对它按字母的字典顺序用希尔排序进行排序，那么在第一趟后（步长为5）的序列为（-）" class="headerlink" title="10. 有字符序列 FBJGEAIDCH，现在打算对它按字母的字典顺序用希尔排序进行排序，那么在第一趟后（步长为5）的序列为（ ）"></a>10. 有字符序列 FBJGEAIDCH，现在打算对它按字母的字典顺序用希尔排序进行排序，那么在第一趟后（步长为5）的序列为（ ）</h3><ul><li><p><input disabled="" type="checkbox"> CAEBFDIGJH</p></li><li><p><input disabled="" type="checkbox"> AIDCHFBJGE</p></li><li><p><input checked="" disabled="" type="checkbox"> ABDCEFIJGH</p></li><li><p><input disabled="" type="checkbox"> BFJGEAIDCH</p></li></ul><h3 id="11-现有数字序列-5-11-7-2-3-17，目前要通过堆排序进行降序排序，那么由该序列建立的初始堆应为（-）"><a href="#11-现有数字序列-5-11-7-2-3-17，目前要通过堆排序进行降序排序，那么由该序列建立的初始堆应为（-）" class="headerlink" title="11. 现有数字序列 5 11 7 2 3 17，目前要通过堆排序进行降序排序，那么由该序列建立的初始堆应为（ ）"></a>11. 现有数字序列 5 11 7 2 3 17，目前要通过堆排序进行降序排序，那么由该序列建立的初始堆应为（ ）</h3><ul><li><p><input checked="" disabled="" type="checkbox"> 2 3 7 11 5 17</p></li><li><p><input disabled="" type="checkbox"> 17 11 7 2 3 5</p></li><li><p><input disabled="" type="checkbox"> 17 11 7 5 3 2</p></li><li><p><input disabled="" type="checkbox"> 2 3 5 7 11 17</p><blockquote><p>要降序排列，所以要建小堆，每次把堆顶元素放在当前堆的最后一个位置</p></blockquote></li></ul><h3 id="12-对数字序列28-16-32-12-60-2-5-72进行升序的快速排序（以第一个关键码为基准的方法），一次划分后的结果为（-）"><a href="#12-对数字序列28-16-32-12-60-2-5-72进行升序的快速排序（以第一个关键码为基准的方法），一次划分后的结果为（-）" class="headerlink" title="12. 对数字序列28 16 32 12 60 2 5 72进行升序的快速排序（以第一个关键码为基准的方法），一次划分后的结果为（ ）"></a>12. 对数字序列28 16 32 12 60 2 5 72进行升序的快速排序（以第一个关键码为基准的方法），一次划分后的结果为（ ）</h3><ul><li><input disabled="" type="checkbox"> 2 5 12 16 28 60 32 72</li><li><input checked="" disabled="" type="checkbox"> 2 16 5 12 28 60 32 72</li><li><input disabled="" type="checkbox"> 2 16 12 5 28 60 32 72</li><li><input disabled="" type="checkbox"> 5 16 2 12 28 32 60 72<blockquote><p>建堆要进行向下调整算法（从最后一个非叶子节点开始进行向下调整算法，直到根元素）<br>快速排序以基准值为中心，对元素进行划分，这里以28为基准值，则小于28的和大于28的进行交换，完成一次划分<br>首先：32和5交换： 28 16 5 12 60 2 32 72<br>然后60和2交换：  28 16 5 12 2 60 32 72<br>最后28和最后一个小于28的元素进行交换：2 16 5 12 28 60 32 72</p></blockquote></li></ul><h3 id="13-下列选项中，不可能是快速排序第2趟排序后的结果的是（-）"><a href="#13-下列选项中，不可能是快速排序第2趟排序后的结果的是（-）" class="headerlink" title="13. 下列选项中，不可能是快速排序第2趟排序后的结果的是（ ）"></a>13. 下列选项中，不可能是快速排序第2趟排序后的结果的是（ ）</h3><ul><li><input disabled="" type="checkbox"> 2 3 5 4 6 7 9</li><li><input disabled="" type="checkbox"> 2 7 5 6 4 3 9</li><li><input checked="" disabled="" type="checkbox"> 3 2 5 4 7 6 9</li><li><input disabled="" type="checkbox"> 4 2 3 5 7 6 9<blockquote><p>快排的阶段性排序结果的特点是，第i趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，它右边的数都比它大。题目问第二趟排序的结果，即要找不存在2个这样的数的选项。<br>A: 第一趟的基准值可以为2， 第二趟的基准值可以为3<br>B: 第一趟的基准值可以为2， 第二趟的基准值可以为9<br>C: 第一趟的基准值只能是9，但是第二趟的基准值就找不出来，没有符合要求的值作为基准值，所以不可能是一个中间结果。<br>D: 第一趟的基准值可以为9， 第二趟的基准值可以为5</p></blockquote></li></ul><h4 id="14-以下哪种排序算法对-1-3-2-4-5-6-7-8-9-进行排序最快（-）"><a href="#14-以下哪种排序算法对-1-3-2-4-5-6-7-8-9-进行排序最快（-）" class="headerlink" title="14. 以下哪种排序算法对[1, 3, 2, 4, 5, 6, 7, 8, 9]进行排序最快（ ）"></a>14. 以下哪种排序算法对[1, 3, 2, 4, 5, 6, 7, 8, 9]进行排序最快（ ）</h4><ul><li><p><input checked="" disabled="" type="checkbox"> 直接插入排序</p></li><li><p><input disabled="" type="checkbox"> 快速排序</p></li><li><p><input disabled="" type="checkbox"> 归并排序</p></li><li><p><input disabled="" type="checkbox"> 堆排序</p></li></ul><blockquote><p>顺序有序最好的是直接插入排序复杂度是O(N)</p></blockquote><h4 id="15-下面的排序算法中，初始数据集的排列顺序对算法的性能无影响的有（-）"><a href="#15-下面的排序算法中，初始数据集的排列顺序对算法的性能无影响的有（-）" class="headerlink" title="15. 下面的排序算法中，初始数据集的排列顺序对算法的性能无影响的有（ ）"></a>15. 下面的排序算法中，初始数据集的排列顺序对算法的性能无影响的有（ ）</h4><p>① 快速排序</p><p>② 希尔怕徐</p><p>③ 插入排序</p><p>④ 堆排序</p><p>⑤ 归并排序</p><p>⑥ 选择排序</p><ul><li><input disabled="" type="checkbox"> ①④⑤</li><li><input checked="" disabled="" type="checkbox"> ④⑤⑥</li><li><input disabled="" type="checkbox"> ②③⑥</li><li><input disabled="" type="checkbox"> ②③⑤⑥</li></ul><h3 id="16-用某种排序方法对关键字序列-25-84-21-47-15-27-68-35-20-进行排序，序列的变化情况采样如下："><a href="#16-用某种排序方法对关键字序列-25-84-21-47-15-27-68-35-20-进行排序，序列的变化情况采样如下：" class="headerlink" title="16. 用某种排序方法对关键字序列 25 84 21 47 15 27 68 35 20 进行排序，序列的变化情况采样如下："></a>16. 用某种排序方法对关键字序列 25 84 21 47 15 27 68 35 20 进行排序，序列的变化情况采样如下：</h3><p>20 15 21 25 47 27 68 35 84</p><p>15 20 21 25 35 27 47 68 84</p><p>15 20 21 25 27 35 47 68 84</p><p>请问采用的是以下哪种排序算法（ ）</p><ul><li><p><input disabled="" type="checkbox"> 选择排序</p></li><li><p><input disabled="" type="checkbox"> 希尔排序</p></li><li><p><input disabled="" type="checkbox"> 归并排序</p></li><li><p><input checked="" disabled="" type="checkbox"> 快速排序</p></li></ul><blockquote><p> 对于八大排序算法的源代码如有需要，可以到我的GitHub查看<a href="https://github.com/Allen9012/elementary-data-structure/tree/main/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">八大排序算法</a>，如果大家觉得有收获的话，请给我点赞，关注和收藏吧，谢谢支持<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八大排序算法&quot;&gt;&lt;a href=&quot;#八大排序算法&quot; class=&quot;headerlink&quot; title=&quot;八大排序算法&quot;&gt;&lt;/a&gt;八大排序算法&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloudmage.oss-cn-shangh</summary>
      
    
    
    
    
    <category term="数据结构和算法" scheme="https://allen9012.github.io/BlogNet/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hash 容器</title>
    <link href="https://allen9012.github.io/BlogNet/2022/09/04/Hash-%E5%AE%B9%E5%99%A8/"/>
    <id>https://allen9012.github.io/BlogNet/2022/09/04/Hash-%E5%AE%B9%E5%99%A8/</id>
    <published>2022-09-04T01:26:56.000Z</published>
    <updated>2022-09-04T01:27:38.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091927697.jpg" alt="BingWallpaper29"></p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>[toc]</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205302000044.png" alt="image-20220530200053766"></p><h2 id="1-unordered系列关联式容器"><a href="#1-unordered系列关联式容器" class="headerlink" title="1. unordered系列关联式容器"></a>1. unordered系列关联式容器</h2><p>在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到logN，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091242639.png" alt="image-20220509124203576"></p><p>同样的容器在Java中就很接地气</p><table><thead><tr><th>c++</th><th>Java</th></tr></thead><tbody><tr><td>map</td><td>TreeMap</td></tr><tr><td>set</td><td>TreeSet</td></tr><tr><td>unordered_map</td><td>HashMap</td></tr><tr><td>unordered_set</td><td>HashSet</td></tr></tbody></table><h2 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2. unordered_map"></a>2. unordered_map</h2><h3 id="2-1-unordered-map快速入门"><a href="#2-1-unordered-map快速入门" class="headerlink" title="2.1 unordered_map快速入门"></a>2.1 unordered_map快速入门</h3><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091934716.png" alt="image-20220509193444666"></p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> unordered_map是存储<key, value="">键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。</key,><br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在内部,unordered_map没有对<kye, value="">按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。</kye,><br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> unordered_maps实现了直接访问操作符<code>(operator[])</code>，它允许使用key作为参数直接访问value。<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 它的迭代器至少是前向接口迭代器。</p><h3 id="2-2-unordered-map常用接口"><a href="#2-2-unordered-map常用接口" class="headerlink" title="2.2 unordered_map常用接口"></a>2.2 unordered_map常用接口</h3><p>哈希表的话其实和map和set的诸多接口都是类似的</p><h4 id="2-2-1-unordered-map"><a href="#2-2-1-unordered-map" class="headerlink" title="2.2.1 unordered_map()"></a>2.2.1 unordered_map()</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>unordered_map()</td><td>构造不同格式的unordered_map对象</td></tr></tbody></table><h4 id="2-2-2-unordered-map-capacity"><a href="#2-2-2-unordered-map-capacity" class="headerlink" title="2.2.2 unordered_map capacity"></a>2.2.2 unordered_map capacity</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>bool empty() const</td><td>检测unordered_map是否为空</td></tr><tr><td>size_t size() const</td><td>获取unordered_map的有效元素个数</td></tr></tbody></table><h4 id="2-2-3-unordered-map-iterator"><a href="#2-2-3-unordered-map-iterator" class="headerlink" title="2.2.3 unordered_map:: iterator"></a>2.2.3 unordered_map:: iterator</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>begin</td><td>返回unordered_map第一个元素的迭代器</td></tr><tr><td>end</td><td>返回unordered_map最后一个元素下一个位置的迭代器</td></tr><tr><td>cbegin</td><td>返回unordered_map第一个元素的const迭代器</td></tr><tr><td>cend</td><td>返回unordered_map最后一个元素下一个位置的const迭代器</td></tr></tbody></table><p>所有的容器使用迭代器遍历的时候都是类似的方式</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token operator">++</span>it<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>范围for也是一样的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> us<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-element元素访问"><a href="#2-2-4-element元素访问" class="headerlink" title="2.2.4 element元素访问"></a>2.2.4 element元素访问</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>operator[]</td><td>返回与key对应的value，没有一个默认值</td></tr></tbody></table><p>该函数中实际调用哈希桶的插入操作，用参数key与V()构造一个默认值往底层哈希桶中插入，如<br>果key不在哈希桶中，插入成功，返回V()，插入失败，说明key已经在哈希桶中，将key对应的value返回。</p><h4 id="2-2-5-Element-lookup"><a href="#2-2-5-Element-lookup" class="headerlink" title="2.2.5 Element lookup"></a>2.2.5 Element lookup</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>iterator find(const K&amp; key)</td><td>返回key在哈希桶中的位置</td></tr><tr><td>size_t count(const K&amp; key)</td><td>返回哈希桶中关键码为key的键值对的个数</td></tr></tbody></table><p>由于unordered_map中key是不能重复的，因此count函数的返回值最大为1</p><h5 id="herb-find"><a href="#herb-find" class="headerlink" title=":herb:find"></a><span class="github-emoji"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>find</h5><p>其实我们的查找是由两种方法的</p><p><span class="github-emoji"><span>🌸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f338.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果是哈希表的专有查找</p><p>优点是：利用率hash特性，效率很高– O(1)</p><p><span class="github-emoji"><span>🌸</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f338.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果是使用通用算法（来自于<code>&lt;algorithm&gt;</code>）</p><p>优点：每个容器都可以使用，泛型算法。 缺点：暴力查找  – O(N)</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>p.s. 如果使用的不是hash的而是普通的set的话，那么红黑树查找效率是O(logN)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// unordered_set专用查找算法。优点：使用哈希特性去查找，效率高 -- O(1)  </span><span class="token comment">// 类似如果是set的，效率是O(logN)</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通用算法，优点：每个容器都可以使用，泛型算法。 缺点：暴力查找  -- O(N)</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>us<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> us<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"找到了"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"找不到"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-6-Modifiers"><a href="#2-2-6-Modifiers" class="headerlink" title="2.2.6 Modifiers"></a>2.2.6 Modifiers</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/insert/"><strong>insert</strong></a></td><td>Insert elements (public member function )</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/erase/"><strong>erase</strong></a></td><td>Erase elements (public member function )</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/clear/"><strong>clear</strong></a></td><td>Clear content (public member function )</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/swap/"><strong>swap</strong></a></td><td>Swap content (public member function)</td></tr></tbody></table><h4 id="2-2-7-Buckets"><a href="#2-2-7-Buckets" class="headerlink" title="2.2.7 Buckets"></a>2.2.7 Buckets</h4><table><thead><tr><th>函数声明</th><th>功能介绍</th></tr></thead><tbody><tr><td>size_t <strong>bucket_count</strong>()const</td><td>返回哈希桶中桶的总个数</td></tr><tr><td>size_t <strong>bucket_size</strong>(size_t n)const</td><td>返回n号桶中有效元素的总个数</td></tr><tr><td>size_t <strong>bucket</strong>(const K&amp; key)</td><td>返回元素key所在的桶号</td></tr><tr><td>size_t <strong>max_bucket_count()</strong> const</td><td>返回潜在可拥有的最大桶数</td></tr></tbody></table><h4 id="2-2-8-Hash-policy"><a href="#2-2-8-Hash-policy" class="headerlink" title="2.2.8 Hash policy"></a>2.2.8 Hash policy</h4><table><thead><tr><th><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/load_factor/"><strong>load_factor</strong></a></th><th>当前负载因子</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/max_load_factor/"><strong>max_load_factor</strong></a></td><td>容器的当前最大负载因子</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/rehash/"><strong>rehash</strong></a></td><td>相当于reserve，预留空间，将容器中的桶数设置为<em>n</em>或更多</td></tr><tr><td><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/reserve/"><strong>reserve</strong></a></td><td>将容器中的桶数设置为最适合包含至少n 个元素的桶数</td></tr></tbody></table><h2 id="3-unordered-set"><a href="#3-unordered-set" class="headerlink" title="3. unordered_set"></a>3. unordered_set</h2><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205092007265.png" alt="image-20220509200751201"></p><p>类似结合set和unordered_map</p><h2 id="4-unordered-V-S-ordered"><a href="#4-unordered-V-S-ordered" class="headerlink" title="4. unordered V.S. ordered"></a>4. unordered V.S. ordered</h2><p>下面通过一段代码，来演示一下差别</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> us<span class="token punctuation">;</span>    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>    size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"set insert:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_set insert:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    size_t begin3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t begin4 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end4 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"set find:"</span> <span class="token operator">&lt;&lt;</span> end3 <span class="token operator">-</span> begin3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_set find:"</span> <span class="token operator">&lt;&lt;</span> end4 <span class="token operator">-</span> begin4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    size_t begin5 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end5 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t begin6 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        us<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size_t end6 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"set erase:"</span> <span class="token operator">&lt;&lt;</span> end5 <span class="token operator">-</span> begin5 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unordered_set erase:"</span> <span class="token operator">&lt;&lt;</span> end6 <span class="token operator">-</span> begin6 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205101919853.png" alt="image-20220510191942796"></p><p>可见unordered_map的效率是显著的高的</p><h2 id="Hash底层"><a href="#Hash底层" class="headerlink" title="Hash底层"></a>Hash底层</h2><p>unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。Hash结构其实又可以叫散列结构，本质上是一种建立映射，计数排序中可以说就是用到了哈希</p><p>Hash是一种数学函数，可将任意长度的输入转换为固定长度的加密输出。因此，无论所涉及的原始数据量或文件大小如何，其唯一的哈希值始终是相同的大小。此外，散列不能用于“逆向工程”来自散列输出的输入，因为散列函数是“单向”的（就像绞肉机；你不能把碎牛肉放回牛排中）。尽管如此，如果您对相同的数据使用这样的函数，它的哈希值将是相同的，因此如果您已经知道它的哈希值，您可以验证数据是否相同（即未更改）。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205112014478.png" alt="image-20220511201434374"></p><h3 id="Intro-of-Hash"><a href="#Intro-of-Hash" class="headerlink" title="Intro of Hash"></a>Intro of Hash</h3><h4 id="非哈希"><a href="#非哈希" class="headerlink" title="非哈希"></a>非哈希</h4><p><strong>顺序结构以及平衡树</strong>中，元素关键码与其存储位置之间没有对应的关系，因此**在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(logN)**，搜索的效率取决于搜索过程中元素的比较次数。</p><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。</p><p><span class="github-emoji"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 插入元素<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放<br><span class="github-emoji"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 搜索元素<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功</p><p><span alt="modern">该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)</span></p><h3 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h3><p>引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则：<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哈希函数计算出来的地址能均匀分布在整个空间中<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哈希函数应该比较简单</p><h4 id="直接定址法-常用"><a href="#直接定址法-常用" class="headerlink" title="直接定址法(常用)"></a>直接定址法(常用)</h4><p>取关键字的某个线性函数为散列地址：<br>$$<br>Hash(Key)= A*Key + B<br>$$</p><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 优点：简单、均匀 ，速度快O(1)</p><p><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 缺点：需要事先知道关键字的分布情况， 不能处理浮点数，字符串等等，如果给定一个很大范围，会浪费很多空间</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：适合查找比较小且连续的情况，只能是整数，而且数据范围比较集中 </p><h4 id="除留余数法-常用"><a href="#除留余数法-常用" class="headerlink" title="除留余数法(常用)"></a>除留余数法(常用)</h4><p>设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：<br>$$<br>Hash(key) = key\  %\ p   \ (p&lt;=m)<br>$$<br>将关键码转换成哈希地址</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205102204698.png" alt="image-20220510220448631"></p><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 优点：数据范围可以很大，使用场景一下子广起来了</p><p><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 缺点：不同的值会映射到同一个位置上：哈希冲突，冲突越多，效率下降越厉害</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：数据范围很大</p><h4 id="平方取中法-少用"><a href="#平方取中法-少用" class="headerlink" title="平方取中法(少用)"></a>平方取中法(少用)</h4><p>假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；</p><p>再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 </p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：不知道关键字的分布，而位数又不是很大的情况</p><h4 id="折叠法-少用"><a href="#折叠法-少用" class="headerlink" title="折叠法(少用)"></a>折叠法(少用)</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加<br>求和，并按散列表表长，取后几位作为散列地址。</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：事先不需要知道关键字的分布，适合关键字位数比较多的情况</p><h4 id="随机数法-少用"><a href="#随机数法-少用" class="headerlink" title="随机数法(少用)"></a>随机数法(少用)</h4><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为<br>随机数函数。</p><p><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：通常应用于关键字长度不等时采用此法</p><h4 id="数学分析法-少用"><a href="#数学分析法-少用" class="headerlink" title="数学分析法(少用)"></a>数学分析法(少用)</h4><p>设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。</p><p>假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是 相同的，那么我<br>们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现 冲突，还可以对抽取出来的数字<br>进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移位、前两数与后两数叠加(如1234改<br>成12+34=46)等方法。<br><span class="github-emoji"><span>🎲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 使用场景：通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布<br>较均匀的情况 </p><blockquote><p>哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</p></blockquote><h3 id="Hash-collision"><a href="#Hash-collision" class="headerlink" title="Hash collision"></a>Hash collision</h3><p>哈希冲突是哈希表中的两条数据共享相同的哈希值。 在这种情况下，哈希值来自一个哈希函数，该函数接受数据输入并返回固定长度的位。</p><p>尽管哈希算法的创建是为了防止冲突，但它们有时仍然可以将不同的数据映射到同一个哈希（根据<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">鸽巢原理</a>）。恶意用户可以利用这一点来模仿、访问或更改数据</p><p>对于两个数据元素的关键字k<sub>i</sub> 和k<sub>j</sub>和 (i != j)，有k<sub>i</sub> != k<sub>j</sub> ，但有：<br>$$<br>Hash(k_i) ==Hash(k_j)<br>$$<br>即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。<br>我们把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。</p><h2 id="Resolve-Hash-collisions"><a href="#Resolve-Hash-collisions" class="headerlink" title="Resolve Hash collisions"></a>Resolve Hash collisions</h2><p>解决哈希冲突两种常见的方法是：闭散列和开散列</p><p>当发生Collision时，Chaining会将所有被Hash Function分配到同一格slot的资料透过Linked list串起来，像是在书桌的抽屉下面绑绳子般，把所有被分配到同一格抽屉的物品都用绳子吊在抽屉下面。</p><p>相较于Chaining提供额外空间(node)来存放被分配到相同slot的资料，Open Addressing则是将每笔资料都放在书桌(Table)本身配备的抽屉(slot)，一格抽屉只能放一个物品，如果抽屉都满了，就得换张书桌(重新配置记忆体给新的Table)。</p><h3 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h3><p><strong>闭散列：也叫开放定址法，在开放空间内找一个位置定值，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。</strong></p><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>已知模出来映射的位置已经冲突，那线性探测的想法很简单，我们采用一个固定大小的哈希表，每次遇到哈希冲突时，我们以循环方式线性遍历该表以找到下一个空槽。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">0</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">2</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">4</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token function">H</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token number">5</span><span class="token operator">%</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205110931435.png" alt="image-20220511093148389"></p><p>在这种情况下，我们的哈希函数可以被认为是：<br>$$<br>H(x, i) = (H(x) + i)%len<br>$$<br>其中 N 是表的大小，i 表示从 1 开始的线性递增变量（直到找到空桶）。</p><p>我们可以发现空间越大冲突的可能性会越小，然而，冲突还是会存在，没有被完全解决</p><h5 id="线性探测举例"><a href="#线性探测举例" class="headerlink" title="线性探测举例"></a>线性探测举例</h5><p>下面的哈希函数取得是：<br>$$<br>Hash(key) = key%len + i<br>$$<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205111006501.png" alt="image-20220511100608445"></p><h5 id="线性探测优缺点"><a href="#线性探测优缺点" class="headerlink" title="线性探测优缺点"></a>线性探测优缺点</h5><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 优点：实现非常简单<br><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 缺点：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即：不同关键码占据<br>了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降低。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题</p><p>这种方法处于高速缓存性能和集群问题的中间。总体思路保持不变，唯一的区别是我们在寻找空桶时查看每次迭代的 Q(i) 增量，其中 Q(i) 是 i 的某个二次表达式。Q 的一个简单表达式是 Q(i) = i^2^，在这种情况下，哈希函数看起来像这样：<br>$$<br>H(x, i) = (H(x) + i^2)%len<br>$$</p><h5 id="二次探测举例"><a href="#二次探测举例" class="headerlink" title="二次探测举例"></a>二次探测举例</h5><p>下面的哈希函数取得是：<br>$$<br>Hash(key)=key%len+i^2<br>$$<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205111004110.png" alt="image-20220511100437056"></p><blockquote><p>如果加太多超过了capacity，又会从头开始找，相当于再mod一下capacity</p></blockquote><h5 id="二次探测优缺点"><a href="#二次探测优缺点" class="headerlink" title="二次探测优缺点"></a>二次探测优缺点</h5><p>二次探测可以解决数据“堆积”</p><h3 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h3><p>开散列法又叫链地址法(开链法)，也可一叫做哈希桶首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205112015952.png" alt="image-20220511201501850"></p><p>本质上我们可以看出来，它就是一个指针数组 </p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>哈希表总是需要扩容的，这里就涉及到了负载因子</p><p><strong>负载因子/载荷因子=存储的有效个数/空间的大小</strong></p><p><span class="github-emoji"><span>#⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0023-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 负载因子越大，冲突的概率越高，增删改查的效率越低</p><p><span class="github-emoji"><span>#⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0023-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 负载因子越小，冲突的概率越高，增删改查的效率越高，但是空间的浪费越多，利用率越低</p><h5 id="闭散列-1"><a href="#闭散列-1" class="headerlink" title="闭散列"></a>闭散列</h5><blockquote><p>研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122052429.png" alt="image-20220512205202349"></p><h5 id="开散列-1"><a href="#开散列-1" class="headerlink" title="开散列"></a>开散列</h5><p>已知桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希表进行增容，那该条件怎么确认呢？<strong>开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容。</strong></p><blockquote><p>还是要控制一个负载因子，负载因子越小，冲突概率越低，效率越高，但是浪费的空间越多，反之冲突概率越高，效率越低</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122045951.png"></p><h4 id="素数优化"><a href="#素数优化" class="headerlink" title="素数优化"></a>素数优化</h4><p>有人说，除留余数法，最好模一个素数，这次不是直接扩容翻倍那么如何每次快速取一个类似两倍关系的素数，STL源码中给出了如下的操作，记录下了一些素数，就可以更好的解决冲突</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> PRIMECOUNT <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span><span class="token keyword">const</span> size_t primeList<span class="token punctuation">[</span>PRIMECOUNT<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token number">53ul</span><span class="token punctuation">,</span> <span class="token number">97ul</span><span class="token punctuation">,</span> <span class="token number">193ul</span><span class="token punctuation">,</span> <span class="token number">389ul</span><span class="token punctuation">,</span> <span class="token number">769ul</span><span class="token punctuation">,</span>    <span class="token number">1543ul</span><span class="token punctuation">,</span> <span class="token number">3079ul</span><span class="token punctuation">,</span> <span class="token number">6151ul</span><span class="token punctuation">,</span> <span class="token number">12289ul</span><span class="token punctuation">,</span> <span class="token number">24593ul</span><span class="token punctuation">,</span>    <span class="token number">49157ul</span><span class="token punctuation">,</span> <span class="token number">98317ul</span><span class="token punctuation">,</span> <span class="token number">196613ul</span><span class="token punctuation">,</span> <span class="token number">393241ul</span><span class="token punctuation">,</span> <span class="token number">786433ul</span><span class="token punctuation">,</span>    <span class="token number">1572869ul</span><span class="token punctuation">,</span> <span class="token number">3145739ul</span><span class="token punctuation">,</span> <span class="token number">6291469ul</span><span class="token punctuation">,</span> <span class="token number">12582917ul</span><span class="token punctuation">,</span> <span class="token number">25165843ul</span><span class="token punctuation">,</span>    <span class="token number">50331653ul</span><span class="token punctuation">,</span> <span class="token number">100663319ul</span><span class="token punctuation">,</span> <span class="token number">201326611ul</span><span class="token punctuation">,</span> <span class="token number">402653189ul</span><span class="token punctuation">,</span> <span class="token number">805306457ul</span><span class="token punctuation">,</span>    <span class="token number">1610612741ul</span><span class="token punctuation">,</span> <span class="token number">3221225473ul</span><span class="token punctuation">,</span> <span class="token number">4294967291ul</span><span class="token punctuation">}</span><span class="token punctuation">;</span>size_t <span class="token function">GetNextPrime</span><span class="token punctuation">(</span>size_t prime<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PRIMECOUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> prime<span class="token punctuation">)</span>        <span class="token keyword">return</span> primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-开散列-V-S-闭散列"><a href="#6-4-开散列-V-S-闭散列" class="headerlink" title="6.4 开散列 V.S. 闭散列"></a>6.4 开散列 V.S. 闭散列</h3><p>实际当中哈希桶结构其实相对来说更加实用</p><table><thead><tr><th>Situation</th><th>哈希桶（开散列）</th><th>闭散列</th><th>描述</th></tr></thead><tbody><tr><td>空间</td><td>空间利用率高</td><td>略低</td><td>负载因子哈希桶可以大一点</td></tr><tr><td>极端情况</td><td>极端情况还有解决方案</td><td>极端情况不好解决</td><td>极端情况是数据不多，负载因子很低，但是这些数据还是大部分冲突了</td></tr><tr><td>解决方案</td><td>冲突数据过多的桶，进行红黑树树化（Java）</td><td>解决不了</td><td>树化操作</td></tr></tbody></table><p>Java中的解决方案</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122113688.png" alt="image-20220512211357503"></p><blockquote><p>当然如果数据被删除到小于8的时候也要把数据还原成链表</p></blockquote><p>类似的我们可以这么写</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205122140672.png" alt="image-20220512214014603"></p><p>如何统计个数，其实每次插入的时候都需要遍历一遍链表，这时如果还是链表的话，可以计算长度</p><p>第二种实现方式是一种复用，一种封装，写起来稍微简单一点，如果forward_list超过8就可以把数据导入到set里面去</p><p>拓展阅读：</p><p><a href="https://www.cnblogs.com/leoo2sk/archive/2010/10/01/hash-and-encrypt.html">哈希与加密</a></p><p><a href="https://www.cnblogs.com/lpfuture/p/5796398.html">一致性Hash算法原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205091927697.jpg&quot; alt=&quot;BingWallpaper29&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Hash&quot;&gt;&lt;a href=&quot;#Hash</summary>
      
    
    
    
    
    <category term="高阶数据结构 Hash" scheme="https://allen9012.github.io/BlogNet/tags/%E9%AB%98%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Hash/"/>
    
  </entry>
  
  <entry>
    <title>Red-Black Tree</title>
    <link href="https://allen9012.github.io/BlogNet/2022/09/03/Red-Black-Tree/"/>
    <id>https://allen9012.github.io/BlogNet/2022/09/03/Red-Black-Tree/</id>
    <published>2022-09-03T02:26:29.000Z</published>
    <updated>2022-09-03T02:29:31.775Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205040918814.jpg" alt="BingWallpaper27"></p><p>[toc]</p><h1 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h1><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205200902972.png" alt="image-20220520090154798"></p><h2 id="0-Intro"><a href="#0-Intro" class="headerlink" title="0.Intro"></a>0.Intro</h2><p><strong>红黑树</strong>是一种自平衡二叉搜索树。每个节点存储一个表示“颜色”（“红色”或“黑色”）的额外位，用于确保树在插入和删除期间保持平衡。当树被修改时，新树被重新排列并“重新绘制”以恢复限制树在最坏情况下可能变得多么不平衡的着色属性。这些属性被设计成可以有效地执行这种重新排列和重新着色。</p><blockquote><p>From <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree</a></p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205042105325.png" alt="image-20220504210510276"></p><h2 id="1-Red-Black-Tree"><a href="#1-Red-Black-Tree" class="headerlink" title="1. Red-Black Tree"></a>1. Red-Black Tree</h2><p>通过对任何一条从根到叶子的路径上各个结点着色方式的限制，==红黑树确保没有一条路径会比其他路径长出两倍==，因而是接近平衡的。接近平衡其实比平衡更好一点，因为相对平衡对于计算机来说实际上差别不大（对计算机来说其实logN和2logN差别不是很大），但是严格平衡是通过不断旋转来提高效率的，基于这样的原因，红黑树效率不必AVL差，但是反而旋转更少，因此总体效率更优，因此现在使用红黑树更多一点，而不是AVL树</p><h3 id="1-1-红黑树的性质"><a href="#1-1-红黑树的性质" class="headerlink" title="1.1  红黑树的性质"></a>1.1  红黑树的性质</h3><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 每个结点不是红色就是黑色<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 根节点是黑色的<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果一个节点是红色的，则它的两个孩子结点是黑色的(<strong>没有连续的红色节点</strong>)<br><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<strong>每条路上包含相同数量黑色节点</strong>）</p><p>每个叶子结点都是黑色的(==此处的叶子结点指的是空结点/NIL==)</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051231892.png" alt="image-20220505123105834"></p><h3 id="1-2-红黑树推论"><a href="#1-2-红黑树推论" class="headerlink" title="1.2 红黑树推论"></a>1.2 红黑树推论</h3><p><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 路径：<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最短路径：全部由黑色节点构成<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最长路径：一黑一红，黑色节点数量等于红色节点<br><span class="github-emoji"><span>🐉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f409.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 假设黑色节点有N个：<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最短路径长度：logN<br>    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最长路径长度：2logN</p><h2 id="2-实现红黑树"><a href="#2-实现红黑树" class="headerlink" title="2. 实现红黑树"></a>2. 实现红黑树</h2><h3 id="2-0-红黑树节点结构"><a href="#2-0-红黑树节点结构" class="headerlink" title="2.0 红黑树节点结构"></a>2.0 红黑树节点结构</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    RED<span class="token punctuation">,</span>    BLACK<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">RBTreeNode</span><span class="token punctuation">{</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _left<span class="token punctuation">;</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _right<span class="token punctuation">;</span>    RBTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">*</span> _parent<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _kv<span class="token punctuation">;</span>    Color _col<span class="token punctuation">;</span>    <span class="token function">RBTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token operator">&amp;</span>  kv<span class="token punctuation">)</span>    <span class="token operator">:</span><span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_parent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_kv</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span>    <span class="token punctuation">,</span><span class="token function">_col</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候我们有一个问题，为什么要将节点的默认颜色给成红色的？</p><p>黑的好还是红的好?</p><blockquote><p>插入红的会破坏规则：</p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果一个节点是红色的，则它的两个孩子结点是黑色的(<strong>没有连续的红色节点</strong>)</p><p>插入黑的会破坏规则：</p><p><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（<strong>每条路上包含相同数量黑色节点</strong>）</p></blockquote><p>我们选择消耗低的，还是插入默认红的比较好</p><h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert"></a>2.2 Insert</h3><h4 id="2-2-0-处理搜索部分"><a href="#2-2-0-处理搜索部分" class="headerlink" title="2.2.0 处理搜索部分"></a>2.2.0 处理搜索部分</h4><p>搜索树部分类似于AVL和BSTree的插入逻辑</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//空树</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token comment">//根必须是黑的</span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span><span class="token comment">//1. 找适当的空位置</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span><span class="token comment">//重复</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//2. cur走到空 可以链接</span>Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>newnode<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">{</span>    parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span>cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//处理</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>kv<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键是处理红黑节点</p><h4 id="2-2-1-处理红黑节点"><a href="#2-2-1-处理红黑节点" class="headerlink" title="2.2.1 处理红黑节点"></a>2.2.1 处理红黑节点</h4><p>因为新节点的默认颜色是红色，因此：如果其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不<br>需要调整；但当新插入节点的双亲节点颜色为红色时，就违反了性质三不能有连在一起的红色节点，此<br>时需要对红黑树分情况来讨论：</p><table><thead><tr><th>parent.color</th><th>条件</th><th>处理</th></tr></thead><tbody><tr><td>BLACK</td><td>不需要调整</td><td>插入完成</td></tr><tr><td>RED</td><td>违反规则3</td><td>需要处理</td></tr></tbody></table><p>如果parent节点是红的，那么就会出现多种情况，需要处理，情况1可以通变色处理，但是情况2+3则因为<strong>最长路径已经超过最短路径的两倍所以无法变色解决，需要旋转</strong></p><p>下面的图中我们约定:cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点</p><table><thead><tr><th>情况</th><th>cur</th><th>parent</th><th>grandparent</th><th>uncle</th><th>处理方案</th></tr></thead><tbody><tr><td>情况一：<br>叔叔存在且为红</td><td>RED</td><td>RED</td><td>BLACK</td><td>exist &amp;&amp; RED</td><td>pu变黑，g变红，继续往上走</td></tr><tr><td>情况二:<br>叔叔不存在或为黑（直线）</td><td>RED</td><td>RED</td><td>BLACK</td><td>!exist || <br>exist &amp;&amp; BLACK</td><td>单旋转+变色</td></tr><tr><td>情况三;<br>叔叔不存在或为黑（折线）</td><td>RED</td><td>RED</td><td>BLACK</td><td>!exist ||<br>exist &amp;&amp; BLACK</td><td>双旋转+变色</td></tr></tbody></table><h4 id="2-2-2-Situation1"><a href="#2-2-2-Situation1" class="headerlink" title="2.2.2 Situation1"></a>2.2.2 Situation1</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况一: cur为红，p为红，g为黑，u存在且为红</strong></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051325666.png" alt="image-20220505132556579"></p><table><thead><tr><th>具象图</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>g已经到顶了</td><td>pu变黑，g变红</td></tr><tr><td>具象图2：</td><td>符合具象图1但是修改完其他节点不符合</td><td>不断执行情况1，直到parent为空时，p存在且为黑，或者p不存在停止（把根变黑）</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051326419.png" alt="image-20220505132610350"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205051351735.png" alt="image-20220505135120634"></p><h4 id="2-2-3-Situation2"><a href="#2-2-3-Situation2" class="headerlink" title="2.2.3 Situation2"></a>2.2.3 Situation2</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况二: cur为红，p为红，g为黑，u不存在/u为黑</strong><br>情况二中，无非是还会出现一种情况是左旋，但是说到底都是单旋转中的一种,关键在于</p><table><thead><tr><th>parent/grandparent/cur关系</th><th>旋转操作</th><th>变色操作</th></tr></thead><tbody><tr><td>p为g的左孩子，cur为p的左孩子</td><td>右单旋转</td><td>p、g变色–p变黑，g变红</td></tr><tr><td>p为g的右孩子，cur为p的右孩子</td><td>左单旋转</td><td>p、g变色–p变黑，g变红</td></tr></tbody></table><p><font><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 为什么不能直接染色?</font></p><p>看到下图可能会有一些疑问：为什么我不能把p变黑，g变红，简单来就可以了，还要搞什么旋转呢？这是因为首先原来插入之前是一棵红黑树，那么右路如果有uncle就是需要整一条右路上要两个黑节点才能满足规则五，如果没有uncle节点就要满足至少有一个黑，所以说如果直接改变颜色，那么会导致要么右路只有一个黑节点，要么就是右路干脆没有黑节点，所以说一定要采取旋转方式，才能满足规则五</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061006661.png"></p><table><thead><tr><th>具象图（以右单旋为例）</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>`uncle  !exist</td><td></td></tr><tr><td>具象图2：</td><td>符合情况一且处理之后产生情况二</td><td>处理情况一+右单旋+p变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205060953867.png" alt="image-20220506095327691"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061035548.png" alt="image-20220506103556352"></p><h4 id="2-2-4-Situation3"><a href="#2-2-4-Situation3" class="headerlink" title="2.2.4 Situation3"></a>2.2.4 Situation3</h4><p><strong><span class="github-emoji"><span>🍁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f341.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 情况三: cur为红，p为红，g为黑，u不存在/u为黑</strong></p><p>情况三看上去好像和情况二很像，其实差别在于情况三的结构，同时他是一个双旋</p><table><thead><tr><th>parent/grandparent/cur关系</th><th>旋转操作1</th><th>旋转操作2</th><th>变色操作</th></tr></thead><tbody><tr><td>p为g的左孩子，cur为p的右孩子</td><td>左单旋转</td><td>右单旋转</td><td>cur、g变色–cur变黑，g变红</td></tr><tr><td>p为g的右孩子，cur为p的左孩子</td><td>右单旋转</td><td>左单旋转</td><td>cur、g变色–cur变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205071403059.png" alt="image-20220507140351911"></p><table><thead><tr><th>具象图（以右单旋为例）</th><th>描述</th><th>操作</th></tr></thead><tbody><tr><td>具象图1：</td><td>`uncle  !exist</td><td></td></tr><tr><td>具象图2：</td><td>符合情况一且处理之后产生情况三</td><td>处理情况一+左单旋+右单旋+cur变黑，g变红</td></tr></tbody></table><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061039461.png" alt="image-20220506103931331"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205061104810.png" alt="image-20220506110459705"></p><h4 id="2-2-5-分类讨论总结"><a href="#2-2-5-分类讨论总结" class="headerlink" title="2.2.5 分类讨论总结"></a>2.2.5 分类讨论总结</h4><p>插入一个新节点，新节点必是红的</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205072102026.png" alt="image-20220507210143404"></p><h4 id="2-2-6-实现插入"><a href="#2-2-6-实现插入" class="headerlink" title="2.2.6 实现插入"></a>2.2.6 实现插入</h4><h5 id="2-2-6-1-插入本体"><a href="#2-2-6-1-插入本体" class="headerlink" title="2.2.6.1 插入本体"></a>2.2.6.1 插入本体</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//插入</span>pair<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//空树</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token comment">//根必须是黑的</span>        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token comment">//1. 找适当的空位置</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&gt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span><span class="token comment">//重复</span>            <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//2. cur走到空 可以链接</span>    Node<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    newnode<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first <span class="token operator">&lt;</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> newnode<span class="token punctuation">;</span>        newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> newnode<span class="token punctuation">;</span>        newnode<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cur <span class="token operator">=</span> newnode<span class="token punctuation">;</span>    <span class="token comment">//3.判断处理条件</span>    <span class="token comment">//如果父亲存在，且颜色为红色就需要处理</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token operator">-&gt;</span>_col <span class="token operator">==</span> RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//抓住叔叔是关键</span>        Node<span class="token operator">*</span> grandfather <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>    <span class="token comment">//a. 首先父亲在祖父左边的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">==</span>grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Node<span class="token operator">*</span> uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>            <span class="token comment">//情况1：uncle 存在且为红</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">==</span>RED<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> uncle<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token comment">//继续往上处理</span>                cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>                parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//情况2+3 uncle不存在或者uncle存在且为黑</span>            <span class="token keyword">else</span><span class="token comment">//此时变色无法处理</span>            <span class="token punctuation">{</span>                <span class="token comment">//情况2：单旋</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">==</span>parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span>                <span class="token punctuation">{</span>   <span class="token comment">//1. 右单旋</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//2. 变色</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                    parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span><span class="token comment">//情况3：双旋</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//根是黑的了，不会往上影响直接break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         <span class="token comment">//b. 首先父亲在祖父左边的情况</span>        <span class="token keyword">else</span><span class="token comment">//parent == grandfather-&gt;_right</span>        <span class="token punctuation">{</span>            Node<span class="token operator">*</span> uncle <span class="token operator">=</span> grandfather<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>            <span class="token comment">//情况1：uncle 存在且为红 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uncle <span class="token operator">&amp;&amp;</span> uncle<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                uncle<span class="token operator">-&gt;</span>_col<span class="token operator">=</span>parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token comment">//继续往上递归</span>                cur <span class="token operator">=</span> grandfather<span class="token punctuation">;</span>                parent <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span><span class="token comment">//这个肯定有父亲</span>            <span class="token punctuation">}</span>             <span class="token comment">//情况 2+3： uncle不存在或为黑</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_right<span class="token operator">==</span>cur<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    parent<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>grandfather<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>                    grandfather<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> RED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//默认修改根节点为黑色</span>    _root<span class="token operator">-&gt;</span>_col <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>newnode<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-6-2-旋转函数"><a href="#2-2-6-2-旋转函数" class="headerlink" title="2.2.6.2 旋转函数"></a>2.2.6.2 旋转函数</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_Rotate_R</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> subL <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>Node<span class="token operator">*</span> subLR <span class="token operator">=</span> subL<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span><span class="token comment">//1.旋转</span>parent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subLR<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>subLR<span class="token punctuation">)</span><span class="token punctuation">{</span>subLR<span class="token operator">-&gt;</span>_parent<span class="token operator">=</span>parent<span class="token punctuation">;</span><span class="token punctuation">}</span>subL<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> parent<span class="token punctuation">;</span>Node<span class="token operator">*</span> grandparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span><span class="token comment">//记录爷爷</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subL<span class="token punctuation">;</span><span class="token comment">//2. 修改父子关系</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> _root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//原来的父亲做了根节点</span>_root <span class="token operator">=</span> subL<span class="token punctuation">;</span>_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//修改爷爷和父亲链接</span><span class="token keyword">if</span> <span class="token punctuation">(</span>grandparent<span class="token operator">-&gt;</span>_left<span class="token operator">==</span>parent<span class="token punctuation">)</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subL<span class="token punctuation">;</span><span class="token keyword">else</span>grandparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subL<span class="token punctuation">;</span>subL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> grandparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">_Rotate_L</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> parent<span class="token punctuation">)</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> subR <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>Node<span class="token operator">*</span> subRL <span class="token operator">=</span> subR<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span><span class="token comment">//1. 旋转</span>parent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subRL<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>subRL<span class="token punctuation">)</span><span class="token punctuation">{</span>subRL<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span><span class="token punctuation">}</span>subR<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> parent<span class="token punctuation">;</span>Node<span class="token operator">*</span> grandparent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> subR<span class="token punctuation">;</span><span class="token comment">//2. 修改父子关系</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>_root <span class="token operator">=</span> subR<span class="token punctuation">;</span>_root<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">==</span> parent<span class="token punctuation">)</span>grandparent<span class="token operator">-&gt;</span>_left <span class="token operator">=</span> subR<span class="token punctuation">;</span><span class="token keyword">else</span>grandparent<span class="token operator">-&gt;</span>_right <span class="token operator">=</span> subR<span class="token punctuation">;</span>subR<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> grandparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-Erase"><a href="#2-3-Erase" class="headerlink" title="2.3 Erase"></a>2.3 Erase</h3><p>和AVL树类似，红黑树的删除只谈谈思想</p><ul><li>删除节点一定是左为空或者右为空，然后让父亲链接自己的孩子<ul><li><p>删除的是红色节点，直接就没有什么问题</p></li><li><p>删除的是黑色节点，可能导致连续的红节点，或者一条路径上少了一个黑节点</p><ul><li><p>后继还有红节点，变色成黑的</p></li><li><p>后继没有红节点可能还要旋转</p></li></ul></li></ul></li></ul><p>具体有很多种情况可以参照<a href="https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html">https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html</a></p><h3 id="2-4-Find"><a href="#2-4-Find" class="headerlink" title="2.4 Find"></a>2.4 Find</h3><p>和搜索树如出一辙</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Node<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&gt;</span>key<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_kv<span class="token punctuation">.</span>first<span class="token operator">&lt;</span>key<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-析构函数"><a href="#2-5-析构函数" class="headerlink" title="2.5 析构函数"></a>2.5 析构函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_Destroy</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//析构</span><span class="token operator">~</span><span class="token function">AVLTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">_Destroy</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>    _root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-拷贝构造和赋值运算符"><a href="#2-6-拷贝构造和赋值运算符" class="headerlink" title="2.6 拷贝构造和赋值运算符"></a>2.6 拷贝构造和赋值运算符</h3><p>可以参考搜索二叉树，和之前的如出一辙</p><p><a href="https://blog.csdn.net/Allen9012/article/details/124435568">https://blog.csdn.net/Allen9012/article/details/124435568</a></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205071453328.png" alt="image-20220507145354216"></p><h3 id="2-7-CheckBalance"><a href="#2-7-CheckBalance" class="headerlink" title="2.7 CheckBalance"></a>2.7 CheckBalance</h3><p>我们需要写一个树来查一下我们的插入操作正不正确，是否插入形成了一个红黑树</p><p>为了验证是否是红黑树，我们还是利用几点原则</p><h4 id="2-7-1-黑色的根"><a href="#2-7-1-黑色的根" class="headerlink" title="2.7.1 黑色的根"></a>2.7.1 黑色的根</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//1.黑根</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"root是红色"</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-没有连续的红色节点"><a href="#2-7-2-没有连续的红色节点" class="headerlink" title="2.7.2 没有连续的红色节点"></a>2.7.2 没有连续的红色节点</h4><p>方法就是遍历，然后找到红色节点，去查找父亲是不是红色节点，如果是红色就返回false</p><h4 id="2-7-3-每条路径上的黑色节点数量相等"><a href="#2-7-3-每条路径上的黑色节点数量相等" class="headerlink" title="2.7.3 每条路径上的黑色节点数量相等"></a>2.7.3 每条路径上的黑色节点数量相等</h4><p>前序遍历，从根节点走到每一个NIL节点，只要是黑色就count++，如果走到了NIL节点就return，然后此时上一层栈帧的++不影响其他层的count，于是可以实现</p><ol><li>用一个vector去记录每个路径的黑色接点数量，如果最后都是相等的，那么就是说明是红黑树</li><li>不想要走完每条路线才最后比较，可不可以找一条路径作为标准，只要其他路和这条路线不相等就说明不是红黑树，可以找最左路径做黑色节点的参考值<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>Node<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> black_num<span class="token punctuation">,</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> black_num<span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token comment">//3.路径黑节点数相等</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"路径上黑色节点的数量不相等"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2.遍历红节点，查父亲是不是红的，不要查孩子因为孩子可能没有</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED <span class="token operator">&amp;&amp;</span> root<span class="token operator">-&gt;</span>_parent<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>RED<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"存在连续的红色节点"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>BLACK<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_left<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>_right<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span>  <span class="token function">CheckBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//1.黑根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_root<span class="token operator">-&gt;</span>_col<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"root是红色"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2. 每条路径走到NIL节点，遇到黑++，找最左路径做黑色节点的参考值</span>    <span class="token keyword">int</span> black_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> left <span class="token operator">=</span> _root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">-&gt;</span>_col<span class="token operator">==</span>BLACK<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            black_num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        left <span class="token operator">=</span> left<span class="token operator">-&gt;</span>_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//count计算该条路的值</span>    <span class="token comment">//3. 用子函数来递归遍历</span>    <span class="token keyword">return</span> <span class="token function">_CheckBalance</span><span class="token punctuation">(</span>_root<span class="token punctuation">,</span>black_num<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="3-红黑树-V-S-AVL树"><a href="#3-红黑树-V-S-AVL树" class="headerlink" title="3. 红黑树 V.S. AVL树"></a>3. 红黑树 V.S. AVL树</h2><p>红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是<br>$$<br>O(log_2N)<br>$$</p><p>，红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。</p><h2 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h2><ol><li>C++ STL库 – map/set、mutil_map/mutil_set</li><li>Java 库</li><li>linux内核</li><li>其他一些库</li></ol><p>相关代码放在了我的GitHub仓库<a href="https://github.com/Allen9012/cpp/tree/main/C++%E8%BF%9B%E9%98%B6/RBTree">https://github.com/Allen9012/cpp/tree/main/C%2B%2B%E8%BF%9B%E9%98%B6/RBTree</a></p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h3 id="关于AVL树和红黑树的区别说法不正确的是（）"><a href="#关于AVL树和红黑树的区别说法不正确的是（）" class="headerlink" title="关于AVL树和红黑树的区别说法不正确的是（）"></a>关于AVL树和红黑树的区别说法不正确的是（）</h3><p>A.AVL树和红黑树保证平衡性的方式不同</p><p>B.AVL树和红黑树都是平衡树，因此查找的时间复杂度都是O(log_2N)</p><p>C.AVL树和红黑树的性质遭到破坏时，都需要进行旋转</p><p>D.AVL树和红黑树中序遍历都可以得到有序序列，因为它们都是二叉搜索树</p><blockquote><p> A：正确，AVL树通过节点的平衡因子保证，红黑树通过节点的颜色以及红黑树的特性保证</p><p> B：正确，AVL树是严格平衡的，红黑树虽然是近似平衡，但其性能往往比AVL树好，而且实现简 单，因此他们的查找  效率都是O(logN)</p><p> C：错误，AVL树是一定需要旋转，红黑树不一定，红黑树有时只需要改变节点的颜色即可</p><p> D：正确，参考概念</p><p> 因此：选择C</p></blockquote><h3 id="关于红黑树以下说法正确的是（）"><a href="#关于红黑树以下说法正确的是（）" class="headerlink" title="关于红黑树以下说法正确的是（）"></a>关于红黑树以下说法正确的是（）</h3><p>A.空树不是红黑树，因为红黑树要求根节点必须为黑色，而空树中没有根节点</p><p>B.红黑树也是二叉搜索树，因此其按照前序遍历可以得到有序序列</p><p>C.红黑树是一棵真正平衡的二叉树</p><p>D.红黑树最长路径中节点个数可能会等于最短路径中节点个数的两倍</p><blockquote><p> A：错误，空树也是红黑树，性质5中规定树中的空指针域为叶子节点，因此空树也是有节点的</p><p> B：错误，红黑树也是二叉搜索树，按照中序遍历才可以得到有序序列</p><p> C：红黑树不像AVL树那么严格，是一棵近似平衡的二叉搜索树</p><p> D：正确，比如红黑树中只有两个节点</p><p> 因此：选择D</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202205040918814.jpg&quot; alt=&quot;BingWallpaper27&quot;&gt;&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;RB-tree</summary>
      
    
    
    
    
    <category term="高阶数据结构" scheme="https://allen9012.github.io/BlogNet/tags/%E9%AB%98%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://allen9012.github.io/BlogNet/2022/08/25/hello-world/"/>
    <id>https://allen9012.github.io/BlogNet/2022/08/25/hello-world/</id>
    <published>2022-08-25T01:14:45.824Z</published>
    <updated>2022-09-03T02:28:48.815Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Allen’s Blog! This is your very first post. you can ask me on <a href="https://github.com/Allen9012">GitHub</a>.</p><p>Following is my blog on <a href="https://blog.csdn.net/Allen9012?spm=1000.2115.3001.5343">CSDN</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to Allen’s Blog! This is your very first post. you can ask me on &lt;a href=&quot;https://github.com/Allen9012&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Follow</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>高并发内存池</title>
    <link href="https://allen9012.github.io/BlogNet/2022/08/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>https://allen9012.github.io/BlogNet/2022/08/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/</id>
    <published>2022-08-01T01:23:10.000Z</published>
    <updated>2022-09-18T04:54:53.951Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>为了学习和提高设计能力，检验编程思想以及编程能力，以下开始学习并探究实现高并发内存池项目</p><p>本项目实现的是一个高并发的内存池，它是Google的一个开源项目tcmalloc的迷你版，tcmalloc全称Thread-Caching Malloc，即线程缓存的malloc，实现了高效的多线程内存管理，用于替换系统的内存分配相关函数malloc和free。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208211705700.png" alt="image-20220821170456564"></p><p>tcmalloc高知名度的大项目，是全球顶尖的C++大佬联手创造的项目，不少公司都在用它，而Go语言就直接用它做了自己的内存分配器。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301446105.png" alt="image-20220830144611046"></p><p>该项目就是把tcmalloc中最核心的框架简化后拿出来，模拟实现出一个mini版的高并发内存池，目的就是学习tcmalloc的精华。</p><p>该项目主要涉及C/C++、数据结构（链表、哈希桶）、操作系统内存管理、单例模式、多线程、互斥锁等方面的技术。</p><h2 id="什么是内存池"><a href="#什么是内存池" class="headerlink" title="什么是内存池"></a>什么是内存池</h2><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><p>所谓“池化技术”，就是<strong>程序先向系统申请过量的资源，然后自己进行管理，以备不时之需。</strong></p><p><span style="color:lightseagreen">之所以要申请过量的资源，是因为申请和释放资源都有较大的开销，不如提前申请一些资源放入“池”中，当需要资源时直接从“池”中获取，不需要时就将该资源重新放回“池”中即可。</span>这样使用时就会变得非常快捷，可以大大提高程序的运行效率。</p><p>其实我们还有很多使用“池”这种技术的地方，除了内存池之外，还有连接池、线程池、对象池等。</p><p>以服务器上的线程池为例，它的主要思想就是：先启动若干数量的线程，让它们处于睡眠状态，当接收到客户端的请求时，唤醒池中某个睡眠的线程，让它来处理客户端的请求，当处理完这个请求后，线程又进入睡眠状态。</p><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>内存池是指程序预先向操作系统申请一块足够大的内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当释放内存的时候，并不是真正将内存返回给操作系统，而是将内存返回给内存池。当程序退出时（或某个特定时间），内存池才将之前申请的内存真正释放。</p><h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>内存池主要解决的就是效率的问题，它能够避免让程序频繁的向系统申请和释放内存。</p><h4 id="解决内存碎片"><a href="#解决内存碎片" class="headerlink" title="解决内存碎片"></a>解决内存碎片</h4><p>其次，内存池作为系统的内存分配器，还需要尝试解决内存碎片的问题。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301404371.png" alt="image-20220830140353243"></p><p>内存碎片是指您的大部分内存被分配在大量不连续的块或块中 - 使您的总内存中有很大一部分未分配，但在大多数典型情况下无法使用。这会导致内存不足异常或分配错误（即 malloc 返回 null）。</p><p>考虑这一点的最简单方法是想象你有一面大的空墙，你需要在上面放置不同尺寸的图片。每张图片都占据一定的尺寸，您显然无法将其拆分成更小的部分以使其适合。你需要在墙上有一个空的地方，图片的大小，否则你不能把它放上去。现在，如果你开始把照片挂在墙上，但你不小心如何安排它们，你很快就会看到一面墙被部分照片覆盖，即使你可能有空位，大多数新照片都不适合因为它们比可用的位置大。您仍然可以挂非常小的图片，但大多数图片不适合。所以你必须重新排列（紧凑）已经在墙上的那些，以便为更多空间腾出空间。</p><h5 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h5><p><strong>外部碎片</strong>是一些空闲的小块内存区域，由于这些内存空间不连续，以至于合计的内存足够，但是不能满足一些内存分配申请需求。</p><p><strong>内部碎片</strong>是由于一些对齐的需求，导致分配出去的空间中一些内存无法被利用。</p><p>注意： 内存池尝试解决的是外部碎片的问题，同时也尽可能的减少内部碎片的产生。</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>C/C++中我们要动态申请内存并不是直接去堆申请的，而是通过malloc函数去申请的，包括C++中的new实际上也是封装了malloc函数的。</p><p>我们申请内存块时是先调用malloc，malloc再去向操作系统申请内存。malloc实际就是一个内存池，malloc相当于向操作系统“批发”了一块较大的内存空间，然后“零售”给程序用，当全部“售完”或程序有大量的内存需求时，再根据实际需求向操作系统“进货”。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301429040.png" alt="image-20220830142903941"></p><p>malloc的实现方式有很多种，一般不同编译器平台用的都是不同的。比如Windows的VS系列中的malloc就是微软自行实现的一套，而Linux下的gcc用的是glibc中的ptmalloc。</p><p><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>那我们既然已经有了malloc，为什么还需要学习使用tcmalloc的模拟呢？</strong></p><blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301431381.png" alt="image-20220830143143335"></p><p>也就是说tcmalloc是一个比malloc在多线程模式下更快的一个内存池</p></blockquote><h2 id="实现一个定长内存池"><a href="#实现一个定长内存池" class="headerlink" title="实现一个定长内存池"></a>实现一个定长内存池</h2><blockquote><p>“尺有所短 寸有所长”</p></blockquote><p>malloc其实就是一个通用的内存池，在什么场景下都可以使用，但这也意味着malloc在什么场景下都不会有很高的性能，因为malloc并不是针对某种场景专门设计的。</p><p>定长内存池就是针对固定大小内存块的申请和释放的内存池，<strong>由于定长内存池只需要支持固定大小内存块的申请和释放，因此我们可以将其性能做到极致，并且在实现定长内存池时不需要考虑内存碎片等问题</strong>，因为我们申请/释放的都是固定大小的内存块。</p><p>通过实现定长内存池我们可以来熟悉一下对简单内存池的控制，其次这个定长内存池后面会作为高并发内存池的一个基础组件，后期也会使用到</p><h3 id="实现定长"><a href="#实现定长" class="headerlink" title="实现定长"></a>实现定长</h3><p>我们可以使用非类型模板参数，使得在该内存池中申请到的对象的大小都是N。</p><p>同时定长内存池也叫做对象池，在创建对象池时，对象池可以根据传入的对象类型的大小来实现“定长”，因此我们可以通过使用模板参数来实现“定长”，比如创建定长内存池时传入的对象类型是int，那么该内存池就只支持4字节大小内存的申请和释放。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//用模板控制了大小</span><span class="token comment">//template&lt;size_t N&gt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">ObjectPool</span><span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设计成员变量"><a href="#设计成员变量" class="headerlink" title="设计成员变量"></a>设计成员变量</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token comment">//指向大块内存的指针。</span><span class="token keyword">int</span> _remainBytes <span class="token comment">//大块内存切分过程中剩余字节数。</span><span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token comment">//还回来过程中链接的自由链表的头指针。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意初始化，不初始化的报错：</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301738257.png" alt="image-20220830173811179"></p><p><strong>规则1：内置类型的变量如果初始化，则它的默认初始化值取决于定义它的位置</strong></p><ul><li><strong>定义在任何函数之外的未初始化的内置类型变量（也就是全局变量）会被默认初始化为0</strong></li><li><strong>定义在函数体内部的（包括main函数）未初始化的内置类型变量（也就是局部变量）的默认初始值是未定义的（也就是一个随机数）。如果试图拷贝或以其他方式访问该变量的值，此时会引发编译错误</strong></li></ul><p><strong>规则2：未初始化的内置类型的全局变量的默认初始化值还取决于变量的数据类型：</strong></p><ul><li><strong>数值数据类型的未初始化全局变量的默认初始值为0</strong></li><li><strong>bool类型的未初始化的全局变量的默认初始化值为false（也就是0）</strong></li><li><strong>char类型的未初始化的全局变量的默认初始化值为‘\0’（ASCII码值为0）</strong> </li><li><strong>string类型（姑且当成内置类型）的未初始化的全局变量的默认初始值为“”</strong></li></ul><p><strong>规则3：静态变量无论是全局变量还是局部变量，编译器都会给其默认初始化值，值为多少取决于变量的数据类型</strong></p><p><strong>规则4：指针类型的全局未初始化的变量的默认初始值为NULL，而指针类型的局部未初始化变量的默认值这是未定义的（在有些编译器下定义为初始化的局部指针变量会报错）</strong></p><h4 id="指针记录"><a href="#指针记录" class="headerlink" title="指针记录"></a>指针记录</h4><p>对于向堆申请到的大块内存，我们可以用一个指针来对其进行管理</p><p>由于此后我们需要将这块内存进行切分，为了方便切分操作，指向这块内存的指针最好是字符指针，因为指针的类型决定了指针向前或向后走一步有多大距离，对于字符指针来说，当我们需要向后移动n个字节时，直接对字符指针进行加n操作即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301457386.png" alt="image-20220830145721335"></p><p>这里使用<code>char*</code>而不适用<code>void*</code>的原因是，后期需要进行切片，使用void*方便++和–操作，同时一个字节为大小的话，后期大小好控制（相较于int）</p><h4 id="自由链表"><a href="#自由链表" class="headerlink" title="自由链表"></a>自由链表</h4><p>同时释放回来的定长内存块也需要被管理，我们可以将这些释放回来的定长内存块链接成一个链表，这里我们将管理释放回来的内存块的链表叫做自由链表，为了能找到这个自由链表，我们还需要一个指向自由链表的指针。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301457924.png" alt="image-20220830145729885"></p><p>我们将我们之前释放的每一块内存块表示成一个节点，我们去这个节点的前四个字节保存连接下一个节点的地址（需要处理小于四字节的情况）</p><h4 id="剩余字节数"><a href="#剩余字节数" class="headerlink" title="剩余字节数"></a>剩余字节数</h4><p>仅用一个指针管理内存池肯定是不够的，我们还需要用一个变量来记录这块内存的长度。</p><p>如果没有一个size代表着剩余的长度的话有可能就一下子取光越界了</p><p>于是我们针对这个剩余字节数，如果剩的够的话，就留着，如果不够了就需要再开辟</p><h3 id="从内存池申请对象"><a href="#从内存池申请对象" class="headerlink" title="从内存池申请对象"></a>从内存池申请对象</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在一切的开始，初始化一下内存池，如果剩余大小不够了，就重新开一个内存空间</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">  <span class="token comment">//一个对象都不够的话，就重新申请</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>    _memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>_remainBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//128KB</span>    <span class="token comment">//逻辑上切一个T大小的对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="重复利用"><a href="#重复利用" class="headerlink" title="重复利用"></a>重复利用</h4><p>当我们申请对象时，内存池应该优先把还回来的内存块对象再次重复利用，因此如果自由链表当中有内存块的话，就直接从自由链表头删一个内存块进行返回即可。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301702409.png" alt="image-20220830170203369"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//优先还回来的内存块重复利用</span><span class="token keyword">if</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//头删操作</span><span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下一个节点的地址</span>    obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>    _freeList <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//切片出去了</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="利用剩余内存池块"><a href="#利用剩余内存池块" class="headerlink" title="利用剩余内存池块"></a>利用剩余内存池块</h4><p>如果自由链表当中没有内存块，那么我们就在大块内存中切出定长的内存块进行返回，当内存块切出后及时更新<code>_memory</code>指针的指向，以及<code>_remainBytes</code>的值即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>_memory <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//偏移</span>_remainBytes <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301704351.png" alt="image-20220830170406273"></p><p><strong>需要特别注意的是，由于当内存块释放时我们需要将内存块链接到自由链表当中，因此我们必须保证切出来的对象至少能够存储得下一个地址，所以当对象的大小小于当前所在平台指针的大小时，需要按指针的大小进行内存块的切分。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span><span class="token keyword">const</span> size_t objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>_memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> <span class="token comment">//偏移</span>_remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span><span class="token keyword">return</span> obj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    T<span class="token operator">*</span> obj <span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token comment">//优先还回来的内存块重复利用</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token comment">//头删操作</span> <span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下一个节点的地址</span>        obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>        _freeList <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//切片出去了</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment">//一个对象都不够的话，就重新申请</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            _remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>            _memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>_remainBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//128KB</span>            <span class="token comment">//逻辑上切一个T大小的对象</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>        <span class="token keyword">const</span> size_t objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>        _memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> <span class="token comment">//偏移</span>        _remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span>        <span class="token comment">//定位new显示调用T的构造函数初始化</span>        <span class="token keyword">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>T<span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需要注意的是，与释放对象时需要显示调用该对象的析构函数一样，当内存块切分出来后，我们也应该使用定位new，显示调用该对象的构造函数对其进行初始化。</strong></p><h3 id="从内存池释放对象"><a href="#从内存池释放对象" class="headerlink" title="从内存池释放对象"></a>从内存池释放对象</h3><p>对于还回来的定长内存块，我们可以用自由链表将其链接起来，但我们并不需要为其专门定义链式结构，我们可以让内存块的前4个字节（32位平台）或8个字节（64位平台）作为指针，存储后面内存块的起始地址即可。</p><h4 id="初始化freelist"><a href="#初始化freelist" class="headerlink" title="初始化freelist"></a>初始化freelist</h4><p>一开始freelist是空的，我们希望在每一个节点的前一个指针大小的字节处，存放下一个节点的指针，可是在32位机器下是需要8个字节的，这时就很难受了，我们如何分别64位和32位？用分支判断太复杂，我们其实可以使用一个更好用简单的方法</p><p>我们知道，32位平台下指针的大小是4个字节，64位平台下指针的大小是8个字节。而指针指向数据的类型，决定了指针解引用后能向后访问的空间大小，因此我们这里需要的是一个指向指针的指针，这里使用二级指针就行了。</p><p>当我们需要访问一个内存块的前4/8个字节时，我们就可以先该内存块的地址先强转为二级指针（无论是<code>void*</code>还是<code>int*</code>都可以），由于二级指针存储的是一级指针的地址，二级指针解引用能向后访问一个指针的大小，因此在32位平台下访问的就是4个字节，在64位平台下访问的就是8个字节，此时我们访问到了该内存块的前4/8个字节。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>_freeList <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token comment">//*(int*)obj = nullptr; //获取一个指针的大小 ，但是不好使用64位</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后续释放"><a href="#后续释放" class="headerlink" title="后续释放"></a>后续释放</h4><p>这里我们选择头插，这样可以不用去找尾，省去效率</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301651334.png" alt="image-20220830165151259"></p><p>在向自由链表插入被释放的内存块时，先让该内存块的前4个字节或8个字节存储自由链表中第一个内存块的地址，然后再让<code>_freeList</code>指向该内存块即可，也就是一个简单的链表头插操作。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>此时的delete函数，由于头插是和初始化不冲突的，所以说我们可以不用分支判断，直接一步到位</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//调用析构函数</span>obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何直接从堆申请空间？"><a href="#如何直接从堆申请空间？" class="headerlink" title="如何直接从堆申请空间？"></a>如何直接从堆申请空间？</h3><p>既然是内存池，那么我们首先得向系统申请一块内存空间，然后对其进行管理。要想直接向堆申请内存空间，在Windows下，可以调用VirtualAlloc函数；在Linux下，可以调用brk或mmap函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token comment">//...</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">//直接去堆上申请按页申请空间</span><span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>size_t kpage<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> kpage<span class="token operator">&lt;&lt;</span><span class="token number">13</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token comment">// linux下brk mmap等</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们可以通过条件编译将对应平台下向堆申请内存的函数进行封装，此后我们就不必再关心当前所在平台，当我们需要直接向堆申请内存时直接调用我们封装后的SystemAlloc函数即可。</p><h3 id="测试性能-amp-amp-调整过后的pool"><a href="#测试性能-amp-amp-调整过后的pool" class="headerlink" title="测试性能&amp;&amp;调整过后的pool"></a>测试性能&amp;&amp;调整过后的pool</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> fixed_length_pool<span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token comment">//...</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">//直接去堆上申请按页申请空间</span><span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>size_t kpage<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> kpage<span class="token operator">&lt;&lt;</span><span class="token number">13</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token comment">// linux下brk mmap等</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">ObjectPool</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>T<span class="token operator">*</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>T<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//优先还回来的内存块重复利用</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//头删操作</span><span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下一个节点的地址</span>obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freeList<span class="token punctuation">;</span>_freeList <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">//切片出去了</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//一个对象都不够的话，就重新申请</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>_remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">// _memory = (char*)malloc(_remainBytes);  //128KB</span>_memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>_remainBytes <span class="token operator">&gt;&gt;</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//除8K换算出页数</span><span class="token comment">//逻辑上切一个T大小的对象</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span><span class="token keyword">const</span> size_t objSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>_memory <span class="token operator">+=</span> objSize<span class="token punctuation">;</span> <span class="token comment">//偏移</span>_remainBytes <span class="token operator">-=</span> objSize<span class="token punctuation">;</span><span class="token comment">//定位new显示调用T的构造函数初始化</span><span class="token keyword">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>T<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//调用析构函数</span>obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span><span class="token operator">*</span> _memory <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//指向大块内存的指针。</span><span class="token keyword">int</span> _remainBytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//大块内存切分过程中剩余字节数。</span><span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//还回来过程中链接的自由链表的头指针。</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">{</span><span class="token keyword">int</span> _val<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> _left<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> _right<span class="token punctuation">;</span><span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">TestObjectPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 申请释放的轮次</span><span class="token keyword">const</span> size_t Rounds <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">// 每轮申请释放多少次</span><span class="token keyword">const</span> size_t N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>v1<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">delete</span> v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ObjectPool<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> TNPool<span class="token punctuation">;</span>size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>v2<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>TNPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>TNPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>v2<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"new cost time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"object pool cost time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用malloc时，对比</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208301734134.png" alt="image-20220830173459075"></p><h2 id="内存池框架设计"><a href="#内存池框架设计" class="headerlink" title="内存池框架设计"></a>内存池框架设计</h2><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>现代的设计往往单核但进程已经是性能达到极限了，所以往往转向多核多进程的设计</p><p>现代很多的开发环境也都是多核多线程，因此在申请内存时，必然存在激烈的锁竞争问题。malloc本身其实已经很优秀了，但是在并发场景下可能会因为频繁的加锁和解锁导致效率有所降低，而该项目的原型tcmalloc实现的就是一种在多线程高并发场景下更胜一筹的内存池。</p><p>在实现高并发内存池时我们一般需要考虑：</p><ol><li>性能问题。（一般内存池）</li><li>多线程环境下，锁竞争问题。（高并发的内存池需要考虑该问题）</li><li>内存碎片问题。（一般内存池）</li></ol><h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311003227.png" alt="image-20220831100345062"></p><p>高并发内存池主要由以下三个部分构成：</p><h4 id="thread-cache"><a href="#thread-cache" class="headerlink" title="thread cache"></a>thread cache</h4><p>thread cache就是一个类，他是一个内存的数据结构</p><p>好处是线程缓存是每个线程独有的，每个线程申请内存的时候都是不用加锁的，这也就是这个并发线程池高效的地方</p><p>不过它用于小于等于256KB的内存分配</p><p>每个线程独享一个thread cache。</p><p>但是thread cache不可能永远是够的，总会出现内存取光的情况</p><h4 id="central-cache"><a href="#central-cache" class="headerlink" title="central cache"></a>central cache</h4><p><strong>中心缓存是所有线程所共享</strong></p><p>当thread cache需要内存时会<strong>按需从central cache中获取</strong>内存</p><p>central cache合适的时机回收thread cache中的对象，避免<strong>一个线程占用了太多的内存，而其他线程的内存吃紧</strong>，它可以达到内存分配在多个线程中更均衡的按需调度的目的</p><p>central cache是存在竞争的，所以从这里取内存对象是需要加锁，首先这里用的是桶锁，其次只有thread cache同时没有内存对象时才会找central cache，所以这里锁竞争不会很激烈</p><h4 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h4><p>页缓存中存储的内存是以页为单位进行存储及分配的，当central cache需要内存时，page cache会分配出一定数量的页分配给central cache，而当central cache中的内存满足一定条件时，page cache也会在合适的时机对其进行回收，并将回收的内存尽可能的进行合并，组成更大的连续内存块，缓解内存碎片的问题。</p><p>page cache如果没有的话就去系统找堆去要</p><h2 id="thread-cache-1"><a href="#thread-cache-1" class="headerlink" title="thread cache"></a>thread cache</h2><h3 id="设计threadcache"><a href="#设计threadcache" class="headerlink" title="设计threadcache"></a>设计threadcache</h3><p>定长内存池只支持固定大小内存块的申请释放，因此定长内存池中只需要一个自由链表管理释放回来的内存块。现在我们要支持申请和释放不同大小的内存块，那么我们就需要多个自由链表来管理释放回来的内存块，因此thread cache实际上一个哈希桶结构，每个桶中存放的都是一个自由链表。</p><p>thread cache支持小于等于256KB内存的申请，如果我们将每种字节数的内存块都用一个自由链表进行管理的话，那么此时我们就需要20多万个自由链表，光是存储这些自由链表的头指针就需要消耗大量内存，这显然是得不偿失的。所以我们可以将某一个字节范围内的需求归到一个指定的对齐字节的自由链表统一分配  </p><p>这时我们可以选择做一些平衡的牺牲，让这些字节数按照某种规则进行对齐，例如我们让这些字节数都按照8字节进行向上对齐，那么thread cache的结构就是下面这样的，此时当线程申请<code>1~8</code>字节的内存时会直接给出8字节，而当线程申请<code>9~16</code>字节的内存时会直接给出16字节，以此类推。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311027210.png" alt="image-20220831102717104"></p><p><strong>因此当线程要申请某一大小的内存块时，就需要经过某种计算得到对齐后的字节数，进而找到对应的哈希桶</strong>，如果该哈希桶中的自由链表中有内存块，那就从自由链表中头删一个内存块进行返回；如果该自由链表已经为空了，那么就需要向下一层的central cache进行获取了。</p><p>但此时由于对齐的原因，就可能会产生一些碎片化的内存无法被利用，比如线程只申请了6字节的内存，而thread cache却直接给了8字节的内存，这多给出的2字节就无法被利用，导致了一定程度的空间浪费，这些因为某些对齐原因导致无法被利用的内存，就是内存碎片中的<strong>内部碎片</strong>。</p><h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><ol><li>当内存申请size&lt;=256KB，先获取到线程本地存储的thread cache对象，计算size映射的哈希桶自由链表下标i。</li><li>如果自由链表_freeLists[i]中有对象，则直接Pop一个内存对象返回。</li><li>如果_freeLists[i]中没有对象时，则批量从central cache中获取一定数量的对象，插入到自由链表并返回一个对象。</li></ol><h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><ol><li>当释放内存小于256k时将内存释放回thread cache，计算size映射自由链表桶位置i，将对象Push到_freeLists[i]。</li><li>当链表的长度过长，则回收一部分内存对象到central cache。</li></ol><h3 id="成员变量-自由链表"><a href="#成员变量-自由链表" class="headerlink" title="成员变量-自由链表"></a>成员变量-自由链表</h3><p>为了方便使用自由链表，我们仿照之前对于自由链表的操作，现在对结构进行封装，目前我们就提供Push和Pop两个成员函数，对应的操作分别是将对象插入到自由链表（头插）和从自由链表获取一个对象（头删），后面在需要时还会添加对应的成员函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//管理切分好的小对象的自由链表</span><span class="token keyword">class</span> <span class="token class-name">FreeLIst</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> obj<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 头插</span>        <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>        _freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//头删</span>        <span class="token keyword">void</span><span class="token operator">*</span> obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>        _freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设计hashbucket对齐规则"><a href="#设计hashbucket对齐规则" class="headerlink" title="设计hashbucket对齐规则"></a>设计hashbucket对齐规则</h3><h4 id="如何进行对齐？"><a href="#如何进行对齐？" class="headerlink" title="如何进行对齐？"></a>如何进行对齐？</h4><p>首先，这些内存块是会被链接到自由链表上的，因此一开始肯定是按8字节进行对齐是最合适的，因为我们必须保证这些内存块，无论是在32位平台下还是64位平台下，都至少能够存储得下一个指针。</p><p>但如果所有的字节数都按照8字节进行对齐的话，那么我们就需要建立256 × 1024 ÷ 8 = 32768个桶，这个数量还是比较多的，实际上我们可以让不同范围的字节数按照不同的对齐数进行对齐，具体对齐方式如下：</p><p>这里的映射规则是对<code>tcmaclloc</code>简化的，<code>tcmaclloc</code>还要复杂</p><table><thead><tr><th>字节数</th><th>对齐数</th><th>hashbucket下标</th><th>桶数</th></tr></thead><tbody><tr><td>[ 1 ，128 ]</td><td>8</td><td>[ 0 ， 16 )</td><td>16</td></tr><tr><td>[ 128 + 1 ，1024 ]</td><td>16</td><td>[ 16 ， 72 )</td><td>56</td></tr><tr><td>[ 1024 + 1 ，8 × 1024 ]</td><td>128</td><td>[ 72 ， 128 )</td><td>56</td></tr><tr><td>[ 8 × 1024 + 1 ，64 × 1024 ]</td><td>1024</td><td>[ 128 ， 184 )</td><td>56</td></tr><tr><td>[ 64 × 1024 + 1 ，256 × 1024 ]</td><td>8×1024</td><td>[ 184 ， 208 )</td><td>24</td></tr></tbody></table><p>这样整体可以控制到10%左右的浪费，这是怎么算的？</p><h4 id="空间浪费率"><a href="#空间浪费率" class="headerlink" title="空间浪费率"></a>空间浪费率</h4><p>虽然对齐产生的内碎片会引起一定程度的空间浪费，但按照上面的对齐规则，我们可以将浪费率控制10%左右。需要说明的是，1~128这个区间我们不做讨论，因为1字节就算是对齐到2字节也有50%的浪费率，这里我们就从第二个区间开始进行计算。</p><p>$$<br>浪费率 = \frac{浪费的字节数}{对齐后的字节数}<br>$$</p><p> </p><p>  根据上面的公式，我们要得到某个区间的最大浪费率，就应该让分子取到最大，让分母取到最小。比如129~1024这个区间，该区域的对齐数是16，那么最大浪费的字节数就是15，而最小对齐后的字节数就是这个区间内的前16个数所对齐到的字节数，也就是144，那么该区间的最大浪费率也就是<code>15 ÷ 144 ≈ 10.42 %</code>同样的道理，后面两个区间的最大浪费率分别是<code>127 ÷ 1152 ≈ 11.02 %</code> 和 <code>1023 ÷ 9216 ≈ 11.10 % </code></p><h4 id="实现对齐函数"><a href="#实现对齐函数" class="headerlink" title="实现对齐函数"></a>实现对齐函数</h4><p>需要注意的是，SizeClass类当中的成员函数最好设置为静态成员函数，否则我们在调用这些函数时就需要通过对象去调用，并且对于这些可能会频繁调用的函数，为了减少频繁调用的开销，我们可以考虑将其设置为内联函数。</p><h5 id="RoundUp"><a href="#RoundUp" class="headerlink" title="RoundUp"></a>RoundUp</h5><p>在获取某一字节数向上对齐后的字节数时，可以先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">RoundUp</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="RoundUp-1"><a href="#RoundUp-1" class="headerlink" title="RoundUp"></a>RoundUp</h5><p>一般来说正常人都是这么解决对齐问题的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 整体控制在最多10%左右的内碎片浪费</span><span class="token comment">// [1,128]8byte对齐    freelist[0,16)</span><span class="token comment">// [128+1,1024]16byte对齐    freelist[16,72)</span><span class="token comment">// [1024+1,8*1024]128byte对齐    freelist[72,128)</span><span class="token comment">// [8*1024+1,64*1024]1024byte对齐     freelist[128,184)</span><span class="token comment">// [64*1024+1,256*1024]8*1024byte对齐   freelist[184,208)</span><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> size_t AlignNum<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t alignSize<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">%</span> AlignNum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//对齐到对齐数</span>            alignSize <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> alignSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> AlignNum <span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span><span class="token comment">//正好对齐</span>            alignSize <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> alignSize<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而高手采用了这个思路，只能说太强了，虽然位运算可能并没有上面的写法容易理解，但计算机执行位运算的速度是比执行乘法和除法更快的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">_RoundUp</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">,</span> size_t alignNum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>alignNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于上述位运算，我们以10字节按8字节对齐为例进行分析8 − 1 = 7，7就是一个低三位为1其余位为0的二进制序列，我们将10与7相加，相当于将10字节当中不够8字节的剩余字节数补上了。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311215003.png" alt="image-20220831121520939"></p><p>然后我们再将该值与7按位取反后的值进行与运算，而7按位取反后是一个低三位为0其余位为1的二进制序列，该操作进行后相当于屏蔽了该值的低三位而该值的其余位保持不变，此时得到的值就是10字节按8字节对齐后的值，即16字节。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311215264.png" alt="image-20220831121537192"></p><p>在获取某一字节数对应的哈希桶下标时，也是先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p><h3 id="获取桶下标"><a href="#获取桶下标" class="headerlink" title="获取桶下标"></a>获取桶下标</h3><p>在获取某一字节数对应的哈希桶下标时，也是先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*size_t _Index(size_t bytes, size_t alignNum){    if (bytes % alignNum == 0)    {        return bytes / alignNum - 1;    }    else    {        return bytes / alignNum;    }}*/</span><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">_Index</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">,</span> size_t align_shift<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//下标从一开始</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> align_shift<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 计算映射的哪一个自由链表桶</span><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">Index</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 每个区间有多少个链</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> group_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">_Index</span><span class="token punctuation">(</span>bytes <span class="token operator">-</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> group_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在获取某一字节数对应的哈希桶下标时，也是先判断该字节数属于哪一个区间，然后再通过调用一个子函数进行进一步处理。</p><p>此时我们需要编写一个子函数来继续进行处理，容易想到的就是根据对齐数来计算某一字节数对应的下标。</p><p>当然，为了提高效率下面也提供了一个用位运算来解决的方法，需要注意的是，此时我们并不是传入该字节数的对齐数，而是将对齐数写成2的n次方的形式后，将这个n值进行传入。比如对齐数是8，传入的就是3。</p><h3 id="ThreadCache类"><a href="#ThreadCache类" class="headerlink" title="ThreadCache类"></a>ThreadCache类</h3><p>按照上述的对齐规则，thread cache中桶的个数，也就是自由链表的个数是208，以及thread cache允许申请的最大内存大小256KB，我们可以将这些数据按照如下方式进行定义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//小于等于MAX_BYTES，就找thread cache申请</span><span class="token comment">//大于MAX_BYTES，就直接找page cache或者系统堆申请</span><span class="token keyword">static</span> <span class="token keyword">const</span> size_t MAX_BYTES <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">//thread cache和central cache自由链表哈希桶的表大小</span><span class="token keyword">static</span> <span class="token keyword">const</span> size_t NFREELISTS <span class="token operator">=</span> <span class="token number">208</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个debug</p><p>这里当时没有赋值最大的桶的shu’l</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311625499.png" alt="image-20220831162550410"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311626667.png" alt="image-20220831162628566"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311625596.png" alt="image-20220831162532503"></p><h4 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h4><p>在thread cache申请对象时，通过所给字节数计算出对应的哈希桶下标，如果桶中自由链表不为空，则从该自由链表中取出一个对象进行返回即可；但如果此时自由链表为空，那么我们就需要从central cache进行获取了，这里的FetchFromCentralCache函数也是thread cache类中的一个成员函数，在后面再进行具体实现。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//申请内容不可以超过256K</span><span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取对齐的字节</span>size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得桶的下标</span>size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>alignSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> alignSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h4><p>释放的时候找到对应大小的桶，放回去</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">Deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到对应的桶插进去</span>size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="threadcacheTLS无锁访问"><a href="#threadcacheTLS无锁访问" class="headerlink" title="threadcacheTLS无锁访问"></a>threadcacheTLS无锁访问</h4><p>TLS: Thread Local Storage 线程本地存储</p><h5 id="why-TLS"><a href="#why-TLS" class="headerlink" title="why TLS"></a>why TLS</h5><p>每个线程都有一个自己独享的thread cache，那应该如何创建这个thread cache呢？我们不能将这个thread cache创建为全局的，因为全局变量是所有线程共享的，这样就不可避免的需要锁来控制，增加了控制成本和代码复杂度。</p><p>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现。这就是TLS。这是一种变量的存储方法，使用该存储方法的变量在它所在的线程是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。</p><p>TLS在不同的平台有不同的实现，可移植性不太好。幸好要实现线程局部存储并不难，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程的ID不同，查到的数据自然也不同了。大多数平台都提供了线程局部存储的方法，无需要我们自己去实现</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//TLS - Thread Local Storage</span><span class="token keyword">static</span> <span class="token function">_declspec</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> ThreadCache<span class="token operator">*</span> pTLSThreadCache <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>尤其注意</strong>：这里的对象要把它设置成一个静态的，不然的话会产生链接错误，因为这里被多个文件包含，就会导致在多个.o文件中出现，导致冲突和链接错误，加上一个static，表示只在当前文件可见</p><p>但不是每个线程被创建时就立马有了属于自己的thread cache，而是当该线程调用相关申请内存的接口时才会创建自己的thread cache，因此在申请内存的函数中会包含以下逻辑</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pTLSThreadCache <span class="token operator">=</span><span class="token keyword">new</span> ThreadCache<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="central-cache-1"><a href="#central-cache-1" class="headerlink" title="central cache"></a>central cache</h2><h3 id="central-cache框架"><a href="#central-cache框架" class="headerlink" title="central cache框架"></a>central cache框架</h3><p>当线程申请某一大小的内存时，如果thread cache中对应的自由链表不为空，那么直接取出一个内存块进行返回即可，但如果此时该自由链表为空，那么这时thread cache就需要向central cache申请内存了。</p><p>central cache的结构与thread cache是一样的，它们都是哈希桶的结构，并且<strong>它们遵循的对齐映射规则都是一样的</strong>。<span style="color:darkcyan">这样做的好处就是，当thread cache的某个桶中没有内存了，就可以直接到central cache中对应的哈希桶里去取内存就行了。</span></p><h4 id="申请内存-1"><a href="#申请内存-1" class="headerlink" title="申请内存"></a>申请内存</h4><ol><li>当thread cache中没有内存时，就会批量向central cache申请一些内存对象，这里的批量获取对象的数量使用了类似网络tcp协议拥塞控制的慢开始算法；central cache也有一个哈希映射的spanlist，spanlist中挂着span，从span中取出对象给thread cache，这个过程是需要加锁的，不过这里使用的是一个桶锁，尽可能提高效率。</li><li>central cache映射的spanlist中所有span的都没有内存以后，则需要向page cache申请一个新的span对象，拿到span以后将span管理的内存按大小切好作为自由链表链接到一起。然后从span中取对象给thread cache。</li><li>central cache的中挂的span中use_count记录分配了多少个对象出去，分配一个对象给thread<br>cache，就++use_count</li></ol><p><strong>当一个 thread cache 挂有过多的内存时，我们就可以把它还给central cache，再给到其他的thread cache使用，这就做到了均衡分配</strong></p><h4 id="释放内存-1"><a href="#释放内存-1" class="headerlink" title="释放内存"></a>释放内存</h4><ol><li>当thread_cache过长或者线程销毁，则会将内存释放回central cache中的，释放回来时–use_count。当use_count减到0时则表示所有对象都回到了span，则将span释放回page cache，page cache中会对前后相邻的空闲页进行合并。</li></ol><h3 id="central-cache与thread-cache的不同"><a href="#central-cache与thread-cache的不同" class="headerlink" title="central cache与thread cache的不同"></a>central cache与thread cache的不同</h3><p>central cache与thread cache有两个明显不同的地方，首先，thread cache是每个线程独享的，而#<strong>central cache是所有线程共享的</strong>，因为每个线程的thread cache没有内存了都会去找central cache，因此在访问central cache时是需要加锁的。</p><p>但central cache在加锁时并不是将整个central cache全部锁上了，<strong>central cache在加锁时用的是桶锁</strong>，也就是说每个桶都有一个锁。此时只有当多个线程同时访问central cache的同一个桶时才会存在锁竞争，如果是多个线程同时访问central cache的不同桶就不会存在锁竞争。</p><p>central cache与thread cache的第二个不同之处就是，thread cache的每个桶中挂的是一个个切好的内存块，而<strong>central cache的每个桶中挂的是一个个的span。</strong><br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202208311816818.png" alt="image-20220831181626735"></p><p><strong>每个span管理的都是一个以页为单位的大块内存</strong>，每个桶里面的若干span是按照双链表的形式链接起来的，并且每个span里面还有一个自由链表，这个自由链表里面挂的就是一个个切好了的内存块，根据其所在的哈希桶这些内存块被切成了对应的大小。</p><p>如果span被拿完了，那么就继续问下面的page cache要</p><h3 id="centralcache结构设计"><a href="#centralcache结构设计" class="headerlink" title="centralcache结构设计"></a>centralcache结构设计</h3><h4 id="页号的类型"><a href="#页号的类型" class="headerlink" title="页号的类型"></a>页号的类型</h4><p>首先我们知道进程地址空间的大小：每个程序运行起来后都有自己的进程地址空间，在32位平台下，进程地址空间的大小是2^32^；而在64位平台下，进程地址空间的大小就是2^64^。</p><p>页的大小一般是4K或者8K，我们以8K为例。在32位平台下，进程地址空间就可以被分成 2^32^ ÷ 2^13^= 2^19^  个页；在64位平台下，进程地址空间就可以被分成 2^64^ ÷ 2^13^ = 2^51^个页。页号本质与地址是一样的，它们都是一个编号，只不过地址是以一个字节为一个单位，而页是以多个字节为一个单位。</p><p>由于页号在64位平台下的取值范围是[ 0 ， 2^51^) ，因此我们不能简单的用一个无符号整型来存储页号，这时我们需要借助条件编译来解决这个问题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//条配件编译解决页号</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token keyword">typedef</span> size_t PAGE_ID<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">_WIN64</span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> PAGE_ID<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这不对，因为这里是很坑的</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209012013197.png" alt="image-20220901201330077"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//条配件编译解决页号</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN64</span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> PAGE_ID<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">_WIN32</span></span><span class="token keyword">typedef</span> size_t PAGE_ID<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，在32位下，<code>_WIN32</code>有定义，<code>_WIN64</code>没有定义；而在64位下，<code>_WIN32</code>和<code>_WIN64</code>都有定义。因此在条件编译时，我们应该先判断<code>_WIN64</code>是否有定义，再判断<code>_WIN32</code>是否有定义。</p><h4 id="span的结构"><a href="#span的结构" class="headerlink" title="span的结构"></a>span的结构</h4><p>central cache的每个桶里挂的是一个个的span，span是一个管理以页为单位的大块内存，span的结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//管理以页为单位的大块内存</span><span class="token keyword">struct</span> <span class="token class-name">Span</span><span class="token punctuation">{</span>PAGE_ID _pageId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//大块内存起始页的页号</span>size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment">//页的数量</span>Span<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment">//双链表结构</span>Span<span class="token operator">*</span> _prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>size_t _useCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">//切好的小块内存，被分配给thread cache的计数</span><span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment">//切好的小块内存的自由链表</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么要记录页号?</strong></p><blockquote><p>对于span管理的以页为单位的大块内存，我们需要知道这块内存具体在哪一个位置，便于之后page cache进行前后页的合并，因此span结构当中会记录所管理大块内存起始页的页号。</p></blockquote><p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么双向链表？</strong></p><blockquote><p>每个桶当中的span是以双链表的形式组织起来的，当我们需要将某个span归还给page cache时，就可以很方便的将该span从双链表结构中移出。如果用单链表结构的话就比较麻烦了，因为单链表在删除时，需要知道当前结点的前一个结点。</p></blockquote><p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么要自由链表？</strong></p><blockquote><p>此外，每个span管理的大块内存，都会被切成相应大小的内存块挂到当前span的自由链表中，比如8Byte哈希桶中的span，会被切成一个个8Byte大小的内存块挂到当前span的自由链表中，因此span结构中需要存储切好的小块内存的自由链表。</p></blockquote><p><span class="github-emoji"><span>🥑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f951.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么要<code>_usecount</code>?</strong></p><blockquote><p>span结构当中的<code>_useCount</code>成员记录的就是，当前span中切好的小块内存，被分配给thread cache的计数，当某个span的<code>_useCount</code>计数变为0时，代表当前span切出去的内存块对象全部还回来了，此时central cache就可以将这个span再还给page cache。</p></blockquote><h4 id="SpanList结构"><a href="#SpanList结构" class="headerlink" title="SpanList结构"></a>SpanList结构</h4><p>根据上面的描述，central cache的每个哈希桶里面存储的都是一个双链表结构，对于该双链表结构我们可以对其进行封装。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向链表</span><span class="token keyword">class</span> <span class="token class-name">SpanList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SpanList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>_head <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> pos<span class="token punctuation">,</span> Span<span class="token operator">*</span> newSpan<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>newSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>Span<span class="token operator">*</span> prev <span class="token operator">=</span>pos<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span><span class="token comment">//prev newspan pos</span>prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newSpan<span class="token punctuation">;</span>newSpan<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>newSpan<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> pos<span class="token punctuation">;</span>pos<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Erase</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> pos<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">!=</span> _head<span class="token punctuation">)</span><span class="token punctuation">;</span>Span<span class="token operator">*</span> prev <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>Span<span class="token operator">*</span> next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Span<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span>  <span class="token comment">//桶锁</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，从双链表删除的span会还给下一层的page cache，相当于只是把这个span从双链表中移除，因此不需要对删除的span进行delete操作。</p><h3 id="centralcache核心实现"><a href="#centralcache核心实现" class="headerlink" title="centralcache核心实现"></a>centralcache核心实现</h3><p>由于每个线程都有一个属于自己的thread cache，我们是用TLS来实现每个线程无锁的访问属于自己的thread cache的。而central cache和page cache在整个进程中只有一个，对于这种只能创建一个对象的类，我们可以将其设置为单例模式。</p><p>单例模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。单例模式又分为饿汉模式和懒汉模式，懒汉模式相对较复杂，我们这里使用饿汉模式就足够了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CentralCache</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//thread cache 是无锁的，但是CentralCache是有桶锁的</span><span class="token comment">//采用单例模式,这里是一个全局访问点</span><span class="token keyword">static</span> CentralCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInst<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token function">CentralCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//不可拷贝构造</span><span class="token function">CentralCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> CentralCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>SpanList _spanList<span class="token punctuation">[</span>NFREELIST<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> CentralCache _sInst<span class="token punctuation">;</span>  <span class="token comment">//不要在.h中定义，否则会被多个文件包含</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了保证CentralCache类只能创建一个对象，我们需要将central cache的构造函数和拷贝构造函数设置为私有，或者在C++11中也可以在函数声明的后面加上<code> = delete</code>进行修饰。</p><p>CentralCache类当中还需要有一个CentralCache类型的静态的成员变量，当程序运行起来后我们就立马创建该对象，在此后的程序中就只有这一个单例了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">CentralCache CentralCache<span class="token double-colon punctuation">::</span>_sInst<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后central cache还需要提供一个公有的成员函数，用于获取该对象，此时在整个进程中就只会有一个central cache对象了。</p><h4 id="慢反馈调节算法"><a href="#慢反馈调节算法" class="headerlink" title="慢反馈调节算法"></a>慢反馈调节算法</h4><p>当thread cache向central cache申请内存时，central cache应该给出多少个对象呢？这是一个值得思考的问题，如果central cache给的太少，那么thread cache在短时间内用完了又会来申请；但如果一次性给的太多了，可能thread cache用不完也就浪费了。</p><p>鉴于此，我们这里采用了一个慢开始反馈调节算法。当thread cache向central cache申请内存时，如果申请的是较小的对象，那么可以多给一点，但如果申请的是较大的对象，就可以少给一点。</p><p>通过下面这个函数，我们就可以根据所需申请的对象的大小计算出具体给出的对象个数，并且可以将给出的对象个数控制到2~512个之间。也就是说，就算thread cache要申请的对象再小，我最多一次性给出512个对象；就算thread cache要申请的对象再大，我至少一次性给出2个对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> size_t <span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//[2, 512] ,依次批量移动多少个对象的（慢启动）上限值</span>    <span class="token comment">//小对象一次批量的上限高</span>    <span class="token comment">//大对象一次批量的上限低</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> MAX_BYTES <span class="token operator">/</span> size<span class="token punctuation">;</span>    <span class="token comment">//下限（一个对象很大的情况下，只取一个对象太小了）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//上限（8字节的对象依次会取太多）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">512</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但就算申请的是小对象，一次性给出512个也是比较多的，基于这个原因，我们可以在FreeList结构中增加一个叫做<code>_maxSize</code>的成员变量，该变量的初始值设置为1，并且提供一个公有成员函数用于获取这个变量。也就是说，现在thread cache中的每个自由链表都会有一个自己的<code>_maxSize</code>。</p><p><strong>也就是说，我将之前的这个NumMoveSize作为一个上限，保证每次申请的值不超过NumMoveSize的返回值</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//管理切分好的小对象的自由链表</span><span class="token keyword">class</span> <span class="token class-name">FreeList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>size_t<span class="token operator">&amp;</span> <span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _maxSize<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//自由链表</span>size_t _maxSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时当thread cache申请对象时，我们会比较<code>_maxSize</code>和计算得出的值，取出其中的较小值作为本次申请对象的个数。此外，如果本次采用的是<code>_maxSize</code>的值，那么还会将thread cache中该自由链表的<code>_maxSize</code>的值进行加一。</p><p>因此，thread cache第一次向central cache申请某大小的对象时，申请到的都是一个，但下一次thread cache再向central cache申请同样大小的对象时，因为该自由链表中的<code>_maxSize</code>增加了，最终就会申请到两个。直到该自由链表中<code>_maxSize</code>的值，增长到超过计算出的值后就不会继续增长了，此后申请到的对象个数就是计算出的个数。（这有点像网络中拥塞控制的机制）</p><h4 id="FetchFromCentralCache"><a href="#FetchFromCentralCache" class="headerlink" title="FetchFromCentralCache"></a>FetchFromCentralCache</h4><p>每次thread cache向central cache申请对象时，我们先通过慢开始反馈调节算法计算出本次应该申请的对象的个数，然后再向central cache进行申请。</p><p>如果thread cache最终申请到对象的个数就是一个，那么直接将该对象返回即可。为什么需要返回一个申请到的对象呢？因为thread cache要向central cache申请对象，其实由于某个线程向thread cache申请对象但thread cache当中没有，这才导致thread cache要向central cache申请对象。因此central cache将对象返回给thread cache后，thread cache会再将该对象返回给申请对象的线程。</p><p>但如果thread cache最终申请到的是多个对象，那么除了将第一个对象返回之外，还需要将剩下的对象挂到thread cache对应的哈希桶当中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">FetchFromCentralCache</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//慢开始的调节算法</span><span class="token comment">/* 1. 最开始的时候不会依次向中心缓存要太多，因为一下太多了就会用不完 * 2. 如果你不要这个size大小的 内存需求，那么batchNum就会向上增长到上限 * 3. size越大，一次向中心缓存要的batch就小 * 4. size越小，一次向中心缓存要的batch就大 */</span><span class="token comment">//自己有一个最小值这里的设置作为一个获取的上限</span>size_t batchNum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>batchNum <span class="token operator">==</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>_freeLists<span class="token operator">-&gt;</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> end <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//返回值是实际返回的值</span>size_t actualNum <span class="token operator">=</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">FetchRangeObject</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> batchNum<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>actualNum <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>actualNum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> start<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> start<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="FetchRangeObject"><a href="#FetchRangeObject" class="headerlink" title="FetchRangeObject"></a>FetchRangeObject</h4><p>这里我们要从central cache获取n个指定大小的对象，这些对象肯定都是从central cache对应哈希桶的某个span中取出来的，因此取出来的这n个对象是链接在一起的，我们只需要得到这段链表的头和尾即可，这里可以采用输出型参数进行获取。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">FetchRangeObject</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> size_t batchNum<span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加锁</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实现锁内的逻辑</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token function">GetOneSpan</span><span class="token punctuation">(</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//对应的桶里面获得span</span><span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span>start <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span><span class="token comment">//end需要往后走batchNum - 1</span>end <span class="token operator">=</span> start<span class="token punctuation">;</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>size_t actualNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//需要返回的参数</span><span class="token comment">//为防止span &lt; batchNum这里使用while循环</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> batchNum <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>end <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token operator">++</span>actualNum<span class="token punctuation">;</span><span class="token punctuation">}</span>span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_useCount <span class="token operator">+=</span> actualNum<span class="token punctuation">;</span><span class="token comment">//更新被分配给thread cache的计数</span><span class="token comment">//解锁</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> actualNum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于central cache是所有线程共享的，所以我们在访问central cache中的哈希桶时，需要先给对应的哈希桶加上桶锁，在获取到对象后再将桶锁解掉。</p><p>在向central cache获取对象时，先是在central cache对应的哈希桶中获取到一个非空的span，然后从这个span的自由链表中取出n个对象即可，但可能这个非空的span的自由链表当中对象的个数不足n个，这时该自由链表当中有多少个对象就给多少就行了。GetOneSpan函数后期实现</p><p>也就是说，thread cache实际从central cache获得的对象的个数可能与我们传入的n值是不一样的，因此我们需要统计本次申请过程中，实际thread cache获取到的对象个数，然后根据该值及时更新这个span中的小对象被分配给thread cache的计数。</p><p>需要注意的是，虽然我们实际申请到对象的个数可能比n要小，但这并不会产生任何影响。因为thread cache的本意就是向central cache申请一个对象，我们之所以要一次多申请一些对象，是因为这样一来下次线程再申请相同大小的对象时就可以直接在thread cache里面获取了，而不用再向central cache申请对象。</p><h4 id="PushRange"><a href="#PushRange" class="headerlink" title="PushRange"></a>PushRange</h4><p>如果thread cache最终从central cache获取到的对象个数是大于一的，那么我们还需要将剩下的对象插入到thread cache中对应的哈希桶中，为了能让<strong>自由链表支持插入一段范围的对象</strong>，我们还需要在FreeList类中增加一个对应的成员函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>    _freeList <span class="token operator">=</span> start<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="page-cache-1"><a href="#page-cache-1" class="headerlink" title="page cache"></a>page cache</h2><h3 id="page-cache框架"><a href="#page-cache框架" class="headerlink" title="page cache框架"></a>page cache框架</h3><h4 id="page-cache与central-cache相同之处"><a href="#page-cache与central-cache相同之处" class="headerlink" title="page cache与central cache相同之处"></a>page cache与central cache相同之处</h4><p>page cache与central cache一样，它们都是哈希桶的结构，并且page cache的每个哈希桶中里挂的也是一个个的span，这些span也是按照双链表的结构链接起来的。</p><h4 id="page-cache与central-cache不同之处"><a href="#page-cache与central-cache不同之处" class="headerlink" title="page cache与central cache不同之处"></a>page cache与central cache不同之处</h4><p>首先，<strong>central cache的映射规则与thread cache保持一致</strong>，<strong>而page cache的映射规则与它们都不相同。</strong>page cache的哈希桶映射规则采用的是<strong>直接定址法</strong>，比如1号桶挂的都是1页的span，2号桶挂的都是2页的span，以此类推。</p><p>其次，central cache每个桶中的span被切成了一个个对应大小的对象，以供thread cache申请。而page cache当中的span是没有被进一步切小的，因为page cache服务的是central cache，当central cache没有span时，向page cache申请的是某一固定页数的span，而如何切分申请到的这个span就应该由central cache自己来决定。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209021448911.png" alt="image-20220902144759770"></p><p>至于page cache当中究竟有多少个桶，这就要看你最大想挂几页的span了，这里我们就最大挂128页的span，为了让桶号与页号对应起来，我们可以将第0号桶空出来不用，因此我们需要将哈希桶的个数设置为129。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> size_t NPAGES <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span> <span class="token comment">//pagebucket num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么这里最大挂128页的span呢？因为线程申请单个对象最大是256KB，而128页可以被切成4个256KB的对象，因此是足够的。当然，如果你想在page cache中挂更大的span也是可以的，根据具体的需求进行设置就行了。</p><h3 id="获取k个span"><a href="#获取k个span" class="headerlink" title="获取k个span"></a>获取k个span</h3><p>如果central cache要获取一个n页的span，那我们就可以在page cache的第n号桶中取出一个span返回给central cache即可，但如果第n号桶中没有span了，<strong>这时我们并不是直接转而向堆申请一个n页的span，而是要继续在后面的桶当中寻找span。</strong></p><p><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>为什么不直接向堆申请？</strong></p><blockquote><p>直接向堆申请以页为单位的内存时，我们应该尽量申请大块一点的内存块，因为此时申请到的内存是连续的，当线程需要内存时我们可以将其切小后分配给线程，而当线程将内存释放后我们又可以将其合并成大块的连续内存。如果我们向堆申请内存时是小块小块的申请的，那么我们申请到的内存就不一定是连续的了。</p></blockquote><p>因此，当第n号桶中没有span时，我们可以继续找第n+1号桶，因为我们可以将n+1页的span切分成一个n页的span和一个1页的span，这时我们就可以将n页的span返回，而将切分后1页的span挂到1号桶中。但如果后面的桶当中都没有span，这时我们就只能向堆申请一个128页的内存块，并将其用一个span结构管理起来，然后将128页的span切分成n页的span和128-n页的span，其中n页的span返回给central cache，而128-n页的span就挂到第128-n号桶中。</p><p><strong>也就是说，我们每次向堆申请的都是128页大小的内存块，central cache要的这些span实际都是由128页的span切分出来的。</strong></p><h3 id="page-cache实现"><a href="#page-cache实现" class="headerlink" title="page cache实现"></a>page cache实现</h3><h4 id="page-cache-要加锁吗？"><a href="#page-cache-要加锁吗？" class="headerlink" title="page cache 要加锁吗？"></a>page cache 要加锁吗？</h4><p>当每个线程的thread cache没有内存时都会向central cache申请，此时多个线程的thread cache如果访问的不是central cache的同一个桶，那么这些线程是可以同时进行访问的。这时central cache的多个桶就可能同时向page cache申请内存的，所以page cache也是存在线程安全问题的，因此在访问page cache时也必须要加锁。</p><h4 id="使用桶锁吗？"><a href="#使用桶锁吗？" class="headerlink" title="使用桶锁吗？"></a>使用桶锁吗？</h4><p>但是在page cache这里我们不能使用桶锁，因为当central cache向page cache申请内存时，page cache可能会将其他桶当中大页的span切小后再给central cache。此外，当central cache将某个span归还给page cache时，page cache也会尝试将该span与其他桶当中的span进行合并。</p><p>也就是说，在访问page cache时，我们可能需要访问page cache中的多个桶，如果page cache用桶锁就会出现大量频繁的加锁和解锁，导致程序的效率低下（for循环外面的加锁和for循环里面的加锁）。因此我们在访问page cache时使用没有使用桶锁，而是用一个大锁将整个page cache给锁住。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209021536631.png" alt="image-20220902153611534"></p><h4 id="为什么central-cache用桶锁"><a href="#为什么central-cache用桶锁" class="headerlink" title="为什么central cache用桶锁"></a>为什么central cache用桶锁</h4><p>而thread cache在访问central cache时，只需要访问central cache中对应的哈希桶就行了，因为central cache的每个哈希桶中的span都被切分成了对应大小，thread cache只需要根据自己所需对象的大小访问central cache中对应的哈希桶即可，不会访问其他哈希桶，因此central cache可以用桶锁。</p><p><strong>此外，page cache在整个进程中也是只能存在一个的，因此我们也需要将其设置为单例模式。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PageCache</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">static</span> PageCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInstan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//获取K页的span</span>Span<span class="token operator">*</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>SpanList _spanLists<span class="token punctuation">[</span>NPAGES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//分桶的连着不同的页数</span>std<span class="token double-colon punctuation">::</span>mutex _pagemtx<span class="token punctuation">;</span> <span class="token comment">//大锁</span><span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">static</span> PageCache _sInstan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当程序运行起来后我们就立马创建该对象即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">PageCache PageCache<span class="token double-colon punctuation">::</span>_sInst<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="page-cache中获取Span"><a href="#page-cache中获取Span" class="headerlink" title="page cache中获取Span"></a>page cache中获取Span</h3><h4 id="GetOneSpan"><a href="#GetOneSpan" class="headerlink" title="GetOneSpan"></a>GetOneSpan</h4><p>thread cache向central cache申请对象时，central cache需要先从对应的哈希桶中获取到一个非空的span，然后从这个非空的span中取出若干对象返回给thread cache。那central cache到底是如何从对应的哈希桶中，获取到一个非空的span的呢？</p><h4 id="桶中有余"><a href="#桶中有余" class="headerlink" title="桶中有余"></a>桶中有余</h4><p>首先当然是先遍历central cache对应哈希桶当中的双链表，如果该双链表中有非空的span，那么直接将该span进行返回即可。为了方便遍历这个双链表，我们可以模拟迭代器的方式，给SpanList类提供Begin和End成员函数，分别用于获取双链表中的第一个span和最后一个span的下一个位置，也就是头结点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span><span class="token keyword">class</span> <span class="token class-name">SpanList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>Span<span class="token operator">*</span> <span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span><span class="token punctuation">}</span>Span<span class="token operator">*</span> <span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Span<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span> <span class="token comment">//桶锁</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="桶中空空"><a href="#桶中空空" class="headerlink" title="桶中空空"></a>桶中空空</h4><p>但如果遍历双链表后发现双链表中没有span，或该双链表中的span都为空，那么此时central cache就需要向page cache申请内存块了。</p><p>那具体是向page cache申请多大的内存块呢？我们可以根据具体所需对象的大小来决定，就像之前我们根据对象的大小计算出，thread cache一次向central cache申请对象的个数上限，现在我们是<strong>根据对象的大小计算出，central cache一次应该向page cache申请几页的内存块。</strong></p><p>我们可以先根据对象的大小计算出，thread cache一次向central cache申请对象的个数上限，然后将这个上限值乘以单个对象的大小，就算出了<strong>具体需要多少字节</strong>，最后再将这个算出来的字节数转换为页数，如果转换后不够一页，那么我们就申请一页，否则转换出来是几页就申请几页。也就是说，central cache向page cache申请内存时，要求申请到的内存尽量能够满足thread cache向central cache申请时的上限</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//管理对齐和映射等关系</span><span class="token keyword">class</span> <span class="token class-name">SizeAlignment</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//central cache一次向page cache获取多少页</span><span class="token comment">//单个对象 8Bytes - 256KB</span><span class="token comment">//size-&gt;单个对象的大小</span><span class="token keyword">static</span> size_t <span class="token function">NumMovePage</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>size_t num_limit <span class="token operator">=</span> <span class="token function">NumMoveSize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取能获取的对象的上限</span>size_t actual_Byte <span class="token operator">=</span> num_limit <span class="token operator">*</span> size<span class="token punctuation">;</span><span class="token comment">//实际申请的对象的总大小</span>size_t npage <span class="token operator">=</span> actual_Byte <span class="token operator">&gt;&gt;</span> PAEG_SHIFT<span class="token punctuation">;</span>  <span class="token comment">//和页的转换 8K</span><span class="token keyword">if</span><span class="token punctuation">(</span>npage <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>npage <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> npage<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中的<code>PAGE_SHIFT</code>代表页大小转换偏移，我们这里以页的大小为8K为例，<code>PAGE_SHIFT</code>的值就是13。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//页大小转换偏移，即一页定义为2^13，也就是8KB</span><span class="token keyword">static</span> <span class="token keyword">const</span> size_t PAGE_SHIFT <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="挂接"><a href="#挂接" class="headerlink" title="挂接"></a>挂接</h4><p>需要注意的是，当central cache申请到若干页的span后，还需要将这个span切成一个个对应大小的对象挂到该span的自由链表当中。</p><p>如何找到一个span所管理的内存块呢？<strong>首先需要计算出该span的起始地址</strong>，我们可以用这个span的起始页号乘以一页的大小即可得到这个span的起始地址，然后用这个span的页数乘以一页的大小就可以得到这个span所管理的内存块的大小，用起始地址加上内存块的大小即可得到这块内存块的结束位置。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209022133383.png" alt="image-20220902213347301"></p><blockquote><p>这张图片显示的是切片和链接的逻辑</p></blockquote><p>明确了这块内存的起始和结束位置后，我们就可以进行切分了。根据所需对象的大小，每次从大块内存切出一块固定大小的内存块尾插到span的自由链表中即可。</p><p>为什么是尾插呢？因为我们如果是将切好的对象尾插到自由链表，这些对象看起来是按照链式结构链接起来的，而实际它们在物理上是连续的，这时当我们把这些连续内存分配给某个线程使用时，可以提高该线程的CPU缓存利用率。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取一个非空的span</span>Span<span class="token operator">*</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetOneSpan</span><span class="token punctuation">(</span>SpanList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//看看当前的Page桶里面还有没有剩余的span对象在List中</span>Span<span class="token operator">*</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//只要挂着有对象就返回</span><span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">-&gt;</span>_freeList <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> it<span class="token punctuation">;</span><span class="token keyword">else</span>it <span class="token operator">=</span> it<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//没有空闲的Span了，只能找其他的桶上面换Span，再不行就在page类中找堆</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*切分，然后挂载*/</span><span class="token comment">//1. 找到起始地址</span><span class="token keyword">char</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAEG_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 计算span大块内存的大小（字节数）</span>size_t bytes <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;&lt;</span> PAEG_SHIFT<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> end <span class="token operator">=</span> start <span class="token operator">+</span> bytes<span class="token punctuation">;</span><span class="token comment">//3. 切割 + 尾插</span><span class="token comment">/*把大块内存切成自由链表链接起来，先切下来一个做头节点，方便尾插*/</span>span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>start <span class="token operator">+=</span> size<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> tail <span class="token operator">=</span>span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>tail <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//tail往后走</span>start <span class="token operator">+=</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//这里是一个BUG</span>    <span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//尾的指向置空</span><span class="token comment">//不能忘记要插入span</span>list<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> span<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，当我们把span切好后，需要将这个切好的span挂到central cache的对应哈希桶中。因此SpanList类还需要提供一个接口，用于将一个span插入到该双链表中。这里我们选择的是头插，这样当central cache下一次从该双链表中获取非空span时，一来就能找到。</p><p>由于SpanList类之前实现了Insert和Begin函数，这里实现双链表头插就非常简单，直接在双链表的Begin位置进行Insert即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span><span class="token keyword">class</span> <span class="token class-name">SpanList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">PushFront</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Span<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span> <span class="token comment">//桶锁</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取一个k页的span"><a href="#获取一个k页的span" class="headerlink" title="获取一个k页的span"></a>获取一个k页的span</h3><p>当我们调用上述的GetOneSpan从central cache的某个哈希桶获取一个非空的span时，如果遍历哈希桶中的双链表后发现双链表中没有span，或该双链表中的span都为空，那么此时central cache就需要向page cache申请若干页的span了，下面我们就来说说如何从page cache获取一个k页的span。</p><h4 id="补充函数"><a href="#补充函数" class="headerlink" title="补充函数"></a>补充函数</h4><p>因为page cache是直接按照页数进行映射的，因此我们要从page cache获取一个k页的span，就应该直接先去找page cache的第k号桶，如果第k号桶中有span，那我们直接头删一个span返回给central cache就行了。所以我们这里需要再给SpanList类添加对应的Empty和PopFront函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span><span class="token keyword">class</span> <span class="token class-name">SpanList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _head <span class="token operator">==</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span><span class="token punctuation">}</span>Span<span class="token operator">*</span> <span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Span<span class="token operator">*</span> front <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span><span class="token function">Erase</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> front<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Span<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>mutex _mtx<span class="token punctuation">;</span> <span class="token comment">//桶锁</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="处理分配"><a href="#处理分配" class="headerlink" title="处理分配"></a>处理分配</h4><p>如果page cache的第k号桶中没有span，我们就应该继续找后面的桶，只要后面任意一个桶中有一个n页span，我们就可以将其切分成一个k页的span和一个n-k页的span，<strong>然后将切出来k页的span返回给central cache，再将n-k页的span挂到page cache的第n-k号桶即可。</strong></p><p>但如果后面的桶中也都没有span，此时我们就需要向堆申请一个128页的span了，在向堆申请内存时，直接调用我们封装的SystemAlloc函数即可。</p><p>需要注意的是，向堆申请内存后得到的是这块内存的起始地址，此时我们需要将该地址转换为页号。由于我们向堆申请内存时都是按页进行申请的，因此我们直接将该地址除以一页的大小即可得到对应的页号。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第K个桶里面有没有span</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _spanLists<span class="token operator">-&gt;</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//检查一下后面的 桶里面有没有span，如果有的话，把它进行切分</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Span<span class="token operator">*</span> nSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//切</span>Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span><span class="token comment">//在nSpan的头部切k页下来</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> nSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>  <span class="token comment">//修改起始地址</span>kSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token comment">//获得k页</span>nSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+=</span> k<span class="token punctuation">;</span> <span class="token comment">//起始页号修改</span>nSpan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span><span class="token comment">//页数修改</span><span class="token comment">//将剩下的挂到对应映射的位置</span>_spanLists<span class="token punctuation">[</span>nSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//已经没有任何Span了</span>Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//128</span><span class="token comment">//指针转化页号</span>bigSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>  <span class="token comment">//初始页号</span>bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//挂载</span>_spanLists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//尽量避免代码重复，递归调用自己s，相当于第一遍走一个堆申请，第二遍返回span</span><span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里说明一下，当我们向堆申请到128页的span后，需要将其切分成k页的span和128-k页的span，但是为了尽量避免出现重复的代码，我们最好不要再编写对应的切分代码。我们可以先将申请到的128页的span挂到page cache对应的哈希桶中，然后再递归调用该函数就行了，此时在往后找span时就一定会在第128号桶中找到该span，然后进行切分。</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>首先搞清楚不可以在这里加锁，递归枷锁会把自己锁住（递归锁会解决，或者可以分离子函数），下面看看大佬的方式</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031008912.png" alt="image-20220903100849784"></p><p>这里其实有一个问题：当central cache向page cache申请内存时，central cache对应的哈希桶是处于加锁的状态的，那在访问page cache之前我们应不应该把central cache对应的桶锁解掉呢？</p><p>这里建议在访问page cache前，先把central cache对应的桶锁解掉。虽然此时central cache的这个桶当中是没有内存供其他thread cache申请的，但thread cache<strong>除了申请内存还会释放内存</strong>，如果在访问page cache前将central cache对应的桶锁解掉，那么此时当其他thread cache想要归还内存到central cache的这个桶时就不会被阻塞。</p><p>因此在调用NewSpan函数之前，我们需要先将central cache对应的桶锁解掉，然后再将page cache的大锁加上，当申请到k页的span后，我们需要将page cache的大锁解掉，但此时我们不需要立刻获取到central cache中对应的桶锁。因为central cache拿到k页的span后还会对其进行切分操作，因此我们可以在span切好后需要将其挂到central cache对应的桶上时，再获取对应的桶锁。</p><p>这里为了让代码清晰一点，只写出了加锁和解锁的逻辑，我们只需要将这些逻辑添加到之前实现的GetOneSpan函数的对应位置即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">spanList<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解桶锁</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加大锁</span><span class="token comment">//从page cache申请k页的span</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解大锁</span><span class="token comment">//进行span的切分...</span>spanList<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加桶锁</span><span class="token comment">//将span挂到central cache对应的哈希桶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="申请内存过程联调"><a href="#申请内存过程联调" class="headerlink" title="申请内存过程联调"></a>申请内存过程联调</h2><p>先去调试一下申请内存过程的话，后期再做释放内存过程的话会更好调试</p><h3 id="关于SystemAlloc"><a href="#关于SystemAlloc" class="headerlink" title="关于SystemAlloc"></a>关于SystemAlloc</h3><p>对于调用堆申请内存来说，这里我们需要如果在Windows上的话我们就需要包含头文件&lt;windows.h&gt;，这里说一下编译时会出现的问题，在C++的algorithm头文件中有一个min函数，这是一个函数模板，而在Windows.h头文件中也有一个min，这是一个宏。由于调用函数模板时需要进行参数类型的推演，因此当我们调用min函数时，编译器会优先匹配Windows.h当中以宏的形式实现的min，此时当我们以std::min的形式调用min函数时就会产生报错，这就是没有用命名空间进行封装的坏处，这时我们只能选择将std::去掉，让编译器调用Windows.h当中的min。</p><h3 id="ConcurrentAlloc函数"><a href="#ConcurrentAlloc函数" class="headerlink" title="ConcurrentAlloc函数"></a>ConcurrentAlloc函数</h3><p>在将thread cache、central cache以及page cache的申请流程写通了之后，我们就可以向外提供一个ConcurrentAlloc函数，用于申请内存块。每个线程第一次调用该函数时会通过TLS获取到自己专属的thread cache对象，然后每个线程就可以通过自己对应的thread cache申请对象了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//通过TLS，每个线程无锁的获取自己专属的ThreadCache对象</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pTLSThreadCache <span class="token operator">=</span> <span class="token keyword">new</span> ThreadCache<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UnionTest1"><a href="#UnionTest1" class="headerlink" title="UnionTest1"></a>UnionTest1</h3><p>由于在多线程场景下调试观察起来非常麻烦，这里就先不考虑多线程场景，看看在单线程场景下代码的执行逻辑是否符合我们的预期，其次，我们这里就只简单观察在一个桶当中的内存申请就行了。</p><p>下面该线程进行了三次内存申请，这三次内存申请的字节数最终都对齐到了8，此时当线程申请内存时就只会访问到thread cache的第0号桶。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestConcurrentAlloc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p3<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p4<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p5<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p6<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当线程第一次申请内存时，该线程需要通过TLS获取到自己专属的thread cache对象，然后通过这个thread cache对象进行内存申请。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031312714.png" alt="image-20220903131200629"></p><p>在申请内存时通过计算索引到了thread cache的第0号桶，但此时thread cache的第0号桶中是没有对象的，因此thread cache需要向central cache申请内存块。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031312418.png" alt="image-20220903131230326"></p><p>在向central cache申请内存块前，首先通过NumMoveSize函数计算得出，thread cache一次最多可向central cache申请8字节大小对象的个数是512，但由于我们采用的是慢开始算法，因此还需要将上限值与对应自由链表的<code>_maxSize</code>的值进行比较，而此时对应自由链表<code>_maxSize</code>的值是1，所以最终得出本次thread cache向central cache申请8字节对象的个数是1个。</p><p>并且在此之后会将该自由链表中<code>_maxSize</code>的值进行自增，下一次thread cache再向central cache申请8字节对象时最终申请对象的个数就会是2个了。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031313450.png" alt="image-20220903131330371"></p><p>在thread cache向central cache申请对象之前，需要先将central cache的0号桶的锁加上，然后再从该桶获取一个非空的span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031313502.png" alt="image-20220903131356425"></p><p>在central cache的第0号桶获取非空span时，先遍历对应的span双链表，看看有没有非空的span，但此时肯定是没有的，因此在这个过程中我们无法找到一个非空的span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031314713.png" alt="image-20220903131437626"></p><p>那么此时central cache就需要向page cache申请内存了，但在此之前需要先把central cache第0号桶的锁解掉，然后再将page cache的大锁给加上，之后才能向page cache申请内存。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031315386.png" alt="image-20220903131529306"></p><p>在向page cache申请内存时，由于central cache一次给thread cache8字节对象的上限是512，对应就需要4096字节，所需字节数不足一页就按一页算，所以这里central cache就需要向page cache申请一页的内存块。<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031315617.png" alt="image-20220903131546531"></p><p>但此时page cache的第1个桶以及之后的桶当中都是没有span的，因此page cache需要直接向堆申请一个128页的span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031316823.png" alt="image-20220903131622709"></p><p>这里通过监视窗口可以看到，用于管理申请到的128页内存的span信息。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031439178.png" alt="image-20220903143930932"></p><p>我们可以顺便验证一下，按页向堆申请的内存块的起始地址和页号之间是可以相互转换的。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031438711.png" alt="image-20220903143859483"></p><p>现在将申请到的128页的span插入到page cache的第128号桶当中，然后再调用一次NewSpan，在这次调用的时候，虽然在1号桶当中没有span，但是在往后找的过程中就一定会在第128号桶找到一个span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031442942.png" alt="image-20220903144200679"></p><blockquote><p><strong>出现一个报错</strong></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031328465.png" alt="报错信息"></p><p>调试一下发现原因</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031335979.png" alt="image-20220903133542836"></p><p>发现原来是函数写错了，应该是</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031337921.png" alt="image-20220903133729729"></p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031317251.png" alt="image-20220903131737169"></p><p>此时我们就可以把这个128页的span拿出来，切分成1页的span和127页的span，将1页的span返回给central cache，而把127页的span挂到page cache的第127号桶即可。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031445666.png" alt="image-20220903144531372"></p><p>从page cache返回后，就可以把page cache的大锁解掉了，但紧接着还要将获取到的1页的span进行切分，因此这里没有立刻重新加上central cache对应的桶锁。</p><blockquote><p>发现问题</p><p>这里的左移和右移搞反了，应该是乘以大小，拿到了总字节数</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031447247.png" alt="image-20220903144706992"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t bytes <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改一下之后大小就对了</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031318853.png" alt="image-20220903131838780"></p><p>在进行切分的时候，先通过该span的起始页号得到该span的起始地址，然后通过该span的页数得到该span所管理内存块的总的字节数。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031319901.png" alt="image-20220903131902820"></p><p>在确定内存块的开始和结束后，就可以将其切分成一个个8字节大小的对象挂到该span的自由链表中了。在调试过程中通过内存监视窗口可以看到，切分出来的每个8字节大小的对象的前四个字节存储的都是下一个8字节对象的起始地址。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031319217.png" alt="image-20220903131925113"></p><p>当切分结束后再获取central cache第0号桶的桶锁，然后将这个切好的span插入到central cache的第0号桶中，最后再将这个非空的span返回，此时就获取到了一个非空的span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031319892.png" alt="image-20220903131955834"></p><p>由于thread cache只向central cache申请了一个对象，因此拿到这个非空的span后，直接从这个span里面取出一个对象即可，此时该span的_useCount也由0变成了1。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031320286.png" alt="image-20220903132024159"></p><blockquote><p>出现报错</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031341233.png" alt="image-20220903134143017"></p><p>原因是起始这里的actualNum是可以等于1的，这里写错了，改成assert（actualNum&gt;=1）</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031353576.png" alt="image-20220903135310338"></p><p>同时发现这里没有更新，这里对后期的释放流程很有用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">span<span class="token operator">-&gt;</span>_useCount <span class="token operator">+=</span> actualNum<span class="token punctuation">;</span> <span class="token comment">//更新被分配给thread cache的计数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>由于此时thread cache实际只向central cache申请到了一个对象，因此直接将这个对象返回给线程即可。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031320513.png" alt="image-20220903132057436"></p><p>当线程第二次申请内存块时就不会再创建thread cache了，因为第一次申请时就已经创建好了，此时该线程直接获取到对应的thread cache进行内存块申请即可。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031321235.png" alt="image-20220903132126164"></p><p>当该线程第二次申请8字节大小的对象时，此时thread cache的0号桶中还是没有对象的，因为第一次thread cache只向central cache申请了一个8字节对象，因此这次申请时还需要再向central cache申请对象。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031321361.png" alt="image-20220903132142288"></p><p>这时thread cache向central cache申请对象时，thread cache第0号桶中自由链表的_maxSize已经慢增长到2了，所以这次在向central cache申请对象时就会申请2个。如果下一次thread cache再向central cache申请8字节大小的对象，那么central cache会一次性给thread cache3个，这就是所谓的慢增长。<br><img src="C:/Users/Allen/AppData/Roaming/Typora/typora-user-images/image-20220903132223411.png" alt="image-20220903132223411"></p><p>但由于第一次central cache向page cache申请了一页的内存块，并将其切成了1024个8字节大小的对象，因此这次thread cache向central cache申请2两个8字节的对象时，central cache的第0号桶当中是有对象的，直接返回两个给thread cache即可，而不用再向page cache申请内存了。</p><p>但线程实际申请的只是一个8字节对象，因此thread cache除了将一个对象返回之外，还需要将剩下的一个对象挂到thread cache的第0号桶当中。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031323856.png" alt="image-20220903132315784"></p><p>这样一来，当线程第三次申请1字节的内存时，由于1字节对齐后也是8字节，此时thread cache也就不需要再向central cache申请内存块了，直接将第0号桶当中之前剩下的一个8字节对象返回即可。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031455666.png" alt="image-20220903145539405"></p><p>也就是说第一次申请了一块，第二次从central申请了两块内存，然后第三次就直接还有一块，就不用上去要了</p><p>最后测试成功</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031458901.png" alt="image-20220903145824785"></p><h3 id="UnionTest2"><a href="#UnionTest2" class="headerlink" title="UnionTest2"></a>UnionTest2</h3><p>第一次过了就基本怕跑通了，为了进一步测试代码的正确性，我们可以做这样一个测试：让线程申请1024次8字节的对象，然后通过调试观察在第1025次申请时，central cache是否会再向page cache申请内存块。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestConcurrentAlloc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>p1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为central cache第一次就是向page cache申请的一页内存，这一页内存被切成了1024个8字节大小的对象，当这1024个对象全部被申请之后，再申请8字节大小的对象时central cache当中就没有对象了，此时就应该向page cache申请内存块。</p><p>通过调试我们可以看到，第1025次申请8字节大小的对象时，central cache第0号桶中的这个span的<code>_useCount</code>已经增加到了1024，也就是说这1024个对象都已经被线程申请了，此时central cache就需要再向page cache申请一页的span来进行切分了。<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031507441.png" alt="image-20220903150742232"></p><p>而这次central cache在向page cache申请一页的内存时，page cache就是将127页span切分成了1页的span和126页的span了，然后central cache拿到这1页的span后，又会将其切分成1024块8字节大小的内存块以供thread cache申请。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031508580.png" alt="image-20220903150808430"></p><h2 id="thread-cache回收内存"><a href="#thread-cache回收内存" class="headerlink" title="thread cache回收内存"></a>thread cache回收内存</h2><h3 id="Deallocate"><a href="#Deallocate" class="headerlink" title="Deallocate"></a>Deallocate</h3><p>当某个线程申请的对象不用了，可以将其释放给thread cache，然后thread cache将该对象插入到对应哈希桶的自由链表当中即可。</p><p>但是随着线程不断的释放，对应自由链表的长度也会越来越长，这些内存堆积在一个thread cache中就是一种浪费，我们应该将这些内存还给central cache，这样一来，这些内存对其他线程来说也是可申请的，因此当thread cache某个桶当中的自由链表太长时我们可以进行一些处理。</p><p><strong>如果thread cache某个桶当中自由链表的长度超过它一次批量向central cache申请的对象个数</strong>，那么此时我们就要把该自由链表当中的这些对象还给central cache。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">Deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到对应的桶插进去</span>size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 当链表长度大于一次批量申请的内存时就开始还一段list给central cache</span><span class="token keyword">if</span> <span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> _freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">ListTooLong</span><span class="token punctuation">(</span>_freeLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ListTooLong"><a href="#ListTooLong" class="headerlink" title="ListTooLong"></a>ListTooLong</h3><p>当自由链表的长度大于一次批量申请的对象时，我们具体的做法就是，从该自由链表中取出一次批量个数的对象，然后将取出的这些对象还给central cache中对应的span即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ThreadCache</span><span class="token double-colon punctuation">::</span><span class="token function">ListTooLong</span><span class="token punctuation">(</span>FreeList<span class="token operator">&amp;</span> list<span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> end <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">PopRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码可以看出，FreeList类需要支持用Size函数获取自由链表中对象的个数，还需要支持用PopRange函数从自由链表中取出指定个数的对象。因此我们需要给FreeList类增加一个对应的PopRange函数，然后再增加一个<code>_size</code>成员变量，该成员变量用于记录当前自由链表中对象的个数，当我们向自由链表插入或删除对象时，都应该更新<code>_size</code>的值。</p><h3 id="增加成员变量-size"><a href="#增加成员变量-size" class="headerlink" title="增加成员变量_size"></a>增加成员变量<code>_size</code></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FreeList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 头插</span><span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>_freeList <span class="token operator">=</span> obj<span class="token punctuation">;</span>_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>_freeList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//头删</span><span class="token keyword">void</span><span class="token operator">*</span> obj <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> end<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> _freeList<span class="token punctuation">;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>_size <span class="token operator">+=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//这里接口的设计最好不要一次取完，而是一次去一定数量的，这个可以自己控制</span><span class="token keyword">void</span> <span class="token function">PopRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> start<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&amp;</span> end<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> _size<span class="token punctuation">)</span><span class="token punctuation">;</span>start <span class="token operator">=</span> _freeList<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>end <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//直接跳过中间的</span>_freeList <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>_size <span class="token operator">-=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _freeList <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span>size_t<span class="token operator">&amp;</span> <span class="token function">MaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _maxSize<span class="token punctuation">;</span><span class="token punctuation">}</span>size_t <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>size_t _maxSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>size_t _size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于FreeList类当中的PushRange成员函数，我们最好也像PopRange一样给它增加一个参数，表示插入对象的个数，不然我们这时还需要通过遍历统计插入对象的个数。</p><p>因此之前在调用PushRange的地方就需要修改一下，而我们实际就在一个地方调用过PushRange函数，并且此时插入对象的个数也是很容易知道的。当时thread cache从central cache获取了actualNum个对象，将其中的一个返回给了申请对象的线程，剩下的actualNum-1个挂到了thread cache对应的桶当中，所以这里插入对象的个数就是actualNum-1。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209031605293.png" alt="image-20220903160515219"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>当thread cache的某个自由链表过长时，我们实际就是把这个自由链表当中全部的对象都还给central cache了，但这里在设计PopRange接口时还是设计的是取出指定个数的对象，因为在某些情况下当自由链表过长时，我们可能并不一定想把链表中全部的对象都取出来还给central cache，这样设计就是为了增加代码的可修改性。</p><p>其次，当我们判断thread cache是否应该还对象给central cache时，还可以综合考虑每个thread cache整体的大小。比如当某个thread cache的总占用大小超过一定阈值时，我们就将该thread cache当中的对象还一些给central cache，这样就尽量避免了某个线程的thread cache占用太多的内存。对于这一点，在tcmalloc当中就是考虑到了的。</p><h2 id="central-cache回收内存"><a href="#central-cache回收内存" class="headerlink" title="central cache回收内存"></a>central cache回收内存</h2><p>当thread cache中某个自由链表太长时，会将自由链表当中的这些对象还给central cache中的span。</p><p>但是需要注意的是，还给central cache的这些对象不一定都是属于同一个span的。central cache中的每个哈希桶当中可能都不止一个span，因此当我们计算出还回来的对象应该还给central cache的哪一个桶后，还需要知道这些对象到底应该还给这个桶当中的哪一个span。</p><h3 id="对象的地址-gt-对象所在的页号"><a href="#对象的地址-gt-对象所在的页号" class="headerlink" title="对象的地址->对象所在的页号"></a>对象的地址-&gt;对象所在的页号</h3><p>首先我们必须理解的是，某个页当中的所有地址除以页的大小都等该页的页号。比如我们这里假设一页的大小是100，那么地址<code>0~99</code>都属于第0页，它们除以100都等于0，而地址<code>100~199</code>都属于第1页，它们除以100都等于1。</p><h3 id="如何找到一个对象对应的span？"><a href="#如何找到一个对象对应的span？" class="headerlink" title="如何找到一个对象对应的span？"></a>如何找到一个对象对应的span？</h3><p>虽然我们现在可以通过对象的地址得到其所在的页号，但是我们还是不能知道这个对象到底属于哪一个span。因为一个span管理的可能是多个页。</p><p>为了解决这个问题，我们可以建立页号和span之间的映射。由于这个映射关系在page cache进行span的合并时也需要用到，因此我们直接将其存放到page cache里面。这时我们就需要在PageCache类当中添加一个映射关系了，这里可以用C++当中的unordered_map进行实现，并且添加一个函数接口，用于让central cache获取这里的映射关系。（下面代码中只展示了PageCache类当中新增的成员）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单例模式</span><span class="token keyword">class</span> <span class="token class-name">PageCache</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//获取从对象到span的映射</span>Span<span class="token operator">*</span> <span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>PAGE_ID<span class="token punctuation">,</span> Span<span class="token operator">*</span><span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每当page cache分配span给central cache时，都需要记录一下页号和span之间的映射关系。此后当thread cache还对象给central cache时，才知道应该具体还给哪一个span。</p><p>因此当central cache在调用NewSpan接口向page cache申请k页的span时，page cache在返回这个k页的span给central cache之前，应该建立这k个页号与该span之间的映射关系。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第K个桶里面有没有span</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span><span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>_idSpanMap<span class="token punctuation">[</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//检查一下后面的 桶里面有没有span，如果有的话，把它进行切分</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Span<span class="token operator">*</span> nSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//切</span>Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span><span class="token comment">//在nSpan的头部切k页下来</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> nSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>  <span class="token comment">//修改起始地址</span>kSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token comment">//获得k页</span>nSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+=</span> k<span class="token punctuation">;</span> <span class="token comment">//起始页号修改</span>nSpan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span><span class="token comment">//页数修改</span><span class="token comment">//将剩下的挂到对应映射的位置</span>_spanLists<span class="token punctuation">[</span>nSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>nSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立id和span的映射</span><span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>_idSpanMap<span class="token punctuation">[</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//已经没有任何Span了</span>Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//128</span><span class="token comment">//指针转化页号</span>bigSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>  <span class="token comment">//初始页号</span>bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//挂载</span>_spanLists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//尽量避免代码重复，递归调用自己s，相当于第一遍走一个堆申请，第二遍返回span</span><span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们就可以通过对象的地址找到该对象对应的span了，直接将该对象的地址除以页的大小得到页号，然后在unordered_map当中找到其对应的span即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//页号-&gt;id</span><span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span><span class="token comment">//id-&gt;span</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意一下，当我们要通过某个页号查找其对应的span时，该页号与其span之间的映射一定是建立过的，如果此时我们没有在unordered_map当中找到，则说明我们之前的代码逻辑有问题，因此当没有找到对应的span时可以直接用断言结束程序，以表明程序逻辑出错。</p><h3 id="ReleaseListToSpans"><a href="#ReleaseListToSpans" class="headerlink" title="ReleaseListToSpans"></a>ReleaseListToSpans</h3><p>这时当thread cache还对象给central cache时，就可以依次遍历这些对象，将这些对象插入到其对应span的自由链表当中，并且及时更新该span的_useCount计数即可。</p><p>在thread cache还对象给central cache的过程中，如果central cache中某个span的_useCount减到0时，说明这个span分配出去的对象全部都还回来了，那么此时就可以将这个span再进一步还给page cache。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseListToSpans</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>size_t index <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">Index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加锁</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//怎么知道哪块内存对应的哪个span？</span><span class="token keyword">while</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//头插来还</span><span class="token function">NextObj</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freeList<span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> start<span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_useCount <span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_useCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//说明所有的小块内存都回来了</span><span class="token comment">//span可以回收给page cache，page cache可以再去做前后页的合并</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//还给下一层，桶锁解锁，其他线程也可以还</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//后面还要加一个Page的大锁</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解了大锁之后加上桶锁</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>start <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>_spanLists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意，如果要把某个span还给page cache，我们需要先将这个span从central cache对应的双链表中移除，然后再将该span的自由链表置空，因为page cache中的span是不需要切分成一个个的小对象的，以及该span的前后指针也都应该置空，因为之后要将其插入到page cache对应的双链表中。但span当中记录的起始页号以及它管理的页数是不能清除的，否则对应内存块就找不到了。</p><p>并且在central cache还span给page cache时也存在锁的问题，此时需要先将central cache中对应的桶锁解掉，然后再加上page cache的大锁之后才能进入page cache进行相关操作，当处理完毕回到central cache时，除了将page cache的大锁解掉，还需要立刻获得central cache对应的桶锁，然后将还未还完对象继续还给central cache中对应的span。</p><h2 id="page-cache回收内存"><a href="#page-cache回收内存" class="headerlink" title="page cache回收内存"></a>page cache回收内存</h2><p>如果central cache中有某个span的<code>_useCount</code>减到0了，那么central cache就需要将这个span还给page cache了。</p><p>这个过程看似是非常简单的，page cache只需将还回来的span挂到对应的哈希桶上就行了。但实际为了缓解内存碎片的问题，page cache还需要尝试将还回来的span与其他空闲的span进行合并。</p><h3 id="前后页合并设计"><a href="#前后页合并设计" class="headerlink" title="前后页合并设计"></a>前后页合并设计</h3><p>合并的过程可以分为向前合并和向后合并。如果还回来的span的起始页号是num，该span所管理的页数是n。那么在向前合并时，就需要判断第num-1页对应span是否空闲，如果空闲则可以将其进行合并，并且合并后还需要继续向前尝试进行合并，直到不能进行合并为止。而在向后合并时，就需要判断第num+n页对应的span是否空闲，如果空闲则可以将其进行合并，并且合并后还需要继续向后尝试进行合并，直到不能进行合并为止。</p><p>因此page cache在合并span时，是<strong>需要通过页号获取到对应的span</strong>的，这就是我们要把页号与span之间的映射关系存储到page cache的原因。</p><h4 id="识别页的位置"><a href="#识别页的位置" class="headerlink" title="识别页的位置"></a>识别页的位置</h4><p>但需要注意的是，当我们通过页号找到其对应的span时，这个span此时可能挂在page cache，也可能挂在central cache。而在合并时我们只能合并挂在page cache的span，因为挂在central cache的span当中的对象正在被其他线程使用。</p><p>可是我们不能通过span结构当中的<code>_useCount</code>成员，来判断某个span到底是在central cache还是在page cache。因为当central cache刚向page cache申请到一个span时，这个span的<code>_useCount</code>就是等于0的，这时可能<strong>当我们正在对该span进行切分的时候，page cache就把这个span拿去进行合并了</strong>，这显然是不合理的。</p><p>鉴于此，我们可以在span结构中再增加一个<code>_isUse</code>成员，用于标记这个span是否正在被使用，而当一个span结构被创建时我们默认该span是没有被使用的。</p><p>这是我们就需要修改在centralcache申请完之后，就要设置为true</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041050044.png" alt="image-20220904105010897"></p><p>而当central cache将某个span还给page cache时，也就需要将该span的_isUse改成false。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041051282.png" alt="image-20220904105111197"></p><h4 id="再建立映射关系"><a href="#再建立映射关系" class="headerlink" title="再建立映射关系"></a>再建立映射关系</h4><p>由于在合并page cache当中的span时，需要通过页号找到其对应的span，而一个span是在被分配给central cache时，才建立的各个页号与span之间的映射关系，因此page cache当中的span也需要建立页号与span之间的映射关系。</p><p>与central cache中的span不同的是，在page cache中，只需建立一个span的首尾页号与该span之间的映射关系。因为当一个span在尝试进行合并时，如果是往前合并，那么只需要通过一个span的尾页找到这个span，如果是向后合并，那么只需要通过一个span的首页找到这个span。也就是说，在进行合并时我们只需要用到span与其首尾页之间的映射关系就够了。</p><p>因此当我们申请k页的span时，如果是将n页的span切成了一个k页的span和一个n-k页的span，我们除了需要建立k页span中每个页与该span之间的映射关系之外，还需要建立剩下的n-k页的span与其首尾页之间的映射关系。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041101402.png" alt="image-20220904110131298"></p><p>此时page cache当中的span就都与其首尾页之间建立了映射关系，现在我们就可以进行span的合并了，其合并逻辑如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//对span前后的页，尝试进行合并，缓解内存碎片问题</span>PAGE_ID prevID <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>prevID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向前合并</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//1. 前面页号没有，不合并了</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2. 前面相邻的span在使用，不合并了</span>Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token operator">-&gt;</span>second<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//3. 超过最大span页数，也不能管理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>_spanLists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> prevSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 向后合并</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>PAGE_ID nextId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span><span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>nextId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1. 后面的页号没有，不合并了</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2. 后面相邻的span在使用，不合并了</span>Span<span class="token operator">*</span> nextSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//3. 超过最大span页数，也不能管理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span><span class="token comment">//对应的桶里面删掉</span>_spanLists<span class="token punctuation">[</span>nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> nextSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//连入，然后建立映射，此时已经不在使用了,方便别人合并了</span>_spanLists<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_isUse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageId<span class="token operator">+</span>span<span class="token operator">-&gt;</span>_n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="合并注意事项"><a href="#合并注意事项" class="headerlink" title="合并注意事项"></a>合并注意事项</h4><p>向前合并：</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041103029.png" alt="image-20220904110350922"></p><p>向后合并：</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041118502.png" alt="image-20220904111833433"></p><p>需要注意的是，在向前或向后进行合并的过程中：</p><blockquote><p><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果没有通过页号获取到其对应的span，说明对应到该页的内存块还未申请，此时需要停止合并。<br><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果通过页号获取到了其对应的span，但该span处于被使用的状态，那我们也必须停止合并。<br><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果合并后大于128页则不能进行本次合并，因为page cache无法对大于128页的span进行管理。<br><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在合并span时，由于这个span是在page cache的某个哈希桶的双链表当中的，因此在合并后需要将其从对应的双链表中移除，然后再将这个被合并了的span结构进行delete。</p></blockquote><p><strong>除此之外，在合并结束后，除了将合并后的span挂到page cache对应哈希桶的双链表当中，还需要建立该span与其首位页之间的映射关系，便于此后合并出更大的span。</strong></p><h2 id="释放内存过程联调"><a href="#释放内存过程联调" class="headerlink" title="释放内存过程联调"></a>释放内存过程联调</h2><h3 id="ConcurrentFree"><a href="#ConcurrentFree" class="headerlink" title="ConcurrentFree"></a>ConcurrentFree</h3><p>至此我们将thread cache、central cache以及page cache的释放流程也都写完了，此时我们就可以向外提供一个ConcurrentFree函数，用于释放内存块，释放内存块时每个线程通过自己的thread cache对象，调用thread cache中释放内存对象的接口即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t size<span class="token comment">/*暂时*/</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UnionTest1-1"><a href="#UnionTest1-1" class="headerlink" title="UnionTest1"></a>UnionTest1</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">TestConcurrentAlloc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> p5 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p5<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先解决报错</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041405319.png" alt="image-20220904140527220"></p><p>因为end的赋值是nullptr，少了一行赋值，应该让end能够等于start</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041407696.png" alt="image-20220904140747605"></p><p>解决之后开始调试</p><p>首先，这三次申请和释放的对象大小进行对齐后都是8字节，因此对应操作的就是thread cache和central cache的第0号桶，以及page cache的第1号桶。</p><p>由于第三次对象申请时，刚好将thread cache第0号桶当中仅剩的一个对象拿走了，因此在三次对象申请后thread cache的第0号桶当中是没有对象的。</p><p>通过监视窗口可以看到，此时thread cache第0号桶中自由链表的<code>_maxSize</code>已经慢增长到了3，而当我们释放完第一个对象后，该自由链表当中对象的个数只有一个，因此不会将该自由链表当中的对象进一步还给central cache。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041356736.png" alt="image-20220904135647637"></p><p>当第二个对象释放给thread cache的第0号桶后，该桶对应自由链表当中对象的个数变成了2，也是不会进行ListTooLong操作的。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041357035.png" alt="image-20220904135709933"></p><p>直到第三个对象释放给thread cache的第0号桶时，此时该自由链表的<code>_size</code>的值变为3，与<code>_maxSize</code>的值相等，现在thread cache就需要将对象给central cache了。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041357030.png" alt="image-20220904135729932"></p><p>thread cache先是将第0号桶当中的对象弹出MaxSize个，在这里实际上就是全部弹出，此时该自由链表<code>_size</code>的值变为0，然后继续调用central cache当中的ReleaseListToSpans函数，将这三个对象还给central cache当中对应的span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041357016.png" alt="image-20220904135750937"></p><blockquote><p>下面这里是64位的，申请了6个对象的效果，可以看到映射这里是对的</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041417426.png" alt="image-20220904141750328"></p></blockquote><p>在进入central cache的第0号桶还对象之前，先把第0号桶对应的桶锁加上，然后通过查page cache中的映射表找到其对应的span，最后将这个对象头插到该span的自由链表中，并将该span的<code>_useCount</code>进行–。当第一个对象还给其对应的span时，可以看到该span的<code>_useCount</code>减到了2。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041358697.png" alt="image-20220904135852599"></p><p>而由于我们只进行了三次对象申请，并且这些对象大小对齐后大小都是8字节，因此我们申请的这三个对象实际都是同一个span切分出来的。当我们将这三个对象都还给这个span时，该span的_useCount就减为了0。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041359773.png" alt="image-20220904135914691"></p><p>现在central cache就需要将这个span进一步还给page cache，而在将该span交给page cache之前，会将该span的自由链表以及前后指针都置空。并且在进入page cache之前会先将central cache第0号桶的桶锁解掉，然后再加上page cache的大锁，之后才能进入page cache进行相关操作。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041359373.png" alt="image-20220904135945293"></p><p>由于这个一页的span是从128页的span的头部切下来的，在向前合并时由于前面的页还未向系统申请，因此在查映射关系时是无法找到的，此时直接停止了向前合并。</p><blockquote><p>（说明一下：由于下面是重新另外进行的一次调试，因此监视窗口显示的span的起始页号与之前的不同，实际应该与上面一致）</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041400307.png" alt="image-20220904140014216"></p><p>而在向后合并时，由于page cache没有将该页后面的页分配给central cache，因此在向后合并时肯定能够找到一个127页的span进行合并。合并后就变成了一个128页的span，这时我们将原来127页的span从第127号桶删除，然后还需要将该127页的span结构进行delete，因为它管理的127页已经与1页的span进行合并了，不再需要它来管理了。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041400191.png" alt="image-20220904140035071"></p><blockquote><p>可以看到合并之后的效果是分出去的128页现在又还回来了<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041427340.png" alt="image-20220904142714243"></p></blockquote><p>紧接着将这个128页的span插入到第128号桶，然后建立该span与其首尾页的映射，便于下次被用于合并，最后再将该span的状态设置为未被使用的状态即可。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041400245.png" alt="image-20220904140056169"></p><p>当从page cache回来后，除了将page cache的大锁解掉，还需要立刻加上central cache中对应的桶锁，然后继续将对象还给central cache中的span，但此时实际上是还完了，因此再将central cache的桶锁解掉就行了。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041401763.png" alt="image-20220904140117686"></p><p>至此我们便完成了这三个对象的申请和释放流程。</p><h3 id="多线程场景测试"><a href="#多线程场景测试" class="headerlink" title="多线程场景测试"></a>多线程场景测试</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MultiThreadAlloc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">MultiThreadAlloc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">TestMultiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>MultiThreadAlloc1<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>MultiThreadAlloc2<span class="token punctuation">)</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多线程情况下出现的错误</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041442757.png" alt="image-20220904144231662"></p><p>大佬认为在不同的模块分配的内存，释放的时候会出现此问题，而此问题，只在Debug模式会提示，Release模式不会提示。但不提示并不代表没有错误，一定要解决之。解决的方法是：在哪个模块分配的内存，就在哪个模块释放。</p><p>阅读往上大佬解决该问题的方法，发现改成Release版之后就可以使用了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041443785.png" alt="image-20220904144330717"></p><p>由于这里我们没有涉及到动态库，所以应该是释放的问题</p><p>1，内存不能跨模块分配和释放，模块分配的内存必须由该模块自己来释放。应该在DLL中再加一个方法，比如MemRelease，主程序调用这个方法来释放内存。</p><p>2，就是绕过new和<a href="http://www.so.com/s?q=delete&amp;ie=utf-8&amp;src=se_lighten_f">delete</a>，用GlobalAlloc()和GlobalFree()的方法</p><p>现在就去寻找delete，发现这里没有从桶中取出就delete了span</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041456119.png" alt="image-20220904145649014"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041457241.png" alt="image-20220904145715143"></p><p>而且漏掉了一个break的逻辑，差点出错</p><p>现在运行通过了</p><h2 id="一次申请大于256KB的大块内存"><a href="#一次申请大于256KB的大块内存" class="headerlink" title="一次申请大于256KB的大块内存"></a>一次申请大于256KB的大块内存</h2><p>申请过程</p><p>之前说到，每个线程的thread cache是用于申请小于等于256KB的内存的，而对于大于256KB的内存，我们可以考虑直接向page cache申请，但page cache中最大的页也就只有128页，因此如果是大于128页的内存申请，就只能直接向堆申请了。</p><table><thead><tr><th>申请内存的大小</th><th>申请方式</th><th>注</th></tr></thead><tbody><tr><td>x≤256KB(32页)</td><td>向thread cache申请</td><td>当申请的内存大于256KB时，虽然不是从thread cache进行获取，但在分配内存时也是需要进行向上对齐的，</td></tr><tr><td>32页&lt;x≤128页</td><td>向page cache申请</td><td>对于大于256KB的内存我们可以直接按页进行对齐。</td></tr><tr><td>x≥128页</td><td>向堆申请</td><td></td></tr></tbody></table><p>而我们之前实现RoundUp函数时，对传入字节数大于256KB的情况直接做了断言处理，因此这里需要对RoundUp函数稍作修改。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取向上对齐后的字节数</span><span class="token keyword">static</span> <span class="token keyword">inline</span> size_t <span class="token function">RoundUp</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&lt;=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//大于256KB的按页对齐</span><span class="token keyword">return</span> <span class="token function">_RoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在对于之前的申请逻辑就需要进行修改了，当申请对象的大小大于256KB时，就不用向thread cache申请了，这时先计算出按页对齐后实际需要申请的页数，然后通过调用NewSpan申请指定页数的span即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">{</span>size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>size_t kpage <span class="token operator">=</span> alignSize<span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>kpage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>pTLSThreadCache <span class="token operator">=</span> <span class="token keyword">new</span> ThreadCache<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> pTLSThreadCache <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，申请大于256KB的内存时，会直接调用page cache当中的NewSpan函数进行申请，因此这里我们需要再对NewSpan函数进行改造，当需要申请的内存页数大于128页时，就直接向堆申请对应页数的内存块。而如果申请的内存页数是小于128页的，那就在page cache中进行申请，因此当申请大于256KB的内存调用NewSpan函数时也是需要加锁的，因为我们可能是在page cache中进行申请的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//堆中获取</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token keyword">new</span> Span<span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>        _idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span><span class="token keyword">return</span> span<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>###释放过程</p><p>当释放对象时，我们需要判断释放对象的大小：</p><table><thead><tr><th>释放内存的大小</th><th>释放方式</th></tr></thead><tbody><tr><td>x≤256KB(32页)</td><td>释放给thread cache</td></tr><tr><td>32页&lt;x≤128页</td><td>释放给page cache</td></tr><tr><td>x≥128页</td><td>释放给堆</td></tr></tbody></table><p>因此当释放对象时，我们需要先找到该对象对应的span，但是在释放对象时我们只知道该对象的起始地址。这也就是我们在申请大于256KB的内存时，也要给申请到的内存建立span结构，并建立起始页号与该span之间的映射关系的原因。此时我们就可以通过释放对象的起始地址计算出起始页号，进而通过页号找到该对象对应的span。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//指针转换成页号</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//还回去的时候要加锁</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此page cache在回收span时也需要进行判断，如果该span的大小是小于等于128页的，那么直接还给page cache进行了，page cache会尝试对其进行合并。而如果该span的大小是大于128页的，那么说明该span是直接向堆申请的，我们直接将这块内存释放给堆，然后将这个span结构进行delete就行了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//大于128页直接向堆申请</span><span class="token keyword">if</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从id拿到指针地址</span><span class="token function">SystemFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> span<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">// . . .</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明一下，直接向堆申请内存时我们调用的接口是VirtualAlloc，与之对应的将内存释放给堆的接口叫做VirtualFree，而Linux下的brk和mmap对应的释放接口叫做sbrk和unmmap。此时我们也可以将这些释放接口封装成一个叫做SystemFree的接口，当我们需要将内存释放给堆时直接调用SystemFree即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SystemFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>    <span class="token function">VirtualFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MEM_RELEASE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token comment">// sbrk unmmap等</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>下面我们对大于256KB的申请释放流程进行简单的测试：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//找page cache申请</span><span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">257</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//257KB</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token number">257</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找堆申请</span><span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">129</span> <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//129页</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token number">129</span> <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>发现错误</strong></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041632397.png" alt="image-20220904163255236"></p><p>发现是这里桶里面找不到对象，所以就会直接走到assert的报错</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041635066.png" alt="image-20220904163524895"></p><p>原来是这里没有建立桶的映射，所以进去补一下</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041630049.png" alt="image-20220904163044895"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041636369.png" alt="image-20220904163618219"></p><p>改一下就对了</p><p>当申请257KB的内存时，由于257KB的内存按页向上对齐后是33页，并没有大于128页，因此不会直接向堆进行申请，会向page cache申请内存，但此时page cache当中实际是没有内存的，最终page cache就会向堆申请一个128页的span，将其切分成33页的span和95页的span，并将33页的span进行返回。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041638486.png" alt="image-20220904163822336"></p><p>而在释放内存时，由于该对象的大小大于了256KB，因此不会将其还给thread cache，而是直接调用的page cache当中的释放接口。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041638287.png" alt="image-20220904163834138"></p><p>由于该对象的大小是33页，不大于128页，因此page cache也不会直接将该对象还给堆，而是尝试对其进行合并，最终就会把这个33页的span和之前剩下的95页的span进行合并，最终将合并后的128页的span挂到第128号桶中。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041638771.png" alt="image-20220904163849624"></p><p>当申请129页的内存时，由于是大于256KB的，于是还是调用的page cache对应的申请接口，但此时申请的内存同时也大于128页，因此会直接向堆申请。在申请后还会建立该span与其起始页号之间的映射，便于释放时可以通过页号找到该span。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041639407.png" alt="image-20220904163908236"></p><p>在释放内存时，通过对象的地址找到其对应的span，从span结构中得知释放内存的大小大于128页，于是会将该内存直接还给堆。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209041639160.png" alt="image-20220904163922653"></p><h2 id="定长内存池配合脱离使用new"><a href="#定长内存池配合脱离使用new" class="headerlink" title="定长内存池配合脱离使用new"></a>定长内存池配合脱离使用new</h2><p>tcmalloc是要在高并发场景下替代malloc进行内存申请的，因此tcmalloc在实现的时，其内部是不能调用malloc函数的，我们当前的代码中存在通过new获取到的内存，而new在底层实际上就是封装了malloc。</p><p>为了完全脱离掉malloc函数，此时我们之前实现的定长内存池就起作用了，代码中使用new时基本都是为Span结构的对象申请空间，而span对象基本都是在page cache层创建的，因此我们可以在PageCache类当中定义一个<code>_spanPool</code>，用于span对象的申请和释放。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单例模式</span><span class="token keyword">class</span> <span class="token class-name">PageCache</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//...</span><span class="token keyword">private</span><span class="token operator">:</span>ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将代码中使用new的地方替换为调用定长内存池当中的New函数，将代码中使用delete的地方替换为调用定长内存池当中的Delete函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//申请span对象</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放span对象</span>_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，当使用定长内存池当中的New函数申请Span对象时，New函数通过定位new也是对Span对象进行了初始化的。</p><p>此外，每个线程第一次申请内存时都会创建其专属的thread cache，而这个thread cache目前也是new出来的，我们也需要对其进行替换。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//通过TLS，每个线程无锁的获取自己专属的ThreadCache对象</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>mutex tcMtx<span class="token punctuation">;</span><span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>ThreadCache<span class="token operator">&gt;</span> tcPool<span class="token punctuation">;</span>tcMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pTLSThreadCache <span class="token operator">=</span> tcPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tcMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们将用于申请ThreadCache类对象的定长内存池定义为静态的，保持全局只有一个，让所有线程创建自己的thread cache时，都在个定长内存池中申请内存就行了。</p><p>但注意在从该定长内存池中申请内存时需要加锁，防止多个线程同时申请自己的ThreadCache对象而导致线程安全问题。</p><p>最后在SpanList的构造函数中也用到了new，因为SpanList是带头循环双向链表，所以在构造期间我们需要申请一个span对象作为双链表的头结点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//带头双向循环链表</span><span class="token keyword">class</span> <span class="token class-name">SpanList</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">SpanList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>_head <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>Span<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于每个span双链表只需要一个头结点，因此将这个定长内存池定义为静态的，保持全局只有一个，让所有span双链表在申请头结点时，都在一个定长内存池中申请内存就行了。</p><h2 id="优化使用和map相关锁"><a href="#优化使用和map相关锁" class="headerlink" title="优化使用和map相关锁"></a>优化使用和map相关锁</h2><h3 id="优化释放内存不需要传入大小"><a href="#优化释放内存不需要传入大小" class="headerlink" title="优化释放内存不需要传入大小"></a>优化释放内存不需要传入大小</h3><p>当我们使用malloc函数申请内存时，需要指明申请内存的大小；而当我们使用free函数释放内存时，只需要传入指向这块内存的指针即可。而我们目前实现的内存池，在释放对象时除了需要传入指向该对象的指针，还需要传入该对象的大小。</p><p>原因如下：</p><ul><li>如果释放的是大于256KB的对象，需要根据对象的大小来判断这块内存到底应该还给page cache，还是应该直接还给堆。</li><li>如果释放的是小于等于256KB的对象，需要根据对象的大小计算出应该还给thread cache的哪一个哈希桶。</li></ul><p>如果我们也想做到，在释放对象时不用传入对象的大小，那么我们就需要建立对象地址与对象大小之间的映射。由于现在可以通过对象的地址找到其对应的span，而span的自由链表中挂的都是相同大小的对象。<br>因此我们可以在Span结构中再增加一个<code>_objSize</code>成员，该成员代表着这个span管理的内存块被切成的一个个对象的大小。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Span</span><span class="token punctuation">{</span>PAGE_ID _pageId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//大块内存起始页的页号</span>size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//页的数量</span>Span<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//双链表结构</span>Span<span class="token operator">*</span> _prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>size_t objSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//切好的小对象的内存的大小</span>size_t _useCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//切好的小块内存，被分配给thread cache的计数</span><span class="token keyword">void</span><span class="token operator">*</span> _freeList <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">//切好的小块内存的自由链表</span><span class="token keyword">bool</span> _isUse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//是否在使用</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而所有的span都是从page cache中拿出来的，因此每当我们调用NewSpan获取到一个k页的span时，就应该将这个span的<code>_objSize</code>保存下来。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeAlignment</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_objSize <span class="token operator">=</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码中有两处，一处是在central cache中获取非空span时，如果central cache对应的桶中没有非空的span，此时会调用NewSpan获取一个k页的span；另一处是当申请大于256KB内存时，会直接调用NewSpan获取一个k页的span。</p><p>此时当我们释放对象时，就可以直接从对象的span中获取到该对象的大小，准确来说获取到的是对齐以后的大小。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里释放的时候可以直接获取到span的size</span>size_t size <span class="token operator">=</span> span<span class="token operator">-&gt;</span>objSize<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//指针转换成页号</span><span class="token comment">//还回去的时候要加锁</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pagemtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取映射关系时的加锁问题"><a href="#读取映射关系时的加锁问题" class="headerlink" title="读取映射关系时的加锁问题"></a>读取映射关系时的加锁问题</h3><p>我们将页号与span之间的映射关系是存储在PageCache类当中的，当我们访问这个映射关系时是需要加锁的，因为STL容器是不保证线程安全的。</p><p>对于当前代码来说，如果我们此时正在page cache进行相关操作，那么访问这个映射关系是安全的，因为当进入page cache之前是需要加锁的，我们曾经是先解掉了central的桶锁，然后是加上了page锁，因此可以保证此时只有一个线程在进行访问。</p><p>但如果我们是在central cache访问这个映射关系，或是在调用ConcurrentFree函数释放内存时访问这个映射关系，那么就存在线程安全的问题，<strong>因为我要去读，但是有可能别人在写，所以说可能会造成了读的时候也在写，万一对方把这个节点删掉了，我还在读，这肯定是会出现线程安全问题的</strong>。因为此时可能其他线程正在page cache当中进行某些操作，并且该线程此时可能也在访问这个映射关系，因此当我们在page cache外部访问这个映射关系时是需要加锁的。</p><p>实际就是在调用page cache对外提供访问映射关系的函数时需要加锁，这里我们可以考虑使用C++当中的unique_lock，当然你也可以用普通的锁。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问的时候要加锁，这里使用unique锁，因为出了作用域可以自己解锁，使用方便</span>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>_pagemtx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多线程环境下对比malloc测试"><a href="#多线程环境下对比malloc测试" class="headerlink" title="多线程环境下对比malloc测试"></a>多线程环境下对比malloc测试</h2><p>之前我们只是对代码进行了一些基础的单元测试，下面我们在多线程场景下对比malloc进行测试。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BenchmarkMalloc</span><span class="token punctuation">(</span>size_t ntimes<span class="token punctuation">,</span> size_t nworks<span class="token punctuation">,</span> size_t rounds<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">vthread</span><span class="token punctuation">(</span>nworks<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> malloc_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> free_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nworks<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>vthread<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> k<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>ntimes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v.push_back(malloc((16 + i) % 8192 + 1));</span><span class="token punctuation">}</span>size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">free</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>malloc_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span>free_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vthread<span class="token punctuation">)</span><span class="token punctuation">{</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次malloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次free %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发malloc&amp;free %u次，总计花费：%u ms\n"</span><span class="token punctuation">,</span>nworks<span class="token punctuation">,</span> nworks<span class="token operator">*</span>rounds<span class="token operator">*</span>ntimes<span class="token punctuation">,</span> malloc_costtime <span class="token operator">+</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">BenchmarkConcurrentMalloc</span><span class="token punctuation">(</span>size_t ntimes<span class="token punctuation">,</span> size_t nworks<span class="token punctuation">,</span> size_t rounds<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">vthread</span><span class="token punctuation">(</span>nworks<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> malloc_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> free_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nworks<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>vthread<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>ntimes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v.push_back(ConcurrentAlloc((16 + i) % 8192 + 1));</span><span class="token punctuation">}</span>size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>malloc_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span>free_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vthread<span class="token punctuation">)</span><span class="token punctuation">{</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次concurrent alloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次concurrent dealloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发concurrent alloc&amp;dealloc %u次，总计花费：%u ms\n"</span><span class="token punctuation">,</span>nworks<span class="token punctuation">,</span> nworks<span class="token operator">*</span>rounds<span class="token operator">*</span>ntimes<span class="token punctuation">,</span> malloc_costtime <span class="token operator">+</span> free_costtime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>size_t n <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=========================================================="</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token function">BenchmarkConcurrentMalloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">BenchmarkMalloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=========================================================="</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中测试函数各个参数的含义如下：</p><blockquote><p><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ntimes：单轮次申请和释放内存的次数。<br><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> nworks：线程数。<br><span class="github-emoji"><span>🍉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f349.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> rounds：轮次。</p></blockquote><p>在测试函数中，我们通过clock函数分别获取到每轮次申请和释放所花费的时间，然后将其对应累加到malloc_costtime和free_costtime上。最后我们就得到了，nworks个线程跑rounds轮，每轮申请和释放ntimes次，这个过程申请所消耗的时间、释放所消耗的时间、申请和释放总共消耗的时间。</p><p>注意，我们创建线程时让线程执行的是lambda表达式，而我们这里在使用lambda表达式时，以值传递的方式捕捉了变量k，以引用传递的方式捕捉了其他父作用域中的变量，因此我们可以将各个线程消耗的时间累加到一起。</p><p>我们将所有线程申请内存消耗的时间都累加到malloc_costtime上， 将释放内存消耗的时间都累加到free_costtime上，此时malloc_costtime和free_costtime可能被多个线程同时进行累加操作的，所以存在线程安全的问题。鉴于此，我们在定义这两个变量时使用了atomic类模板，这时对它们的操作就是原子操作了。</p><p>此时报错1：</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209042058090.png" alt="image-20220904205806900"></p><p>判断应该是printf的问题%u不能格式化输出atomic，于是这里改成cout好了</p><p>报错2：这里显示了行数</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209042055660.png" alt="image-20220904205523408"></p><p>锁定报错位置</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209042100998.png" alt="image-20220904210002816"></p><p>这就是说明pos == head</p><h3 id="当前性能对比"><a href="#当前性能对比" class="headerlink" title="当前性能对比"></a>当前性能对比</h3><p>强制一个桶里：</p><p>10000</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051137306.png" alt="image-20220905113727210"></p><p>100000</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051144597.png" alt="image-20220905114402512"></p><p>不同的桶：</p><p>1000</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051208520.png" alt="image-20220905120849440"></p><p>10000</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051209797.png" alt="image-20220905120917711"></p><p>居然是高了</p><h2 id="复杂调试技巧"><a href="#复杂调试技巧" class="headerlink" title="复杂调试技巧"></a>复杂调试技巧</h2><p>多线程调试比单线程调试要复杂得多，调试时各个线程之间会相互切换，并且每次调试切换的时机也是不固定的，这就使得调试过程变得非常难以控制。</p><p>下面给出三个调试时的小技巧：</p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>一般情况下我们可以直接运行程序，通过报错来查找问题。如果此时报的是断言错误，那么我们可以直接定位到报错的位置，然后将此处的断言改为与断言条件相反的if判断，在if语句里面打上一个断点，但注意空语句是无法打断点的，这时我们随便在if里面加上一句代码就可以打断点了。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050932564.png" alt="image-20220905093200425"></p><p>此外，条件断点也可以通过右击普通断点来进行设置。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050936880.png" alt="image-20220905093620795"></p><p>右击后即可设置相应的条件，程序运行到此处时如果满足该条件则会停下来。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050936713.png" alt="image-20220905093640627"></p><p>运行到条件断点处后，我们就可以对当前程序进行进一步分析，找出断言错误的被触发原因。</p><h3 id="查看函数栈帧"><a href="#查看函数栈帧" class="headerlink" title="查看函数栈帧"></a>查看函数栈帧</h3><p>当程序运行到断点处时，我们需要对当前位置进行分析，如果检查后发现当前函数是没有问题的，这时可能需要回到调用该函数的地方进行进一步分析，此时我们可以依次点击“调试→窗口→调用堆栈”。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050937849.png" alt="image-20220905093728747"></p><p>此时我们就可以看到当前函数栈帧的调用情况，其中黄色箭头指向的是当前所在的函数栈帧。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050936029.png" alt="image-20220905093604933"></p><p>根据根据函数栈帧我们走到了上一层，发现是这里调用了该函数</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050938831.png" alt="image-20220905093850738"></p><p>发现这里的front的prev和next都等于他自己，说明这里是空的</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050939943.png" alt="image-20220905093946878"></p><p>再往上走发现问题了，这里少写了一个，应该是判断这个桶非空之后，删除这一个桶，如果没有写[k]的话，默认就是删除了第一个桶，所以错误</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050946208.png" alt="image-20220905094659121"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//第K个桶里面有没有span</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="疑似死循环时中断程序"><a href="#疑似死循环时中断程序" class="headerlink" title="疑似死循环时中断程序"></a>疑似死循环时中断程序</h3><p>当你在某个地方设置断点后，如果迟迟没有运行到断点处，而程序也没有崩溃，这时有可能是程序进入到某个死循环了。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051144930.png" alt="image-20220905114451823"></p><p>这时我们可以依次点击“调试→全部中断”。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051145306.png" alt="image-20220905114503218"></p><h3 id="更多的BUG记录"><a href="#更多的BUG记录" class="headerlink" title="更多的BUG记录"></a>更多的BUG记录</h3><h4 id="BUG1"><a href="#BUG1" class="headerlink" title="BUG1"></a>BUG1</h4><p>再次尝试的时候发现100轮的时候没有问题，但是走到1000轮的时候出现新的问题，再次重试的时候发现新的问题，现在函数栈帧打开，找到上一级的NewSpan</p><p>第一次运行报错<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209050955605.png" alt="image-20220905095502502"></p><p>回去查找发现这里没有建立映射，因为这里是一开始pagecache还给centralcache的时候，如果桶里还有span的话要切下来，然后切走的时候需要建立span的映射，这里是桶里还有的情况下，忘记了写，下面如果桶里面灭有的情况下，反而写了，说明这里忘记了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051111158.png" alt="image-20220905111116073"></p><p>修改一下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//第K个桶里面有没有span</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>_spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Span<span class="token operator">*</span> kSpan <span class="token operator">=</span> _spanLists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span><span class="token keyword">for</span> <span class="token punctuation">(</span>PAGE_ID i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>_idSpanMap<span class="token punctuation">[</span>kSpan<span class="token operator">-&gt;</span>_pageId <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> kSpan<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BUG2"><a href="#BUG2" class="headerlink" title="BUG2"></a>BUG2</h4><p>第二次运行报错<img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051109196.png" alt="image-20220905110941093"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051122148.png" alt="image-20220905112226028"></p><p>查找之后发现是一个很难找的问题，这里放在了外面while循环，很恶心</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051140019.png" alt="image-20220905114033890"></p><p>这就导致了向前合并这里的ret和prevID虽然循环，但是是始终不变的，这就出问题，出了一堆不可预知性的 问题</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">/</span>向前合并<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//对span前后的页，尝试进行合并，缓解内存碎片问题</span>PAGE_ID prevID <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageId <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>prevID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1. 前面页号没有，不合并了</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//2. 前面相邻的span在使用，不合并了</span>Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token operator">-&gt;</span>second<span class="token operator">-&gt;</span>_isUse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//3. 超过最大span页数，也不能管理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>span<span class="token operator">-&gt;</span>_pageId <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">;</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span><span class="token comment">//对应的桶里面移除</span>_spanLists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// delete prevSpan;</span>_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="性能瓶颈分析"><a href="#性能瓶颈分析" class="headerlink" title="性能瓶颈分析"></a>性能瓶颈分析</h2><p>经过前面的测试可以看到，我们的代码此时与malloc之间还是有差距的，此时我们就应该分析分析我们当前项目的瓶颈在哪里，但这不能简单的凭感觉，我们应该用性能分析的工具来进行分析。</p><h3 id="VS编译器下性能分析的操作步骤"><a href="#VS编译器下性能分析的操作步骤" class="headerlink" title="VS编译器下性能分析的操作步骤"></a>VS编译器下性能分析的操作步骤</h3><p>VS编译器中就带有性能分析的工具的，我们可以依次点击“调试→性能和诊断”进行性能分析，注意该操作要在Debug模式下进行。</p><blockquote><p>注：VS2022中，已经没有了性能和诊断，只有这个性能探查器</p></blockquote><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051210991.png" alt="image-20220905121053895"></p><p>接下来我们选择这个</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051211009.png" alt="image-20220905121149905"></p><p>同时我们将代码中n的值由10000调成了1000，否则该分析过程可能会花费较多时间，并且将malloc的测试代码进行了屏蔽，因为我们要分析的是我们实现的高并发内存池。</p><h2 id="分析性能瓶颈"><a href="#分析性能瓶颈" class="headerlink" title="分析性能瓶颈"></a>分析性能瓶颈</h2><p>通过分析结果可以看到，光是Deallocate和MapObjectToSpan这两个函数就占用了一半多的时间。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051522832.png" alt="image-20220905152232691"></p><p>而在Deallocate函数中，调用ListTooLong函数时消耗的时间是最多的。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051523490.png" alt="image-20220905152328383"></p><p>继续往下看，在ListTooLong函数中，调用ReleaseListToSpans函数时消耗的时间是最多的。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051524535.png" alt="image-20220905152445444"></p><p>再进一步看，在ReleaseListToSpans函数中，调用MapObjectToSpan函数时消耗的时间是最多的。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051525845.png" alt="image-20220905152505752"></p><p>也就是说，最终消耗时间最多的实际就是MapObjectToSpan函数，我们这时再来看看为什么调用MapObjectToSpan函数会消耗这么多时间。通过观察我们最终发现，调用该函数时会消耗这么多时间就是因为锁的原因。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051525650.png" alt="image-20220905152523551"></p><p>因此当前项目的瓶颈点就在锁竞争上面，需要解决调用MapObjectToSpan函数访问映射关系时的加锁问题。tcmalloc当中针对这一点使用了<strong>基数树</strong>进行优化，使得在读取这个映射关系时可以做到不加锁。</p><h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>基数树实际上就是一个分层的哈希表，根据所分层数不同可分为单层基数树、二层基数树、三层基数树等。</p><h3 id="单层基数树"><a href="#单层基数树" class="headerlink" title="单层基数树"></a>单层基数树</h3><p>单层基数树实际采用的就是直接定址法，每一个页号对应span的地址就存储数组中在以该页号为下标的位置。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051441592.png" alt="image-20220905144144516"></p><p>最坏的情况下我们需要建立所有页号与其span之间的映射关系，因此这个数组中元素个数应该与页号的数目相同，数组中每个位置存储的就是对应span的指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单层基数树</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap1</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span><span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span> <span class="token comment">//需要开辟数组的大小</span>size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeClass</span><span class="token double-colon punctuation">::</span><span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按页对齐后的大小</span>array_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>alignSize <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向堆申请空间</span><span class="token function">memset</span><span class="token punctuation">(</span>array_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对申请到的内存进行清理</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//k的范围不在[0, 2^BITS-1]</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> array_<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回该页号对应的span</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//k的范围必须在[0, 2^BITS-1]</span>array_<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">//建立映射</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> array_<span class="token punctuation">;</span> <span class="token comment">//存储映射关系的数组</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span> <span class="token comment">//页的数目</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时当我们需要建立映射时就调用set函数，需要读取映射关系时，就调用get函数就行了。</p><p>代码中的非类型模板参数BITS表示存储页号最多需要比特位的个数。在32位下我们传入的是32-PAGE_SHIFT，在64位下传入的是64-PAGE_SHIFT。而其中的LENGTH成员代表的就是页号的数目，即2^BITS^</p><p>比如32位平台下，以一页大小为8K为例，此时页的数目就是2^32^ ÷ 2^13^ = 2^19^ ，因此存储页号最多需要19个比特位，此时传入非类型模板参数的值就是32 − 13 = 19。由于32位平台下指针的大小是4字节，因此该数组的大小就是2 ^19^ × 4 = 2 ^21^ = 2 M，内存消耗不大，是可行的。但如果是在64位平台下，此时该数组的大小是2 ^51^ × 8 = 2 ^54^ = 2 ^24^这显然是不可行的，实际上对于64位的平台，我们需要使用三层基数树。</p><h3 id="二层基数树"><a href="#二层基数树" class="headerlink" title="二层基数树"></a>二层基数树</h3><p>  这里还是以32位平台下，一页的大小为8K为例来说明，此时存储页号最多需要19个比特位。而二层基数树实际上就是把这19个比特位分为两次进行映射。</p><p>  比如用前5个比特位在基数树的第一层进行映射，映射后得到对应的第二层，然后用剩下的比特位在基数树的第二层进行映射，映射后最终得到该页号对应的span指针。<br><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051444068.png" alt="image-20220905144456983"></p><p>在二层基数树中，第一层的数组占用2^5^ × 4 = 2^7^ Byte空间，第二层的数组最多占用2^5^× 2^14^× 4 = 2^21^ =2M。二层基数树相比一层基数树的好处就是，一层基数树必须一开始就把2 M的数组开辟出来，而二层基数树一开始时只需将第一层的数组开辟出来，当需要进行某一页号映射时再开辟对应的第二层的数组就行了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//二层基数树</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap2</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_BITS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                <span class="token comment">//第一层对应页号的前5个比特位</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> ROOT_BITS<span class="token punctuation">;</span> <span class="token comment">//第一层存储元素的个数</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> ROOT_BITS<span class="token punctuation">;</span> <span class="token comment">//第二层对应页号的其余比特位</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span> <span class="token comment">//第二层存储元素的个数</span><span class="token comment">//第一层数组中存储的元素类型</span><span class="token keyword">struct</span> <span class="token class-name">Leaf</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Leaf<span class="token operator">*</span> root_<span class="token punctuation">[</span>ROOT_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第一层数组</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span><span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">memset</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>root_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将第一层的空间进行清理</span><span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//直接将第二层全部开辟</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>        <span class="token comment">//第一层对应的下标</span><span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//页号值不在范围或没有建立过映射</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回该页号对应span的指针</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>        <span class="token comment">//第一层对应的下标</span><span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span><span class="token function">assert</span><span class="token punctuation">(</span>i1 <span class="token operator">&lt;</span> ROOT_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">//建立该页号与对应span的映射</span><span class="token punctuation">}</span><span class="token comment">//确保映射[start,start_n-1]页号的空间是开辟好了的</span><span class="token keyword">bool</span> <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> ROOT_LENGTH<span class="token punctuation">)</span> <span class="token comment">//页号超出范围</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//第一层i1下标指向的空间未开辟</span><span class="token punctuation">{</span><span class="token comment">//开辟对应空间</span><span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Leaf<span class="token operator">&gt;</span> leafPool<span class="token punctuation">;</span>Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> <span class="token punctuation">(</span>Leaf<span class="token operator">*</span><span class="token punctuation">)</span>leafPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> leaf<span class="token punctuation">;</span><span class="token punctuation">}</span>key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span> <span class="token comment">//继续后续检查</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Ensure</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将第二层的空间全部开辟好</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此在二层基数树中有一个Ensure函数，当需要建立某一页号与其span之间的映射关系时，需要先调用该Ensure函数确保用于映射该页号的空间是开辟了的，如果没有开辟则会立即开辟。</p><p>而在32位平台下，就算将二层基数树第二层的数组全部开辟出来也就消耗了2 M 2M2M的空间，内存消耗也不算太多，因此我们可以在构造二层基数树时就把第二层的数组全部开辟出来。</p><h3 id="三层基数树"><a href="#三层基数树" class="headerlink" title="三层基数树"></a>三层基数树</h3><p>上面一层基数树和二层基数树都适用于32位平台，而对于64位的平台就需要用三层基数树了。三层基数树与二层基数树类似，三层基数树实际上就是把存储页号的若干比特位分为三次进行映射。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051446337.png" alt="image-20220905144659241"></p><p>此时只有当要建立某一页号的映射关系时，再开辟对应的数组空间，而没有建立映射的页号就可以不用开辟其对应的数组空间，此时就能在一定程度上节省内存空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//三层基数树</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap3</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_BITS <span class="token operator">=</span> <span class="token punctuation">(</span>BITS <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>       <span class="token comment">//第一、二层对应页号的比特位个数</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INTERIOR_BITS<span class="token punctuation">;</span> <span class="token comment">//第一、二层存储元素的个数</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> INTERIOR_BITS<span class="token punctuation">;</span> <span class="token comment">//第三层对应页号的比特位个数</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>         <span class="token comment">//第三层存储元素的个数</span><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>Node<span class="token operator">*</span> ptrs<span class="token punctuation">[</span>INTERIOR_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Leaf</span><span class="token punctuation">{</span><span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Node<span class="token operator">*</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> nodePool<span class="token punctuation">;</span>Node<span class="token operator">*</span> result <span class="token operator">=</span> nodePool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">memset</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token operator">*</span> root_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span><span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>root_ <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span><span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//第一层对应的下标</span><span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span><span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//第三层对应的下标</span><span class="token comment">//页号超出范围，或映射该页号的空间未开辟</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回该页号对应span的指针</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//第一层对应的下标</span><span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span><span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//第三层对应的下标</span><span class="token function">Ensure</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//确保映射第k页页号的空间是开辟好了的</span><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">//建立该页号与对应span的映射</span><span class="token punctuation">}</span><span class="token comment">//确保映射[start,start+n-1]页号的空间是开辟好了的</span><span class="token keyword">bool</span> <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//第一层对应的下标</span><span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二层对应的下标</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> INTERIOR_LENGTH <span class="token operator">||</span> i2 <span class="token operator">&gt;=</span> INTERIOR_LENGTH<span class="token punctuation">)</span> <span class="token comment">//下标值超出范围</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//第一层i1下标指向的空间未开辟</span><span class="token punctuation">{</span><span class="token comment">//开辟对应空间</span>Node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//第二层i2下标指向的空间未开辟</span><span class="token punctuation">{</span><span class="token comment">//开辟对应空间</span><span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Leaf<span class="token operator">&gt;</span> leafPool<span class="token punctuation">;</span>Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> leafPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>leaf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>leaf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span> <span class="token comment">//继续后续检查</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此当我们要建立某一页号的映射关系时，需要先确保存储该页映射的数组空间是开辟好了的，也就是调用代码中的Ensure函数，如果对应数组空间未开辟则会立马开辟对应的空间。</p><h2 id="基数树优化"><a href="#基数树优化" class="headerlink" title="基数树优化"></a>基数树优化</h2><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p>现在我们用基数树对代码进行优化，此时将PageCache类当中的unorder_map用基数树进行替换即可，由于当前是32位平台，因此这里随便用几层基数树都可以。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//单例模式</span><span class="token keyword">class</span> <span class="token class-name">PageCache</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//...</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token comment">//std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;</span>TCMalloc_PageMap1<span class="token operator">&lt;</span><span class="token number">32</span> <span class="token operator">-</span> PAGE_SHIFT<span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时当我们需要建立页号与span的映射时，就调用基数树当中的set函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageId<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 而当我们需要读取某一页号对应的span时，就调用基数树当中的get函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Span<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且现在PageCache类向外提供的，用于读取映射关系的MapObjectToSpan函数内部就不需要加锁了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取从对象到span的映射</span>Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span> <span class="token comment">//页号</span>Span<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么读取基数树映射关系时不需要加锁？"><a href="#为什么读取基数树映射关系时不需要加锁？" class="headerlink" title="为什么读取基数树映射关系时不需要加锁？"></a>为什么读取基数树映射关系时不需要加锁？</h3><p>当某个线程在读取映射关系时，可能另外一个线程正在建立其他页号的映射关系，而此时无论我们用的是C++当中的map还是<code>unordered_map</code>，在读取映射关系时都是需要加锁的。</p><p>因为C++中map的底层数据结构是红黑树，<code>unordered_map</code>的底层数据结构是哈希表，而无论是红黑树还是哈希表，当我们在插入数据时其底层的结构都有可能会发生变化。比如红黑树在插入数据时可能会引起树的旋转，而哈希表在插入数据时可能会引起哈希表扩容。此时要避免出现数据不一致的问题，就不能让插入操作和读取操作同时进行，因此我们在读取映射关系的时候是需要加锁的。</p><p>而对于基数树来说就不一样了，基数树的空间一旦开辟好了就不会发生变化，因此无论什么时候去读取某个页的映射，都是对应在一个固定的位置进行读取的。并且我们不会同时对同一个页进行读取映射和建立映射的操作，因为我们只有在释放对象时才需要读取映射，而建立映射的操作都是在page cache进行的。也就是说，读取映射时读取的都是对应span的<code>_useCount</code>不等于0的页，而建立映射时建立的都是对应span的<code>_useCount</code>等于0的页，所以说我们不会同时对同一个页进行读取映射和建立映射的操作。</p><h2 id="再次对比malloc进行测试"><a href="#再次对比malloc进行测试" class="headerlink" title="再次对比malloc进行测试"></a>再次对比malloc进行测试</h2><p>还是同样的代码，只不过我们用基数树对代码进行了优化，这时测试固定大小内存的申请和释放的结果如下：</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051613138.png" alt="image-20220905161327059"></p><p>可以看到，这时就算申请释放的是固定大小的对象，其效率还是不太行</p><p>下面在申请释放不同大小的对象时，由于central cache的桶锁起作用了，其效率更是变成了malloc的好几倍。</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051610479.png" alt="image-20220905161032404"></p><p>这肯定还是不对的，所以查找一下原因试试看</p><p>首先看看锁的问题，应该是比较容易看出来的</p><p>下面性能分析发现Free和Alloc都是很慢的，说明肯定是alloc的时候有问题，导致了整体的时候慢下来了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051930134.png" alt="image-20220905193025051"></p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051926113.png" alt="image-20220905192641730"></p><p>这导致了慢开始算法出错，每次都让第一个桶增长，而不会影响其他的桶</p><p>这次可以了</p><p><img src="https://cloudmage.oss-cn-shanghai.aliyuncs.com/img/202209051931940.png" alt="image-20220905193156857"></p><h2 id="打包成动静态库"><a href="#打包成动静态库" class="headerlink" title="打包成动静态库"></a>打包成动静态库</h2><p>实际Google开源的tcmalloc是会直接用于替换malloc的，不同平台替换的方式不同。比如基于Unix的系统上的glibc，使用了weak alias的方式替换；而对于某些其他平台，需要使用hook的钩子技术来做。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> THROW <span class="token function">attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span> <span class="token punctuation">(</span>tc_malloc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>于我们当前实现的项目，可以考虑将其打包成静态库或动态库。我们先右击解决方案资源管理器当中的项目名称，然后选择属性。</p><p>以上的所有代码，均已经提交到了Github中，可以参考<a href="https://github.com/Allen9012/ConcurrentMemoryPool">https://github.com/Allen9012/ConcurrentMemoryPool</a></p><p>参考资料：</p><p><a href="https://www.cnblogs.com/persistentsnail/p/3442185.html">https://www.cnblogs.com/persistentsnail/p/3442185.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/29216091">https://zhuanlan.zhihu.com/p/29216091</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/122819562?spm=1001.2014.3001.5502">https://blog.csdn.net/chenlong_cxy/article/details/122819562?spm=1001.2014.3001.5502</a></p><p><a href="https://zhuanlan.zhihu.com/p/384022573">一文了解，Linux内存管理，malloc、free 实现原理</a></p><p><a href="http://azhao.net/index.php/archives/81/">malloc()背后的实现原理——内存池</a></p><p><a href="https://blog.csdn.net/z_ryan/article/details/79950737">malloc的底层实现（ptmalloc）</a></p><p><a href="https://www.cnblogs.com/xixixing/p/16049270.html">C++中出现_CrtlsValidHeapPointer(block)错误</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;为了学习和提高设计能力，检验编程思想以及编程能力，以下开始学习并探究实现高并发内存池项目&lt;</summary>
      
    
    
    
    
    <category term="项目" scheme="https://allen9012.github.io/BlogNet/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
</feed>
